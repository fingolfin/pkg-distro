% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{latexsym,xypic}	


\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{XModAlg}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{XModAlg}}
\markright{\scriptsize \mbox{}\hfill \textsf{XModAlg} \hfill\mbox{}}
{\Huge \textbf{Crossed modules and cat1-algebras of commutative algebras\mbox{}}}\\
\vfill

{\Huge Version 1.12\mbox{}}\\[1cm]
{14/11/2015\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Zekeriya Arvasi    \mbox{}}}\\
{\Large \textbf{ Alper Odaba{\c s}    \mbox{}}}\\
\hypersetup{pdfauthor= Zekeriya Arvasi    ;  Alper Odaba{\c s}    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Zekeriya Arvasi    }  Email: \href{mailto://zarvasi@ogu.edu.tr} {\texttt{zarvasi@ogu.edu.tr}}\\
  Homepage: \href{http://fef.ogu.edu.tr/zarvasi} {\texttt{http://fef.ogu.edu.tr/zarvasi}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematics and Computer Science,\\
 Osmangazi University, Eski{\c s}ehir, Turkey \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Alper Odaba{\c s}    }  Email: \href{mailto://aodabas@ogu.edu.tr} {\texttt{aodabas@ogu.edu.tr}}\\
  Homepage: \href{http://fef.ogu.edu.tr/matbil/aodabas/} {\texttt{http://fef.ogu.edu.tr/matbil/aodabas/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematics and Computer Science,\\
 Osmangazi University, Eski{\c s}ehir, Turkey \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 The \textsf{XModAlg} package provides functions for computation with crossed modules of commutative
algebras and cat$^{1}$-algebras). The current version is 1.12, released 14th November 2015 for \textsf{GAP} 4.7. 

 Bug reports, suggestions and comments are, of course, welcome. Please contact
the second author at \href{mailto://aodabas@ogu.edu.tr} {\texttt{aodabas@ogu.edu.tr}}. \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 \index{License} {\copyright} 2014-2015 Zekeriya Arvasi and Alper Odabas. \textsf{XModAlg} is free software; you can redistribute it and/or modify it under the terms of
the \href{http://www.fsf.org/licenses/gpl.html} {GNU General Public License} as published by the Free Software Foundation; either version 2 of the License,
or any later version. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 This documentation was prepared with the \textsf{GAPDoc} package of Frank L{\"u}beck and Max Neunh{\"o}ffer. 

 Both authors are very grateful to \href{http://pages.bangor.ac.uk/~mas023/} {Chris Wensley} for helpful suggestions. 

 This work was partially supported by T{\"U}B{\.I}TAK (The Scientific and
Technical Research Council of Turkey), project number 107T542. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

             
\chapter{\textcolor{Chapter }{Introduction}}\label{Intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  In 1950 S. MacLane and J.H.C. Whitehead, \cite{whitehead} suggested that crossed modules modeled homotopy $2$-types. Later crossed modules have been considered as $2$\emph{-dimensional groups}, \cite{brown1}, \cite{brown2}. The commutative algebra version of this construction has been adapted by T.
Porter, \cite{arvasi2}, \cite{porter1}. This algebraic version is called \emph{combinatorial algebra theory}, which contains potentially important new ideas (see \cite{arvasi2}, \cite{arvasi3}, \cite{arvasi4}). 

 A share package \textsf{XMod}, \cite{alp3}, \cite{alp2}, was prepared by M. Alp and C.D. Wensley for the \textsf{GAP} computational group theory language, initially for \textsf{GAP}3 then revised for \textsf{GAP}4. The $2$-dimensional part of this programme contains functions for computing crossed
modules and cat$^{1}$-groups and their morphisms \cite{alp3}. 

 This package includes functions for computing crossed modules of algebras, cat$^{1}$-algebras and their morphisms by analogy with \emph{computational group theory}. We will concentrate on group rings over of abelian groups over finite fields
because these algebras are conveniently implemented in \textsf{GAP}. The tools needed are the group algebras in which the group algebra functor $\mathcal{K}(.):Gr\rightarrow Alg$ is left adjoint to the unit group functor $\mathcal{U}(.):Alg\rightarrow Gr$. 

 The categories \texttt{XModAlg} (crossed modules of algebras) and \texttt{Cat1Alg} (cat$^{1}$-algebras) are equivalent, and we include functions to convert objects and
morphisms between them. The algorithms implemented in this package are
analyzed in A. Odabas's Ph.D. thesis, \cite{aodabas1} and described in detail in the paper \cite{arvasi_odabas}. 

 There are aspects of commutative algebras for which no \textsf{GAP} functions yet exist, for example semidirect products. We have included here
functions for all homomorphisms of algebras. }

            
\chapter{\textcolor{Chapter }{Crossed modules}}\label{chap-xmod}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X808C6B357F8BADC1}{}
{
  In this chapter we will present the notion of crossed modules of commutative
algebras and their implementation in this package. 
\section{\textcolor{Chapter }{Definition and Examples}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7BB9D67179296AA0}{}
{
  \index{crossed module} \index{2d-algebra} Let \textsc{k} be a fixed commutative ring with $1 \neq 0$. From now on, all \textsc{k}-algebras will be associative and commutative. 

 A \emph{crossed module} is a \textsc{k}-algebra morphism $\mathcal{X}:=(\partial:S\rightarrow R)$ with an action of $R$ on $S$ satisfying 
\[ {\bf XModAlg\ 1} ~:~ \partial(r \cdot s) = r(\partial s), \qquad {\bf XModAlg\
2} ~:~ (\partial s) \cdot s^{\prime} = ss^{\prime}, \]
 for all $s,s^{\prime }\in S, \ r\in R$. The morphism $\partial$ is called the \emph{boundary map} of $\mathcal{X}$ 

 In this definition we used the left action notation. In the category of
commutative algebras the right and the left actions coincide. 

 We can produce crossed modules by using the following methods. 

\subsection{\textcolor{Chapter }{XModAlgebra}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X813D94F97D8E71A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebra({\mdseries\slshape args})\index{XModAlgebra@\texttt{XModAlgebra}}
\label{XModAlgebra}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraByBoundaryAndAction({\mdseries\slshape bdy, act})\index{XModAlgebraByBoundaryAndAction@\texttt{XModAlgebraByBoundaryAndAction}}
\label{XModAlgebraByBoundaryAndAction}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraByIdeal({\mdseries\slshape A, I})\index{XModAlgebraByIdeal@\texttt{XModAlgebraByIdeal}}
\label{XModAlgebraByIdeal}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraByModule({\mdseries\slshape M, R})\index{XModAlgebraByModule@\texttt{XModAlgebraByModule}}
\label{XModAlgebraByModule}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraByCentralExtension({\mdseries\slshape f})\index{XModAlgebraByCentralExtension@\texttt{XModAlgebraByCentralExtension}}
\label{XModAlgebraByCentralExtension}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraByMultipleAlgebra({\mdseries\slshape A})\index{XModAlgebraByMultipleAlgebra@\texttt{XModAlgebraByMultipleAlgebra}}
\label{XModAlgebraByMultipleAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Here are the standard constructions which these operations implement: 
\begin{itemize}
\item  Let $A$ be an algebra and $I$ an ideal of $A$. Then $\mathcal{X} = (inc:I\rightarrow A)$ is a crossed module with the multiplication action of $A$ on $I$. Conversely, given a crossed module $\mathcal{X} = (\partial : S \rightarrow R)$, it is the case that ${\partial(S)}$ is an ideal of $R$. 
\item  Let $M$ be a $R$-module. Then $\mathcal{X} = (0:M\rightarrow R)$ is a crossed module. Conversely, given a crossed module $\mathcal{X} = (\partial :M\rightarrow R)$, one can get that $\ker\partial$ is a $(R/\partial M)$-module. 
\item  Let $\partial : S\rightarrow R$ be a surjective algebra homomorphism. Define the action of $R$ on $S$ by $r\cdot s = \widetilde{r}s$ where $\widetilde{r} \in \partial^{-1}(r)$. Then $\mathcal{X}=(\partial : S\rightarrow R)$ is a crossed module with the defined action. 
\item  Let $S$ be a \textsc{k}-algebra such that $Ann(S)=0$ or $S^{2} = S$. Then $\partial : S\rightarrow M(S)$ is a crossed module, where $M(S)$ is the algebra of multipliers of $S$ and $\partial $ is the canonical homomorphism, \cite{arvasi4}. 
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape X0})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape X0})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Boundary({\mdseries\slshape X0})\index{Boundary@\texttt{Boundary}}
\label{Boundary}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraAction({\mdseries\slshape X0})\index{XModAlgebraAction@\texttt{XModAlgebraAction}}
\label{XModAlgebraAction}
}\hfill{\scriptsize (attribute)}}\\


 These four attributes are used in the construction of a crossed module $\mathcal{X}$ where: 
\begin{itemize}
\item  \texttt{Source(X)} and \texttt{Range(X)} are the \emph{source} and the \emph{range} of the boundary map respectively; 
\item  \texttt{Boundary(X)} is the boundary map of the crossed module $\mathcal{X}$; 
\item  \texttt{XModAlgebraAction(X)} is the action used in the crossed module. 
\end{itemize}
 The following standard \textsf{GAP} operations have special \textsf{XModAlg} implementations: 
\begin{itemize}
\item  \texttt{Display(X)} is used to list the components of $\mathcal{X}$; 
\item  \texttt{Size(X)} is used for calculating the order of the crossed module $\mathcal{X}$; 
\item  \texttt{Name(X)} is used for giving a name to the crossed module $\mathcal{X}$ by associating the names of source and range algebras. 
\end{itemize}
 In the following example, we construct a crossed module by using the algebra $GF_{5}D_{4}$ and its augmentation ideal. We also show usage of the attributes listed above. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@A := GroupRing(GF(5),DihedralGroup(4));|
  <algebra-with-one over GF(5), with 2 generators>
  !gapprompt@gap>| !gapinput@Size(A);|
  625
  !gapprompt@gap>| !gapinput@SetName(A,"GF5[D4]");|
  !gapprompt@gap>| !gapinput@I := AugmentationIdeal(A);|
  <two-sided ideal in GF5[D4], (2 generators)>
  !gapprompt@gap>| !gapinput@Size(I);|
  125
  !gapprompt@gap>| !gapinput@SetName(I,"Aug");|
  !gapprompt@gap>| !gapinput@CM := XModAlgebraByIdeal(A,I);|
  [Aug->GF5[D4]]
  !gapprompt@gap>| !gapinput@Display(CM);|
  
  Crossed module [Aug->GF5[D4]] :- 
  : Source algebra Aug has generators:
    [ (Z(5)^2)*<identity> of ...+(Z(5)^0)*f1, (Z(5)^2)*<identity> of ...
    +(Z(5)^0)*f2 ]
  : Range algebra GF5[D4] has generators:
    [ (Z(5)^0)*<identity> of ..., (Z(5)^0)*f1, (Z(5)^0)*f2 ]
  : Boundary homomorphism maps source generators to:
    [ (Z(5)^2)*<identity> of ...+(Z(5)^0)*f1, (Z(5)^2)*<identity> of ...
    +(Z(5)^0)*f2 ]
  
  !gapprompt@gap>| !gapinput@Size(CM);|
  [ 125, 625 ]
  !gapprompt@gap>| !gapinput@f := Boundary(CM);|
  MappingByFunction( Aug, GF5[D4], function( i ) ... end )
  !gapprompt@gap>| !gapinput@Print( RepresentationsOfObject(CM), "\n" ); |
  [ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPreXModAlgebraObj" ]
  !gapprompt@gap>| !gapinput@props := [ "CanEasilyCompareElements", "CanEasilySortElements", |
  !gapprompt@>| !gapinput@ "IsDuplicateFree", "IsLeftActedOnByDivisionRing", "IsAdditivelyCommutative", |
  !gapprompt@>| !gapinput@ "IsLDistributive", "IsRDistributive", "IsPreXModDomain", "Is2dAlgebraObject", |
  !gapprompt@>| !gapinput@ "IsPreXModAlgebra", "IsXModAlgebra" ];;|
  !gapprompt@gap>| !gapinput@known := KnownPropertiesOfObject(CM);;|
  !gapprompt@gap>| !gapinput@ForAll( props, p -> (p in known) );|
  true 
  !gapprompt@gap>| !gapinput@Print( KnownAttributesOfObject(CM), "\n" ); |
  [ "Name", "Size", "Range", "Source", "Boundary", "XModAlgebraAction" ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{SubXModAlgebra}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X7CA213397B334CBC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubXModAlgebra({\mdseries\slshape X0})\index{SubXModAlgebra@\texttt{SubXModAlgebra}}
\label{SubXModAlgebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubXModAlgebra({\mdseries\slshape X0})\index{IsSubXModAlgebra@\texttt{IsSubXModAlgebra}}
\label{IsSubXModAlgebra}
}\hfill{\scriptsize (operation)}}\\


 A crossed module $\mathcal{X}^{\prime } = (\partial ^{\prime }:S^{\prime}\rightarrow R^{\prime
})$ is a subcrossed module of the crossed module $\mathcal{X} = (\partial :S\rightarrow R)$ if $S^{\prime }\leq S$, $R^{\prime}\leq R$, $\partial^{\prime } = \partial|_{S^{\prime }}$, and the action of $S^{\prime }$ on $R^{\prime }$ is induced by the action of $R$ on $S$. The operation \texttt{SubXModAlgebra} is used to construct a subcrossed module of a given crossed module. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@e4 := Elements(I)[4];|
  (Z(5)^0)*<identity> of ...+(Z(5)^0)*f1+(Z(5)^2)*f2+(Z(5)^2)*f1*f2
  !gapprompt@gap>| !gapinput@J := Ideal( I, [e4] );|
  <two-sided ideal in Aug, (1 generators)>
  !gapprompt@gap>| !gapinput@Size(J);|
  5
  !gapprompt@gap>| !gapinput@SetName( J, "<e4>" ); |
  !gapprompt@gap>| !gapinput@PM := XModAlgebraByIdeal( A, J );|
  [<e4>->GF5[D4]]
  !gapprompt@gap>| !gapinput@Display( PM );        |
  
  Crossed module [<e4>->GF5[D4]] :- 
  : Source algebra <e4> has generators:
    [ (Z(5)^0)*<identity> of ...+(Z(5)^0)*f1+(Z(5)^2)*f2+(Z(5)^2)*f1*f2 ]
  : Range algebra GF5[D(4)] has generators:
    [ (Z(5)^0)*<identity> of ..., (Z(5)^0)*f1, (Z(5)^0)*f2 ]
  : Boundary homomorphism maps source generators to:
    [ (Z(5)^0)*<identity> of ...+(Z(5)^0)*f1+(Z(5)^2)*f2+(Z(5)^2)*f1*f2 ]
  
  !gapprompt@gap>| !gapinput@IsSubXModAlgebra( CM, PM );|
  true
  
\end{Verbatim}
 \index{precrossed module} 

\subsection{\textcolor{Chapter }{PreXModAlgebraByBoundaryAndAction}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X813B894B7C2E8BAB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreXModAlgebraByBoundaryAndAction({\mdseries\slshape bdy, act})\index{PreXModAlgebraByBoundaryAndAction@\texttt{PreXModAlgebraByBoundaryAndAction}}
\label{PreXModAlgebraByBoundaryAndAction}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreXModAlgebra({\mdseries\slshape X0})\index{IsPreXModAlgebra@\texttt{IsPreXModAlgebra}}
\label{IsPreXModAlgebra}
}\hfill{\scriptsize (property)}}\\


 An $R$-algebra homomorphism $\mathcal{X} := (\partial : S \rightarrow R)$ which satisfy the condition ${\bf XModAlg\ 1}$ is called a \emph{precrossed module}. The details of these implementations can be found in \cite{aodabas1}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SmallGroup(4,2);|
  <pc group of size 4 with 2 generators>
  !gapprompt@gap>| !gapinput@F := GaloisField(4);|
  GF(2^2)
  !gapprompt@gap>| !gapinput@R := GroupRing( F, G );|
  <algebra-with-one over GF(2^2), with 2 generators>
  !gapprompt@gap>| !gapinput@Size(R);|
  256
  !gapprompt@gap>| !gapinput@SetName( R, "GF(2^2)[k4]" ); |
  !gapprompt@gap>| !gapinput@e5 := Elements(R)[5]; |
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@S := Subalgebra( R, [e5] ); |
  <algebra over GF(2^2), with 1 generators>
  !gapprompt@gap>| !gapinput@SetName( S, "<e5>" );|
  !gapprompt@gap>| !gapinput@RS := Cartesian( R, S );; |
  !gapprompt@gap>| !gapinput@SetName( RS, "GF(2^2)[k4] x <e5>" ); |
  !gapprompt@gap>| !gapinput@act := AlgebraAction( R, RS, S );;|
  !gapprompt@gap>| !gapinput@bdy := AlgebraHomomorphismByFunction( S, R, r->r );|
  MappingByFunction( <e5>, GF(2^2)[k4], function( r ) ... end )
  !gapprompt@gap>| !gapinput@IsAlgebraAction( act ); |
  true
  !gapprompt@gap>| !gapinput@IsAlgebraHomomorphism( bdy );|
  true
  !gapprompt@gap>| !gapinput@XM := PreXModAlgebraByBoundaryAndAction( bdy, act );|
  [<e5>->GF(2^2)[k4]]
  !gapprompt@gap>| !gapinput@IsXModAlgebra( XM );|
  true
  !gapprompt@gap>| !gapinput@Display( XM );|
  
  Crossed module [<e5>->GF(2^2)[k4]] :- 
  : Source algebra has generators:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2 ]
  : Range algebra GF(2^2)[k4] has generators:
    [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  : Boundary homomorphism maps source generators to:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2 ]
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{(Pre-)Crossed Module Morphisms}}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X866610BC7C41E1EC}{}
{
 Let $\mathcal{X} = (\partial:S\rightarrow R)$, $\mathcal{X}^{\prime} = (\partial^{\prime }:S^{\prime }\rightarrow R^{\prime })$ be (pre)crossed modules and $\theta :S\rightarrow S^{\prime }$, $\varphi : R\rightarrow R^{\prime }$ be algebra homomorphisms. If 
\[ \varphi \circ \partial = \partial ^{\prime } \circ \theta, \qquad \theta
(r\cdot s)=\varphi(r) \cdot \theta (s), \]
 for all $r\in R$, $s\in S,$ then the pair $(\theta ,\varphi )$ is called a morphism between $\mathcal{X}$ and $\mathcal{X}^{\prime } $ 

 The conditions can be thought as the commutativity of the following diagrams: 
\[ \xymatrix@R=40pt@C=40pt{ S \ar[d]_{\partial} \ar[r]^{\theta} & S^{\prime }
\ar[d]^{\partial^{\prime }} \\ R \ar[r]_{\varphi} & R^{\prime } } \ \ \ \
\xymatrix@R=40pt@C=40pt{ R \times S \ar[d] \ar[r]^{ \varphi \times \theta } &
R^{\prime } \times S^{\prime } \ar[d] \\ S \ar[r]_{ \theta } & S^{\prime }. } \]
    

 In \textsf{GAP} we define the morphisms between algebraic structures such as cat$^{1}$-algebras and crossed modules and they are investigated by the function \texttt{Make2AlgMorphism}. 

\subsection{\textcolor{Chapter }{XModAlgebraMorphism}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X7D575D07810640EB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraMorphism({\mdseries\slshape arg})\index{XModAlgebraMorphism@\texttt{XModAlgebraMorphism}}
\label{XModAlgebraMorphism}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IdentityMapping({\mdseries\slshape X0})\index{IdentityMapping@\texttt{IdentityMapping}}
\label{IdentityMapping}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreXModAlgebraMorphismByHoms({\mdseries\slshape f, g})\index{PreXModAlgebraMorphismByHoms@\texttt{PreXModAlgebraMorphismByHoms}}
\label{PreXModAlgebraMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraMorphismByHoms({\mdseries\slshape f, g})\index{XModAlgebraMorphismByHoms@\texttt{XModAlgebraMorphismByHoms}}
\label{XModAlgebraMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreXModAlgebraMorphism({\mdseries\slshape f})\index{IsPreXModAlgebraMorphism@\texttt{IsPreXModAlgebraMorphism}}
\label{IsPreXModAlgebraMorphism}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsXModAlgebraMorphism({\mdseries\slshape f})\index{IsXModAlgebraMorphism@\texttt{IsXModAlgebraMorphism}}
\label{IsXModAlgebraMorphism}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape m})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape m})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsTotal({\mdseries\slshape m})\index{IsTotal@\texttt{IsTotal}}
\label{IsTotal}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSingleValued({\mdseries\slshape m})\index{IsSingleValued@\texttt{IsSingleValued}}
\label{IsSingleValued}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Name({\mdseries\slshape m})\index{Name@\texttt{Name}}
\label{Name}
}\hfill{\scriptsize (attribute)}}\\


 These operations construct crossed module homomorphisms, which may have the
attributes listed. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@A:=GroupRing(GF(2),CyclicGroup(4));|
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@B:=AugmentationIdeal(A);|
  <two-sided ideal in <algebra-with-one over GF(2), with 2 generators>, 
  (dimension 3)>
  !gapprompt@gap>| !gapinput@X1:=XModAlgebra(A,B);|
  [Algebra( GF(2), [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, 
  (Z(2)^0)*f1+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f1*f2
   ] )->AlgebraWithOne( GF(2), [ (Z(2)^0)*f1, (Z(2)^0)*f2 ] )]
  !gapprompt@gap>| !gapinput@C:=GroupRing(GF(2),SmallGroup(4,2));|
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@D:=AugmentationIdeal(C);|
  <two-sided ideal in <algebra-with-one over GF(2), with 2 generators>, 
  (dimension 3)>
  !gapprompt@gap>| !gapinput@X2:=XModAlgebra(C,D);|
  [Algebra( GF(2), [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, 
  (Z(2)^0)*f1+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f1*f2
   ] )->AlgebraWithOne( GF(2), [ (Z(2)^0)*f1, (Z(2)^0)*f2 ] )]
  !gapprompt@gap>| !gapinput@B = D;|
  false
  !gapprompt@gap>| !gapinput@all_f := AllHomsOfAlgebras(A,C);;|
  !gapprompt@gap>| !gapinput@all_g := AllHomsOfAlgebras(B,D);;|
  !gapprompt@gap>| !gapinput@mor := XModAlgebraMorphism(X1,X2,all_g[1],all_f[2]);|
  [[..] => [..]]
  !gapprompt@gap>| !gapinput@Display(mor);|
  
  Morphism of crossed modules :-
  : Source = [Algebra( GF(2), [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, 
    (Z(2)^0)*f1+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f1*f2 ] )->AlgebraWithOne( GF(2), 
    [ (Z(2)^0)*f1, (Z(2)^0)*f2 ] )] with generating sets:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, (Z(2)^0)*f1+(Z(2)^0)*f2, 
    (Z(2)^0)*f2+(Z(2)^0)*f1*f2 ]
    [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  :  Range = [Algebra( GF(2), [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, 
    (Z(2)^0)*f1+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f1*f2 ] )->AlgebraWithOne( GF(2), 
    [ (Z(2)^0)*f1, (Z(2)^0)*f2 ] )] with generating sets:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, (Z(2)^0)*f1+(Z(2)^0)*f2, 
    (Z(2)^0)*f2+(Z(2)^0)*f1*f2 ] 
    [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  : Source Homomorphism maps source generators to:
    [ <zero> of ..., <zero> of ..., <zero> of ... ]
  : Range Homomorphism maps range generators to:
    [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*<identity> of ..., 
    (Z(2)^0)*<identity> of ... ]
  
  !gapprompt@gap>| !gapinput@IsTotal(mor);|
  true
  !gapprompt@gap>| !gapinput@IsSingleValued(mor);|
  true
  
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Kernel}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X7DCD99628504B810}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Kernel({\mdseries\slshape X0})\index{Kernel@\texttt{Kernel}}
\label{Kernel}
}\hfill{\scriptsize (operation)}}\\


 Let $(\theta,\varphi) : \mathcal{X} = (\partial : S \rightarrow R) \rightarrow
\mathcal{X}^{\prime} = (\partial^{\prime} : S^{\prime} \rightarrow R^{\prime})$ be a crossed module homomorphism. Then the crossed module 
\[ \ker(\theta,\varphi) = (\partial| : \ker\theta \rightarrow \ker\varphi ) \]
 is called the \emph{kernel} of $(\theta,\varphi)$. Also, $\ker(\theta ,\varphi )$ is an ideal of $\mathcal{X}$. An example is given below. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@X3 := Kernel(mor);|
  [Algebra( GF(2), [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, 
  (Z(2)^0)*f1+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f1*f2
   ] )->Algebra( GF(2), [ (Z(2)^0)*f1+(Z(2)^0)*f2, 
   (Z(2)^0)*f1+(Z(2)^0)*f1*f2, (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1
   ] )]
  !gapprompt@gap>| !gapinput@IsXModAlgebra(X3);|
  true
  !gapprompt@gap>| !gapinput@Size(X3);|
  [ 8, 8 ]
  !gapprompt@gap>| !gapinput@IsSubXModAlgebra(X1,X3);|
  true
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Image}}
\logpage{[ 2, 2, 3 ]}\nobreak
\hyperdef{L}{X87F4D35A826599C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Image({\mdseries\slshape X0})\index{Image@\texttt{Image}}
\label{Image}
}\hfill{\scriptsize (operation)}}\\


 Let $(\theta,\varphi) : \mathcal{X} = (\partial : S \rightarrow R) \rightarrow
\mathcal{X}^{\prime} = (\partial^{\prime} : S^{\prime} \rightarrow R^{\prime})$ be a crossed module homomorphism. Then the crossed module 
\[ \mathop{\textrm{Im}\rm}(\theta,\varphi) = (\partial^{\prime}| :
\mathop{\textrm{Im}\rm}\theta \rightarrow \mathop{\textrm{Im}\rm}\varphi) \]
 is called the image of $(\theta,\varphi)$. Further, $\mathop{\textrm{Im}\rm}(\theta,\varphi)$ is a subcrossed module of $(S^{\prime},R^{\prime},\partial^{\prime})$. 

 In our package, the image of a crossed module homomorphism can be obtained by
the command \texttt{Image2dAlgMapping}. The operation \texttt{Sub2dAlgObject} is effectively used for finding the kernel and image crossed modules induced
from a given crossed module homomorphism. }

 

\subsection{\textcolor{Chapter }{SourceHom}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X7B7975DA7E870690}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SourceHom({\mdseries\slshape m})\index{SourceHom@\texttt{SourceHom}}
\label{SourceHom}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RangeHom({\mdseries\slshape m})\index{RangeHom@\texttt{RangeHom}}
\label{RangeHom}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsInjective({\mdseries\slshape m})\index{IsInjective@\texttt{IsInjective}}
\label{IsInjective}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSurjective({\mdseries\slshape m})\index{IsSurjective@\texttt{IsSurjective}}
\label{IsSurjective}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsBijjective({\mdseries\slshape m})\index{IsBijjective@\texttt{IsBijjective}}
\label{IsBijjective}
}\hfill{\scriptsize (property)}}\\


 Let $(\theta,\varphi)$ be a homomorphism of crossed modules. If the homomorphisms $\theta$ and $\varphi$ are injective (surjective) then $(\theta,\varphi)$ is injective (surjective). 

 The attributes \texttt{SourceHom} and \texttt{RangeHom} store the two algebra homomorphisms $\theta$ and $\varphi$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@theta := SourceHom(mor);|
  [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, (Z(2)^0)*f1+(Z(2)^0)*f2, 
  (Z(2)^0)*f2+(Z(2)^0)*f1*f2 ] ->
  [ <zero> of ..., <zero> of ..., <zero> of ... ]
  !gapprompt@gap>| !gapinput@phi := RangeHom(mor);|
  [ (Z(2)^0)*f1 ] -> [ (Z(2)^0)*<identity> of ... ]
  !gapprompt@gap>| !gapinput@IsInjective(mor);|
  false
  !gapprompt@gap>| !gapinput@IsSurjective(mor);|
  false
  
\end{Verbatim}
 }

 }

            
\chapter{\textcolor{Chapter }{Cat1-algebras}}\label{chap-cat1}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X85527BA8786CB7FC}{}
{
  
\section{\textcolor{Chapter }{Definitions and examples}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X811B6B0F8203F972}{}
{
  \index{cat1-group} Algebraic structures which are equivalent to crossed modules of algebras
include : 
\begin{itemize}
\item  cat$^{1}$-algebras. (Ellis, \cite{ellis1}); 
\item  simplicial algebras with Moore complex of length 1 (Z. Arvasi and T.Porter, \cite{arvasi2}); 
\item  algebra-algebroids (Gaffar Musa's Ph.D. thesis, \cite{mosa}). 
\end{itemize}
 In this section we describe an implementation of cat$^{1}$-algebras and their morphisms. 

 The notion of cat$^{1}$-groups was defined as an algebraic model of $2$-types by Loday in \cite{loday}. Then Ellis defined the cat$^{1}$-algebras in \cite{ellis1}. 

 Let $A$ and $R$ be $k$-algebras, let $t,h:A\rightarrow R$ be surjections, and let $e:R\rightarrow A$ be an inclusion. 
\[ \xymatrix@R=50pt@C=50pt{ A \ar@{->}@<-1.5pt>[d]_{t} \ar@{->}@<1.5pt>[d]^{h} \\
R \ar@/^1.5pc/[u]^{e} } \]
 If the conditions, 
\[ \mathbf{Cat1Alg1:} \quad te = id_{R} = he, \qquad \mathbf{Cat1Alg2:} \quad
(\ker t)(\ker h) = \{0_{A}\} \]
 are satisfied, then the algebraic system $\mathcal{C} := (e;t,h : A \rightarrow R)$ is called a cat$^{1}$-algebra. The system which satisfy the condition $\mathbf{Cat1Alg1}$ is called a \emph{precat$^{1}$-algebra}. The homomorphisms $t,h$ and $e$ are called the \emph{tail}, \emph{head} and \emph{embedding} homomorphisms, respectively. 

\subsection{\textcolor{Chapter }{Cat1}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7F4221DF83D1B6D8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1({\mdseries\slshape args})\index{Cat1@\texttt{Cat1}}
\label{Cat1}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1ByTailHeadEmbedding({\mdseries\slshape t, h, e})\index{PreCat1ByTailHeadEmbedding@\texttt{PreCat1ByTailHeadEmbedding}}
\label{PreCat1ByTailHeadEmbedding}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1ByEndomorphisms({\mdseries\slshape t, h})\index{PreCat1ByEndomorphisms@\texttt{PreCat1ByEndomorphisms}}
\label{PreCat1ByEndomorphisms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1AlgebraObj({\mdseries\slshape C})\index{PreCat1AlgebraObj@\texttt{PreCat1AlgebraObj}}
\label{PreCat1AlgebraObj}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1Algebra({\mdseries\slshape C})\index{PreCat1Algebra@\texttt{PreCat1Algebra}}
\label{PreCat1Algebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsIdentityCat1Algebra({\mdseries\slshape C})\index{IsIdentityCat1Algebra@\texttt{IsIdentityCat1Algebra}}
\label{IsIdentityCat1Algebra}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCat1Algebra({\mdseries\slshape C})\index{IsCat1Algebra@\texttt{IsCat1Algebra}}
\label{IsCat1Algebra}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreCat1Algebra({\mdseries\slshape C})\index{IsPreCat1Algebra@\texttt{IsPreCat1Algebra}}
\label{IsPreCat1Algebra}
}\hfill{\scriptsize (property)}}\\


 The operations listed above are used for construction of precat$^{1}$ and cat$^{1}$-algebra structures. The function \texttt{Cat1Algebra} selects the operation from the above implementations up to user's input. The
operation \texttt{PreCat1AlgebraObj} is used for preserving the implementations, }

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape C})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape C})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Tail({\mdseries\slshape C})\index{Tail@\texttt{Tail}}
\label{Tail}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Head({\mdseries\slshape C})\index{Head@\texttt{Head}}
\label{Head}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Embedding({\mdseries\slshape C})\index{Embedding@\texttt{Embedding}}
\label{Embedding}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Kernel({\mdseries\slshape C})\index{Kernel@\texttt{Kernel}}
\label{Kernel}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Boundary({\mdseries\slshape C})\index{Boundary@\texttt{Boundary}}
\label{Boundary}
}\hfill{\scriptsize (attribute)}}\\


 These are the seven main attributes of a pre-cat$^{1}$-algebra. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@A := GroupRing(GF(2),Group((1,2,3)(4,5)));|
  <algebra-with-one over GF(2), with 1 generators>
  !gapprompt@gap>| !gapinput@R := GroupRing(GF(2),Group((1,2,3)));|
  <algebra-with-one over GF(2), with 1 generators>
  !gapprompt@gap>| !gapinput@f := AllHomsOfAlgebras(A,R);|
  [ [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ <zero> of ... ], 
    [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ (Z(2)^0)*() ],
    [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3) ],
    [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2) ],
    [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ (Z(2)^0)*()+(Z(2)^0)*(1,3,2) ], 
    [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ (Z(2)^0)*(1,2,3) ],
    [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2) ], 
    [ (Z(2)^0)*(1,3,2)(4,5) ] -> [ (Z(2)^0)*(1,3,2)
       ] ]
  !gapprompt@gap>| !gapinput@g := AllHomsOfAlgebras(R,A);|
  [ [ (Z(2)^0)*(1,2,3) ] -> [ <zero> of ... ], 
    [ (Z(2)^0)*(1,2,3) ] -> [ (Z(2)^0)*() ],
    [ (Z(2)^0)*(1,2,3) ] -> [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3) ],
    [ (Z(2)^0)*(1,2,3) ] -> [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2) ],
    [ (Z(2)^0)*(1,2,3) ] -> [ (Z(2)^0)*()+(Z(2)^0)*(1,3,2) ], 
    [ (Z(2)^0)*(1,2,3) ] -> [ (Z(2)^0)*(1,2,3) ],
    [ (Z(2)^0)*(1,2,3) ] -> [ (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2) ], 
    [ (Z(2)^0)*(1,2,3) ] -> [ (Z(2)^0)*(1,3,2) ] ]
  !gapprompt@gap>| !gapinput@C4 := PreCat1ByTailHeadEmbedding(f[6],f[6],g[8]);|
  [AlgebraWithOne( GF(2), [ (Z(2)^0)*(1,2,3)(4,5) ] ) -> AlgebraWithOne( GF(2), 
    [ (Z(2)^0)*(1,2,3) ] )]
  !gapprompt@gap>| !gapinput@IsCat1Algebra(C4);|
  true
  !gapprompt@gap>| !gapinput@Size(C4);|
  [ 64, 8 ]
  !gapprompt@gap>| !gapinput@Display(C4);|
  
  Cat1-algebra [..=>..] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3)(4,5) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3) ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,3,2) ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,3,2) ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,3,2) ]
  : kernel has generators:
    [ (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,2,3)(4,5), 
    (Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3,2)(4,5) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ..., <zero> of ..., <zero> of ... ]
  : kernel embedding maps generators of kernel to:
    [ (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,2,3)(4,5), 
    (Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3,2)(4,5) ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Cat1AlgebraSelect}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X82EC94BA7E7F8DEA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgebraSelect({\mdseries\slshape gf, gpsize, gpnum, num})\index{Cat1AlgebraSelect@\texttt{Cat1AlgebraSelect}}
\label{Cat1AlgebraSelect}
}\hfill{\scriptsize (operation)}}\\


 The Cat1Algebra function may also be used to select a cat$^{1}$-algebra from a data file. All cat$^{1}$-structures on commutative algebras are stored in a list in file
cat1algdata.g. The data is read into the list CAT1ALG{\textunderscore}LIST
only when this function is called. The function Cat1AlgebraSelect may be used
in four ways: 
\begin{itemize}
\item  Cat1AlgebraSelect( gf ) returns the list of possible size of Galois field or
the list of possible size of groups with given Galois field. 
\item  Cat1AlgebraSelect( gf, gpsize ) returns the list of possible size of group
with given Galois fields or the list of possible number of groups with given
Galois field and size of group. 
\item  Cat1AlgebraSelect( gf, gpsize, gpnum ) returns the list of possible number of
group with given Galois field and size of group or the list of possible cat$^{1}$-structures with given Galois field and group. 
\item  Cat1AlgebraSelect( gf, gpsize, gpnum, num ) (or just Cat1Algebra( gf, gpsize,
gpnum, num )) returns the chosen cat$^{1}$-algebra. 
\end{itemize}
 Now, we will give an example for the usage of this function. }

 
\begin{Verbatim}[commandchars=!@B,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>B !gapinput@C := Cat1AlgebraSelect(11);B
  |--------------------------------------------------------|
  | 11 is invalid number for Galois Field (gf)             |
  | Possible numbers for the gf in the Data :              |
  |--------------------------------------------------------|
   [ 2, 3, 4, 5, 7 ]
  Usage: Cat1Algebra( gf, gpsize, gpnum, num );
  fail
  !gapprompt@gap>B !gapinput@C := Cat1AlgebraSelect(4,12);B
  |--------------------------------------------------------|
  | 12 is invalid number for size of group (gpsize)        |
  | Possible numbers for the gpsize for GF(4) in the Data: |
  |--------------------------------------------------------|
   [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
  Usage: Cat1Algebra( gf, gpsize, gpnum, num );
  fail
  !gapprompt@gap>B !gapinput@C := Cat1AlgebraSelect(2,6,3);B
  |--------------------------------------------------------|
  | 3 is invalid number for group of order 6               |
  | Possible numbers for the gpnum in the Data :           |
  |--------------------------------------------------------|
   [ 1, 2 ]
  Usage: Cat1Algebra( gf, gpsize, gpnum, num );
  fail
  !gapprompt@gap>B !gapinput@C := Cat1AlgebraSelect(2,6,2);B
  There are 4 cat1-structures for the algebra GF(2)_c6.
   Range Alg      Tail                    Head
  |--------------------------------------------------------|
  | GF(2)_c6      identity map            identity map     |
  | -----         [ 2, 10 ]               [ 2, 10 ]        |
  | -----         [ 2, 14 ]               [ 2, 14 ]        |
  | -----         [ 2, 50 ]               [ 2, 50 ]        |
  |--------------------------------------------------------|
  Usage: Cat1Algebra( gf, gpsize, gpnum, num );
  Algebra has generators [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3)(4,5) ]
  4
  !gapprompt@gap>B !gapinput@C2 := Cat1AlgebraSelect( 4, 6, 2, 2 );B
  [GF(2^2)_c6 -> Algebra( GF(2^2),
  [ (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)(2,5)(3,6)+(
      Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*(1,6,5,4,3,2) ] )]
  !gapprompt@gap>B !gapinput@Size( C2 ); B
  [ 4096, 1024 ]
  !gapprompt@gap>B !gapinput@Display( C2 ); B
  
  Cat1-algebra [GF(2^2)_c6=>..] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3,4,5,6) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)(2,5)
      (3,6)+(Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*(1,6,5,4,3,2) ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)(2,5)
      (3,6)+(Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*(1,6,5,4,3,2) ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)(2,5)
      (3,6)+(Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*(1,6,5,4,3,2) ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)(2,5)
      (3,6)+(Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*(1,6,5,4,3,2) ]
  : kernel has generators:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3,4,5,6)+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)
      (2,5)(3,6)+(Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*(1,6,5,4,3,2) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ... ]
  : kernel embedding maps generators of kernel to:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3,4,5,6)+(Z(2)^0)*(1,3,5)(2,4,6)+(Z(2)^0)*(1,4)
      (2,5)(3,6)+(Z(2)^0)*(1,5,3)(2,6,4)+(Z(2)^0)*(1,6,5,4,3,2) ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{SubCat1Algebra}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X86E99B197E920C21}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubCat1Algebra({\mdseries\slshape arg})\index{SubCat1Algebra@\texttt{SubCat1Algebra}}
\label{SubCat1Algebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubPreCat1Algebra({\mdseries\slshape arg})\index{SubPreCat1Algebra@\texttt{SubPreCat1Algebra}}
\label{SubPreCat1Algebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubCat1Algebra({\mdseries\slshape arg})\index{IsSubCat1Algebra@\texttt{IsSubCat1Algebra}}
\label{IsSubCat1Algebra}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubPreCat1Algebra({\mdseries\slshape arg})\index{IsSubPreCat1Algebra@\texttt{IsSubPreCat1Algebra}}
\label{IsSubPreCat1Algebra}
}\hfill{\scriptsize (property)}}\\


 Let $\mathcal{C} = (e;t,h:A\rightarrow R)$ be a cat$^{1}$-algebra, and let $A^{\prime}$, $R^{\prime}$ be subalgebras of $A$ and $R$ respectively. If the restriction morphisms 
\[ t^{\prime} = t|_{A^{\prime}} : A^{\prime}\rightarrow R^{\prime}, \qquad
h^{\prime} = h|_{A^{\prime}} : A^{\prime}\rightarrow R^{\prime}, \qquad
e^{\prime} = e|_{R^{\prime}} : R^{\prime}\rightarrow A^{\prime} \]
 satisfy the $\mathbf{Cat1Alg1}$ and $\mathbf{Cat1Alg2}$ conditions, then the system $\mathcal{C}^{\prime } = (e^{\prime};t^{\prime},h^{\prime} : A^{\prime}
\rightarrow R^{\prime})$ is called a \emph{subcat$^{1}$-algebra} of $\mathcal{C} = (e;t,h:A\rightarrow R)$. 

 If the morphisms satisfy only the $\mathbf{Cat1Alg1}$ condition then $\mathcal{C}^{\prime }$ is called a \emph{sub-precat$^{1}$-algebra} of $\mathcal{C}$. 

 The operations in this subsection are used for constructing subcat$^{1}$-algebras of a given cat$^{1}$-algebra. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@C3 := Cat1AlgebraSelect( 2, 6, 2, 4 );; |
  !gapprompt@gap>| !gapinput@A3 := Source( C3 );|
  GF(2)_c6
  !gapprompt@gap>| !gapinput@B3 := Range( C3 ); |
  GF(2)_c3
  !gapprompt@gap>| !gapinput@eA3 := Elements( A3 );;|
  !gapprompt@gap>| !gapinput@eB3 := Elements( B3 );;|
  !gapprompt@gap>| !gapinput@AA3 := Subalgebra( A3, [ eA3[1], eA3[2], eA3[3] ] );|
  <algebra over GF(2), with 3 generators>
  !gapprompt@gap>| !gapinput@[ Size(A3), Size(AA3) ]; |
  [ 64, 4 ]
  !gapprompt@gap>| !gapinput@BB3 := Subalgebra( B3, [ eB3[1], eB3[2] ] ); |
  <algebra over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@[ Size(B3), Size(BB3) ]; |
  [ 8, 2 ]
  !gapprompt@gap>| !gapinput@CC3 := SubCat1Algebra( C3, AA3, BB3 );|
  [Algebra( GF(2), [ <zero> of ..., (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(4,5) 
   ] ) -> Algebra( GF(2), [ <zero> of ..., (Z(2)^0)*() ] )]
  !gapprompt@gap>| !gapinput@Display( CC3 );|
  
  Cat1-algebra [..=>..] :-
  : source algebra has generators:
    [ <zero> of ..., (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(4,5) ]
  :  range algebra has generators:
    [ <zero> of ..., (Z(2)^0)*() ]
  : tail homomorphism maps source generators to:
    [ <zero> of ..., (Z(2)^0)*(), <zero> of ... ]
  : head homomorphism maps source generators to:
    [ <zero> of ..., (Z(2)^0)*(), <zero> of ... ]
  : range embedding maps range generators to:
    [ <zero> of ..., (Z(2)^0)*() ]
  : kernel has generators:
    [ <zero> of ..., (Z(2)^0)*()+(Z(2)^0)*(4,5) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ..., <zero> of ... ]
  : kernel embedding maps generators of kernel to:
    [ <zero> of ..., (Z(2)^0)*()+(Z(2)^0)*(4,5) ]
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Cat$^{1}-$algebra morphisms}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X8159613D81C201EA}{}
{
  Let $\mathcal{C} = (e;t,h:A\rightarrow R)$, $\mathcal{C}^{\prime } = (e^{\prime}; t^{\prime }, h^{\prime } : A^{\prime}
\rightarrow R^{\prime})$ be cat$^{1}$-algebras, and let $\phi : A\rightarrow A^{\prime}$ and $\varphi : R \rightarrow R^{\prime}$ be algebra homomorphisms. If the diagram 
\[ \xymatrix@R=50pt@C=50pt{ A \ar@{->}@<-1.5pt>[d]_{t} \ar@{->}@<1.5pt>[d]^{h}
\ar@{->}[r]^{\phi} & A' \ar@{->}@<-1.5pt>[d]_{t'} \ar@{->}@<1.5pt>[d]^{h'} \\
R \ar@/^1.5pc/[u]^{e} \ar@{->}[r]_{\varphi} & R' \ar@/_1.5pc/[u]_{e'} } \]
 commutes, (i.e $t^{\prime} \circ \phi = \varphi \circ t$, $h^{\prime} \circ \phi = \varphi \circ h$ and $e^{\prime } \circ \varphi = \phi \circ e$), then the pair $(\phi ,\varphi )$is called a cat$^{1}$-algebra morphism. 

\subsection{\textcolor{Chapter }{Cat1AlgebraMorphism}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X860E29147DA143B5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgebraMorphism({\mdseries\slshape arg})\index{Cat1AlgebraMorphism@\texttt{Cat1AlgebraMorphism}}
\label{Cat1AlgebraMorphism}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IdentityMapping({\mdseries\slshape C})\index{IdentityMapping@\texttt{IdentityMapping}}
\label{IdentityMapping}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1AlgebraMorphismByHoms({\mdseries\slshape f, g})\index{PreCat1AlgebraMorphismByHoms@\texttt{PreCat1AlgebraMorphismByHoms}}
\label{PreCat1AlgebraMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgebraMorphismByHoms({\mdseries\slshape f, g})\index{Cat1AlgebraMorphismByHoms@\texttt{Cat1AlgebraMorphismByHoms}}
\label{Cat1AlgebraMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreCat1AlgebraMorphism({\mdseries\slshape C})\index{IsPreCat1AlgebraMorphism@\texttt{IsPreCat1AlgebraMorphism}}
\label{IsPreCat1AlgebraMorphism}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCat1AlgebraMorphism({\mdseries\slshape arg})\index{IsCat1AlgebraMorphism@\texttt{IsCat1AlgebraMorphism}}
\label{IsCat1AlgebraMorphism}
}\hfill{\scriptsize (property)}}\\


 These operations are used for constructing cat$^{1}$-algebra morphisms. Details of the implementations can be found in \cite{aodabas1}. }

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape m})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape m})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsTotal({\mdseries\slshape m})\index{IsTotal@\texttt{IsTotal}}
\label{IsTotal}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSingleValued({\mdseries\slshape m})\index{IsSingleValued@\texttt{IsSingleValued}}
\label{IsSingleValued}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Name({\mdseries\slshape m})\index{Name@\texttt{Name}}
\label{Name}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Boundary({\mdseries\slshape m})\index{Boundary@\texttt{Boundary}}
\label{Boundary}
}\hfill{\scriptsize (attribute)}}\\


 These are the six main attributes of a cat$^{1}$-algebra morphism. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@C1:=Cat1Algebra(2,1,1,1);|
  [GF(2)_triv -> GF(2)_triv]
  !gapprompt@gap>| !gapinput@Display(C1);|
  
  Cat1-algebra [GF(2)_triv=>GF(2)_triv] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : the kernel is trivial.
  
  !gapprompt@gap>| !gapinput@C2:=Cat1Algebra(2,2,1,2);|
  [GF(2)_c2 -> GF(2)_triv]
  !gapprompt@gap>| !gapinput@Display(C2);|
  
  Cat1-algebra [GF(2)_c2=>GF(2)_triv] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : kernel has generators:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ... ]
  : kernel embedding maps generators of kernel to:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2) ]
  
  !gapprompt@gap>| !gapinput@C1=C2;|
  false
  !gapprompt@gap>| !gapinput@R1:=Source(C1);;|
  !gapprompt@gap>| !gapinput@R2:=Source(C2);;|
  !gapprompt@gap>| !gapinput@S1:=Range(C1);;|
  !gapprompt@gap>| !gapinput@S2:=Range(C2);;|
  !gapprompt@gap>| !gapinput@gR1:=GeneratorsOfAlgebra(R1);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@gR2:=GeneratorsOfAlgebra(R2);|
  [ (Z(2)^0)*(), (Z(2)^0)*(1,2) ]
  !gapprompt@gap>| !gapinput@gS1:=GeneratorsOfAlgebra(S1);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@gS2:=GeneratorsOfAlgebra(S2);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@im1:=[gR2[1],gR2[1]];|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@f1:=AlgebraHomomorphismByImages(R1,R2,gR1,im1);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ] -> [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@im2:=[gS2[1],gS2[1]];|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@f2:=AlgebraHomomorphismByImages(S1,S2,gS1,im2);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ] -> [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@m:=Cat1AlgebraMorphism(C1,C2,f1,f2);|
  [[GF(2)_triv=>GF(2)_triv] => [GF(2)_c2=>GF(2)_triv]]
  !gapprompt@gap>| !gapinput@Display(m);|
  Morphism of cat1-algebras :-
  : Source = [GF(2)_triv=>GF(2)_triv] with generating sets:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  :  Range = [GF(2)_c2=>GF(2)_triv] with generating sets:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2) ]
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : Source Homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : Range Homomorphism maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@Image2dAlgMapping(m);|
  [GF(3)_c2^3=>GF(3)_c2^3]
  !gapprompt@gap>| !gapinput@IsSurjective(m);|
  false
  !gapprompt@gap>| !gapinput@IsInjective(m);|
  true
  !gapprompt@gap>| !gapinput@IsBijective(m);|
  false
  
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Equivalent Categories}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X8617844F86989A78}{}
{
  The categories $\mathbf{Cat1Alg}$ (cat$^{1}$-algebras) and $\mathbf{XModAlg}$ (crossed modules) are naturally equivalent \cite{ellis1}. This equivalence is outlined in what follows. For a given crossed module $(\partial : A \rightarrow R)$ we can construct the semidirect product $R\ltimes A$ thanks to the action of $R$ on $A$. If we define $t,h : R\ltimes A \rightarrow R$ and $e : R \rightarrow R \ltimes A$ by 
\[ t(r,a) = r, \qquad h(r,a) = r+\partial(a), \qquad e(r) = (r,0), \]
 respectively, then $\mathcal{C} = (e;t,h : R \ltimes A \rightarrow R)$ is a cat$^{1}-$algebra. 

 Conversely, for a given cat$^{1}$-algebra $\mathcal{C}=(e;t,h : A \rightarrow R)$, the map $\partial : \ker t \rightarrow R$ is a crossed module, where the action is multiplication action and $\partial$ is the restriction of $h$ to $\ker t$. 

\subsection{\textcolor{Chapter }{PreCat1ByPreXMod}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X7AA150628786FF01}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1ByPreXMod({\mdseries\slshape X0})\index{PreCat1ByPreXMod@\texttt{PreCat1ByPreXMod}}
\label{PreCat1ByPreXMod}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreXModAlgebraByPreCat1Algebra({\mdseries\slshape C})\index{PreXModAlgebraByPreCat1Algebra@\texttt{PreXModAlgebraByPreCat1Algebra}}
\label{PreXModAlgebraByPreCat1Algebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgebraByXModAlgebra({\mdseries\slshape X0})\index{Cat1AlgebraByXModAlgebra@\texttt{Cat1AlgebraByXModAlgebra}}
\label{Cat1AlgebraByXModAlgebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgebraByCat1Algebra({\mdseries\slshape C})\index{XModAlgebraByCat1Algebra@\texttt{XModAlgebraByCat1Algebra}}
\label{XModAlgebraByCat1Algebra}
}\hfill{\scriptsize (operation)}}\\


 These operations are used for constructing a cat$^{1}$-algebra from a given crossed module, and conversely. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@CXM := Cat1AlgebraByXModAlgebra( XM );|
  [GF(2^2)[k4] IX <e5> -> GF(2^2)[k4]]
  !gapprompt@gap>| !gapinput@X3 := XModAlgebraByCat1Algebra( C3 ); |
  [Algebra( GF(2), [ <zero> of ..., <zero> of ..., <zero> of ... 
   ] )->Algebra( GF(2), 
  [ (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,2,3)(4,5), 
    (Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3,2)(4,5) ] )]
  !gapprompt@gap>| !gapinput@Display( X3 ); |
  
  Crossed module [..->..] :- 
  : Source algebra has generators:
    [ <zero> of ..., <zero> of ..., <zero> of ... ]
  : Range algebra has generators:
    [ (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,2,3)(4,5), 
    (Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3,2)(4,5) ]
  : Boundary homomorphism maps source generators to:
    [ <zero> of ..., <zero> of ..., <zero> of ... ]
  
\end{Verbatim}
 Since all these operations are linked to the functions \texttt{Cat1Algebra} and \texttt{XModAlgebra}, all of them can be done by using these two functions. We may also use the
function \texttt{Cat1Algebra} instead of the operation \texttt{Cat1AlgebraSelect}. }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
