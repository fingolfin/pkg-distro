% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{latexsym,xypic}	

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{XModAlg}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{XModAlg}}
\markright{\scriptsize \mbox{}\hfill \textsf{XModAlg} \hfill\mbox{}}
{\Huge \textbf{Crossed modules and cat1-groups of commutative algebras\mbox{}}}\\
\vfill

{\Huge Version 1.05\mbox{}}\\[1cm]
{07/02/2015\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Zekeriya Arvasi    \mbox{}}}\\
{\Large \textbf{ Alper Odaba{\c s}    \mbox{}}}\\
\hypersetup{pdfauthor= Zekeriya Arvasi    ;  Alper Odaba{\c s}    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Zekeriya Arvasi    }  Email: \href{mailto://zarvasi@ogu.edu.tr} {\texttt{zarvasi@ogu.edu.tr}}\\
  Homepage: \href{http://fef.ogu.edu.tr/zarvasi/} {\texttt{http://fef.ogu.edu.tr/zarvasi/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Osmangazi Univertsity,\\
 Fen Edebiyat Fak{\"u}ltesi, Meselik Kampusu\\
 Eskisehir, Turkey. \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Alper Odaba{\c s}    }  Email: \href{mailto://aodabas@ogu.edu.tr} {\texttt{aodabas@ogu.edu.tr}}\\
  Homepage: \href{http://fef.ogu.edu.tr/matbil/aodabas/} {\texttt{http://fef.ogu.edu.tr/matbil/aodabas/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Osmangazi Univertsity,\\
 Fen Edebiyat Fak{\"u}ltesi, Meselik Kampusu\\
 Eskisehir, Turkey. \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 The \textsf{XModAlg} package provides functions for computation with crossed modulres of
associative algebras and cat$^{1}$-algebras). The current version is 1.05, released 7th February 2015 for \textsf{GAP} 4.7. 

 Bug reports, suggestions and comments are, of course, welcome. Please contact
the second author at \href{mailto://aodabas@ogu.edu.tr} {\texttt{aodabas@ogu.edu.tr}}. \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 \index{License} {\copyright} 2007-2015 Zekeriya Arvasi and Alper Odabas. \textsf{XModAlg} is free software; you can redistribute it and/or modify it under the terms of
the \href{http://www.fsf.org/licenses/gpl.html} {GNU General Public License} as published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 This documentation was prepared with the \textsf{GAPDoc} package of Frank L{\"u}beck and Max Neunh{\"o}ffer. 

 This work was partially supported by T{\"U}B{\.I}TAK (The Scientific and
Technical Research Council of Turkey), project number 107T542. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

             
\chapter{\textcolor{Chapter }{Introduction}}\label{Intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  In 1950 S. MacLane and J.H.C. Whitehead, \cite{whitehead} suggested that crossed modules modeled homotopy $2$-types. Later crossed modules had been considered as $2$\emph{-dimensional groups}, \cite{brown1}, \cite{brown2}. The commutative algebra version of this construction has been adapted by T.
Porter, \cite{arvasi2}, \cite{porter1}. This algebraic version is called \emph{combinatorial algebra theory}, which contains potentially important new ideas (see \cite{arvasi2}, \cite{arvasi3}, \cite{arvasi4}.) 

 A share package \textsf{XMod}, \cite{alp3}, \cite{alp2}, was prepared by M. Alp and C.D. Wensley for the \textsf{GAP} computational group theory language, initially for \textsf{GAP}3 then revised for \textsf{GAP}4. The $2$-dimensional part of this programme contains functions for computing crossed
modules and cat$^{1}$-groups and their morphisms \cite{alp3}. 

 In this paper we describe the \textsf{GAP} \textsf{XModAlg}, including functions for computing crossed module of algebras, cat$^{1}$-algebras and their morphisms by analogy with \emph{computational group theory}. The tools needed are the group algebras in which the group algebra functor $\mathcal{K}(.):Gr\rightarrow Alg$ is left adjoint to the unit group functor $\mathcal{U}(.):Alg\rightarrow Gr$. 

 One of the main result is the \textsf{GAP} implementation of the equivalent categories \texttt{XModAlg} (crossed modules of algebras) and \texttt{Cat1Alg} (cat$^{1}$-algebras) has been shown in this work. Algorithms of the \textsf{GAP} implementations in this paper are deeply analyzed in A. Odabas's Ph.D. thesis, \cite{aodabas1}. 

 Unfortunately \textsf{GAP} is not quiet suitable for commutative algebras since no standard \textsf{GAP} function yet exists for computing semidirect products, endomorphisms and
multiplier algebras. But we only manage the multiplier algebras.(?) }

            
\chapter{\textcolor{Chapter }{Crossed modules}}\label{chap-xmod}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X808C6B357F8BADC1}{}
{
  In this chapter we will present the notion of crossed modules of commutative
algebras and their implementation in this package. 
\section{\textcolor{Chapter }{Definition and Examples}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7BB9D67179296AA0}{}
{
  \index{crossed module} \index{2d-algebra} Let \textsc{k} be a fixed commutative ring with $1 \neq 0$. From now on, all \textsc{k}-algebras will be associative and commutative. 

 A \emph{crossed module} is a \textsc{k}-algebra morphism $\mathcal{X}:=(\partial:S\rightarrow R)$ with an action of $R$ on $S$ satisfying 
\[ {\bf XModAlg\ 1} ~:~ \partial(r \cdot s) = r(\partial s), \qquad {\bf XModAlg\
2} ~:~ (\partial s) \cdot s^{\prime} = ss^{\prime}, \]
 for all $s,s^{\prime }\in S$,\texttt{\symbol{92}} $r\in R$. TYhe morphism $\partial$ is called the \emph{boundary map} of $\mathcal{X}$ 

 We can produce crossed modules by using the following methods. 

\subsection{\textcolor{Chapter }{XModAlg}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X83CA187B847D617E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlg({\mdseries\slshape args})\index{XModAlg@\texttt{XModAlg}}
\label{XModAlg}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgByBoundaryAndAction({\mdseries\slshape bdy, act})\index{XModAlgByBoundaryAndAction@\texttt{XModAlgByBoundaryAndAction}}
\label{XModAlgByBoundaryAndAction}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgByIdeal({\mdseries\slshape A, I})\index{XModAlgByIdeal@\texttt{XModAlgByIdeal}}
\label{XModAlgByIdeal}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgByModule({\mdseries\slshape M, R})\index{XModAlgByModule@\texttt{XModAlgByModule}}
\label{XModAlgByModule}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgByCentralExtension({\mdseries\slshape f})\index{XModAlgByCentralExtension@\texttt{XModAlgByCentralExtension}}
\label{XModAlgByCentralExtension}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgByMultipleAlgebra({\mdseries\slshape A})\index{XModAlgByMultipleAlgebra@\texttt{XModAlgByMultipleAlgebra}}
\label{XModAlgByMultipleAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Here are the standard constructions which these operations implement: 
\begin{itemize}
\item  Let $A$ be an algebra and $I$ an ideal of $A$. Then $\mathcal{X} = (inc:I\rightarrow A)$ is a crossed module with the multiplication action of $A$on $I$. Conversely, we induce an ideal from a given crossed module. Indeed, for a
given crossed module $\mathcal{X} = (\partial : S \rightarrow R)$, ${\partial(S)}$ is an ideal of $R$. 
\item  Let $M$ be a $R$-module. Then $\mathcal{X} = (0:M\rightarrow R)$ is a crossed module. Conversely, given a crossed module $\mathcal{X} = (\partial :M\rightarrow R)$, one can get that $\ker\partial$ is a $(R/\partial M)$-module. 
\item  Let $\partial : S\rightarrow R$ be a surjective algebra homomorphism. Define the action of $R$on $S$ by $r\cdot s = \widetilde{r}s$ where $\widetilde{r} \in \partial^{-1}(r)$. Then $\mathcal{X}=(\partial : S\rightarrow R)$ is a crossed module with the defined action. 
\item  Let $S$ be a \textsc{k}-algebra such that $Ann(S)=0$or $S^{2} = S$ then $\partial : S\rightarrow M(S)$is a crossed module, where $M(S)$ is the algebra of multipliers of $S$ and $\partial $is the canonical homomorphism, \cite{arvasi4}. 
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape X0})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape X0})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Boundary({\mdseries\slshape X0})\index{Boundary@\texttt{Boundary}}
\label{Boundary}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgAction({\mdseries\slshape X0})\index{XModAlgAction@\texttt{XModAlgAction}}
\label{XModAlgAction}
}\hfill{\scriptsize (attribute)}}\\


 These four attributes are used in the construction of a crossed module $\mathcal{X}$ where: 
\begin{itemize}
\item  \texttt{Source(X)} and \texttt{Range(X)} are the \emph{source} and the \emph{range} of the boundary map respectively; 
\item  \texttt{Boundary(X)} is the boundary map of the crossed module $\mathcal{X}$; 
\item  \texttt{XModAlgAction(X)} is the action used in the crossed module. 
\end{itemize}
 The following standard \textsf{GAP} operations have special \textsf{XModAlg} implementations: 
\begin{itemize}
\item  \texttt{Display(X)} is used to list the components of $\mathcal{X}$; 
\item  \texttt{Size(X)} is used for calculating the order of the crossed module $\mathcal{X}$; 
\item  \texttt{Name(X)} is used for giving a name to the crossed module $\mathcal{X}$ by associating the names of source and range algebras. 
\end{itemize}
 In the following example, we construct a crossed module by using the algebra $GF_{5}D_{4}$ and its augmentation ideal. We also show usage of the attributes listed above. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@A:=GroupRing( GF(5), DihedralGroup(4) );|
  <algebra-with-one over GF(5), with 2 generators>
  !gapprompt@gap>| !gapinput@Size(A);
|
  625
  !gapprompt@gap>| !gapinput@eA:=Elements(A);;
|
  !gapprompt@gap>| !gapinput@SetName(A,"GF5[D(4)]");
|
  !gapprompt@gap>| !gapinput@I:=AugmentationIdeal(A);
|
  <two-sided ideal in GF5[D(4)], (2 generators)>
  !gapprompt@gap>| !gapinput@Size(I);
|
  125
  !gapprompt@gap>| !gapinput@SetName(I,"Aug");
|
  !gapprompt@gap>| !gapinput@CM:=XModAlgByIdeal(A,I);
|
  [Aug->GF5[D(4)]]
  !gapprompt@gap>| !gapinput@Display(CM);
|
  
  Crossed module [Aug->GF5[D(4)]] :-
  : Source group Aug has generators:
    [ (Z(5)^2)*<identity> of ...+(Z(5)^0)*f1, (Z(5)^2)*<identity> of
    ...+(Z(5)^0)*f2 ]
  : Range group GF5[D(4)] has generators:
    [ (Z(5)^0)*<identity> of ..., (Z(5)^0)*f1, (Z(5)^0)*f2 ]
  : Boundary homomorphism maps source generators to:
    [ (Z(5)^2)*<identity> of ...+(Z(5)^0)*f1, (Z(5)^2)*<identity> of
    ...+(Z(5)^0)*f2 ]
  
  !gapprompt@gap>| !gapinput@Size(CM);
|
  [ 125, 625 ]
  !gapprompt@gap>| !gapinput@Print(RepresentationsOfObject(CM),"\n");|
  [ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPreXModAlgObj" ]
  !gapprompt@gap>| !gapinput@Print(KnownPropertiesOfObject(CM),"\n");|
  [ "Is2dAlgObject", "IsPreXModAlg", "DisplayXModAlg", "IsXModAlg" ]
  !gapprompt@gap>| !gapinput@Print(KnownAttributesOfObject(CM),"\n");|
  [ "Name", "Size", "Range", "Source", "Boundary", "AlperGroup", 
    "XModAlgAction" ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{SubXModAlg}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X7B7D441781958BCE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubXModAlg({\mdseries\slshape X0})\index{SubXModAlg@\texttt{SubXModAlg}}
\label{SubXModAlg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubXModAlg({\mdseries\slshape X0})\index{IsSubXModAlg@\texttt{IsSubXModAlg}}
\label{IsSubXModAlg}
}\hfill{\scriptsize (attribute)}}\\


 A crossed module $\mathcal{X}^{\prime } = (\partial ^{\prime }:S^{\prime}\rightarrow R^{\prime
})$ is a crossed submodule of the crossed module $\mathcal{X} = (\partial :S\rightarrow R)$ if $S^{\prime }\leq S$, $R^{\prime}\leq R$, $\partial^{\prime } = \partial|_{S^{\prime }}$, and the action of $S^{\prime }$ on $R^{\prime }$ is induced by the action of $R$ on $S$. The operation \texttt{SubXModAlg} is used to construct a crossed submodule of a given crossed module. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@eI:=Elements(I);
|
  !gapprompt@gap>| !gapinput@J:=Ideal(I,[eI[4]]);
|
  <two-sided ideal in Aug, (1 generators)>
  !gapprompt@gap>| !gapinput@J=I;
|
  false
  !gapprompt@gap>| !gapinput@Size(J);
|
  5
  !gapprompt@gap>| !gapinput@IsIdeal(I,J);
|
  true
  !gapprompt@gap>| !gapinput@IsIdeal(A,J);
|
  true
  !gapprompt@gap>| !gapinput@PM:=XModAlg(A,J);
|
  [Algebra( GF(5),
  [ (Z(5)^0)*<identity> of ...+(Z(5)^0)*f1+(Z(5)^2)*f2+(Z(5)^2)*f1*f2
   ] )->GF5[D(4)]]
  !gapprompt@gap>| !gapinput@Display(PM);
|
  
  Crossed module [..->GF5[D(4)]] :-
  : Source group has generators:
    [ (Z(5)^0)*<identity> of ...+(Z(5)^0)*f1+(Z(5)^2)*f2+
    (Z(5)^2)*f1*f2 ]
  : Range group GF5[D(4)] has generators:
    [ (Z(5)^0)*<identity> of ..., (Z(5)^0)*f1,
    (Z(5)^0)*f2 ]
  : Boundary homomorphism maps source generators to:
    [ (Z(5)^0)*<identity> of ...+(Z(5)^0)*f1+(Z(5)^2)*f2+
    (Z(5)^2)*f1*f2 ]
  
  !gapprompt@gap>| !gapinput@IsSubXModAlg(CM,PM);
|
  true
  
\end{Verbatim}
 \index{precrossed module} 

\subsection{\textcolor{Chapter }{PreXmodAlgByBoundaryAndAction(bdy,act)}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X841F4B0B7B84B5AE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreXmodAlgByBoundaryAndAction(bdy,act)({\mdseries\slshape bdy, act})\index{PreXmodAlgByBoundaryAndAction(bdy,act)@\texttt{Pre}\-\texttt{Xmod}\-\texttt{Alg}\-\texttt{By}\-\texttt{Boundary}\-\texttt{And}\-\texttt{Action(bdy,act)}}
\label{PreXmodAlgByBoundaryAndAction(bdy,act)}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreXModAlg({\mdseries\slshape X0})\index{IsPreXModAlg@\texttt{IsPreXModAlg}}
\label{IsPreXModAlg}
}\hfill{\scriptsize (attribute)}}\\


 An $R$-algebra homomorphism $\mathcal{X} := (\partial : S \rightarrow R)$ which satisfy the condition \textsc{XModAlg1} is called a \emph{precrossed module}. The details of these implementations can be found in \cite{aodabas1}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G:=SmallGroup(4,2);
|
  <pc group of size 4 with 2 generators>
  !gapprompt@gap>| !gapinput@F:=GaloisField(4);
|
  GF(2^2)
  !gapprompt@gap>| !gapinput@A:=GroupRing(F,G);
|
  <algebra-with-one over GF(2^2), with 2 generators>
  !gapprompt@gap>| !gapinput@Size(A);
|
  256
  !gapprompt@gap>| !gapinput@eA:=Elements(A);;
|
  !gapprompt@gap>| !gapinput@B:=Subalgebra(A,[eA[5]]);
|
  <algebra over GF(2^2), with 1 generators>
  !gapprompt@gap>| !gapinput@AB:=Cartesian(A,B);;
|
  !gapprompt@gap>| !gapinput@act:=AlgebraAction(A,AB,B);;
|
  !gapprompt@gap>| !gapinput@bdy:=AlgebraHomomorphismByFunction(B,A,i->i);
|
  MappingByFunction( <algebra of dimension 1 over GF(2^2)>, 
  <algebra-with-one of dimension 4 over GF(2^2)>,
  function( i ) ... end )
  !gapprompt@gap>| !gapinput@IsAlgebraAction(act);
|
  true
  !gapprompt@gap>| !gapinput@IsAlgebraHomomorphism(bdy);
|
  true
  !gapprompt@gap>| !gapinput@PM:=PreXModAlgByBoundaryAndAction(bdy,act);
|
  <enumerator>
  !gapprompt@gap>| !gapinput@IsPreXModAlg(PM);|
  true
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{(Pre-)Crossed Module Morphisms}}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X866610BC7C41E1EC}{}
{
 Let $\mathcal{X} = (\partial:S\rightarrow R)$, $\mathcal{X}^{\prime} = (\partial^{\prime }:S^{\prime }\rightarrow R^{\prime })$ be (pre)crossed modules and $\theta :S\rightarrow S^{\prime }$, $\varphi : R\rightarrow R^{\prime }$ be algebra homomorphisms. If 
\[ \varphi \partial = \partial ^{\prime }\theta, \qquad \theta (r\cdot
s)=\varphi(r) \cdot \theta (s), \]
 for all $r\in R$, $s\in S,$ then the pair $(\theta ,\varphi )$ is called a morphism between $\mathcal{X}=(\partial :S\rightarrow R)$ and $\mathcal{X}^{\prime } = (\partial ^{\prime }:S^{\prime }\rightarrow R^{\prime
})$ 

 The conditions can be thought as the commutativity of the following diagrams: 
\[ diagram~~missing~~here! \]
 $ \xymatrix { Y \ar[r]^g } $    

 In \textsf{GAP} we define the morphisms between algebraic structures such as cat$^{1}$-algebras and crossed modules and they are investigated by the function \texttt{Make2AlgMorphism}. The main part of the implementation of this function is given below. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  InstallMethod( Make2dAlgMapping,
      "for 2d-object, 2d-object, homomorphism, homomorphism", true,
      [ Is2dAlgObject, Is2dAlgObject,
      IsAlgebraHomomorphism, IsAlgebraHomomorphism ], 0,
  function( src, rng, shom, rhom )
      local  filter, fam, mor, ok;
      fam := FamilyObj( [ src, rng, shom, rhom ] );
      filter := Is2dAlgMappingRep;
      ok := ( ( Source( src ) = Source( shom ) ) and
              (  Range( src ) = Source( rhom ) ) and
              ( Source( rng ) = Range( shom ) ) and
              (  Range( rng ) = Range( rhom ) ) );
      if not ok then
          Info( InfoXModAlg, 2, "sources and ranges do not match" );
          return fail;
      fi;
      mor := rec();
      ObjectifyWithAttributes( mor,
        NewType( fam, filter ),
        Source, src,
        Range, rng,
        SourceHom, shom,
        RangeHom, rhom );
      return mor;
  end
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{XModAlgMorphism}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X7A4F44F07966416B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgMorphism({\mdseries\slshape arg})\index{XModAlgMorphism@\texttt{XModAlgMorphism}}
\label{XModAlgMorphism}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IdentityMapping({\mdseries\slshape X0})\index{IdentityMapping@\texttt{IdentityMapping}}
\label{IdentityMapping}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreXModAlgMorphismByHoms({\mdseries\slshape f, g})\index{PreXModAlgMorphismByHoms@\texttt{PreXModAlgMorphismByHoms}}
\label{PreXModAlgMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgMorphismByHoms({\mdseries\slshape f, g})\index{XModAlgMorphismByHoms@\texttt{XModAlgMorphismByHoms}}
\label{XModAlgMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreXModAlgMorphism({\mdseries\slshape f})\index{IsPreXModAlgMorphism@\texttt{IsPreXModAlgMorphism}}
\label{IsPreXModAlgMorphism}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsXModAlgMorphism({\mdseries\slshape f})\index{IsXModAlgMorphism@\texttt{IsXModAlgMorphism}}
\label{IsXModAlgMorphism}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape m})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape m})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsTotal({\mdseries\slshape m})\index{IsTotal@\texttt{IsTotal}}
\label{IsTotal}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSingleValued({\mdseries\slshape m})\index{IsSingleValued@\texttt{IsSingleValued}}
\label{IsSingleValued}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Name({\mdseries\slshape m})\index{Name@\texttt{Name}}
\label{Name}
}\hfill{\scriptsize (attribute)}}\\


 These operations construct crossed module homomorphisms, which may have the
attributes listed. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@A:=GroupRing(GF(2),CyclicGroup(6));
|
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@B:=AugmentationIdeal(A);
|
  <two-sided ideal in <algebra-with-one over GF(2), with 2 generators>
  ,(dimension 5)>
  !gapprompt@gap>| !gapinput@CM:=XModAlg(A,B);
|
  [Algebra( GF(2), ... )->AlgebraWithOne( GF(2), ... )]
  SetName(CM,"GF_2C_6");
  !gapprompt@gap>| !gapinput@Display(CM);
|
  Crossed module GF_2C_6 :- 
  : Source algebra has generators:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f2^2, 
    (Z(2)^0)*f1+(Z(2)^0)*f2^2, (Z(2)^0)*f1*f2+(Z(2)^0)*f2^2, 
    (Z(2)^0)*f2^2+(Z(2)^0)*f1*f2^2 ]
  : Range algebra has generators:
    [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  : Boundary homomorphism maps source generators to:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f2^2, 
    (Z(2)^0)*f1+(Z(2)^0)*f2^2, (Z(2)^0)*f1*f2+(Z(2)^0)*f2^2, 
    (Z(2)^0)*f2^2+(Z(2)^0)*f1*f2^2 ]
  !gapprompt@gap>| !gapinput@f:=IdentityMapping(CM);
|
  [[..] => [..]]
  !gapprompt@gap>| !gapinput@IsPreXModAlgMorphism(f);
|
  true
  !gapprompt@gap>| !gapinput@IsXModAlgMorphism(f);
|
  true
  !gapprompt@gap>| !gapinput@Display(f);
|
  Morphism of crossed modules :-
  : Source = [Algebra( GF(2), [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1
    ,(Z(2)^0)*f1+(Z(2)^0)*f2, (Z(2)^0)*f2+(Z(2)^0)*f1*f2,
    (Z(2)^0)*f1*f2+(Z(2)^0)*f2^2, (Z(2)^0)*f2^2+(Z(2)^0)*f1*f2^2
   ] )->AlgebraWithOne( GF(2), [ (Z(2)^0)*f1, (Z(2)^0)*f2
   ] )] with generating sets:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1, (Z(2)^0)*f1+(Z(2)^0)*f2,
    (Z(2)^0)*f2+(Z(2)^0)*f1*f2, (Z(2)^0)*f1*f2+(Z(2)^0)*f2^2,
    (Z(2)^0)*f2^2+(Z(2)^0)*f1*f2^2 ]
    [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  : Range = Source
  : Source Homomorphism maps source generators to:
    [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1, (Z(2)^0)*f1+(Z(2)^0)*f2,
    (Z(2)^0)*f2+(Z(2)^0)*f1*f2, (Z(2)^0)*f1*f2+(Z(2)^0)*f2^2,
    (Z(2)^0)*f2^2+(Z(2)^0)*f1*f2^2 ]
  : Range Homomorphism maps range generators to:
    [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  !gapprompt@gap>| !gapinput@IsTotal(f);
|
  true
  !gapprompt@gap>| !gapinput@IsSingleValued(f);
|
  true
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Kernel}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X7DCD99628504B810}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Kernel({\mdseries\slshape X0})\index{Kernel@\texttt{Kernel}}
\label{Kernel}
}\hfill{\scriptsize (operation)}}\\


 Let $(\theta,\varphi) : \mathcal{X} = (\partial : S \rightarrow R) \rightarrow
\mathcal{X}^{\prime} = (\partial^{\prime} : S^{\prime} \rightarrow R^{\prime})$ be a crossed module homomorphism. Then the crossed module 
\[ \ker(\theta,\varphi) = (\partial|_? : \ker\theta \rightarrow \ker\varphi ) \]
 is called the \emph{kernel} of $(\theta,\varphi)$. Also, $\ker(\theta ,\varphi )$ is an ideal of $\mathcal{X}$. An example is given below. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@PM:=Kernel(f);
|
  [Algebra( GF(2), [], <zero> of ... )->Algebra( GF(2), [],
  <zero> of ... )]
  !gapprompt@gap>| !gapinput@IsXModAlg(PM);
|
  true
  !gapprompt@gap>| !gapinput@IsSubXModAlg(CM,PM);
|
  true
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Image}}
\logpage{[ 2, 2, 3 ]}\nobreak
\hyperdef{L}{X87F4D35A826599C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Image({\mdseries\slshape X0})\index{Image@\texttt{Image}}
\label{Image}
}\hfill{\scriptsize (operation)}}\\


 Let $(\theta,\varphi) : \mathcal{X} = (\partial : S \rightarrow R) \rightarrow
\mathcal{X}^{\prime} = (\partial^{\prime} : S^{\prime} \rightarrow R^{\prime})$ be a crossed module homomorphism. Then the crossed module 
\[ Im(\theta,\varphi) = (\partial^{\prime}|_? : Im\theta \rightarrow Im\varphi) \]
 is called the image of $(\theta,\varphi)$. Further, $Im(\theta,\varphi)$ is a subcrossed module of $(S^{\prime},R^{\prime},\partial^{\prime})$. 

 In our package, the image of a crossed module homomorphism can be obtained by
the command \texttt{Image2dAlgMapping}. The operation \texttt{Sub2dAlgObject} is effectively used for finding the kernel and image crossed modules induced
from a given crossed module homomorphism. }

 

\subsection{\textcolor{Chapter }{SourceHom}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X7B7975DA7E870690}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SourceHom({\mdseries\slshape m})\index{SourceHom@\texttt{SourceHom}}
\label{SourceHom}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RangeHom({\mdseries\slshape m})\index{RangeHom@\texttt{RangeHom}}
\label{RangeHom}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsInjective({\mdseries\slshape m})\index{IsInjective@\texttt{IsInjective}}
\label{IsInjective}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSurjective({\mdseries\slshape m})\index{IsSurjective@\texttt{IsSurjective}}
\label{IsSurjective}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsBijjective({\mdseries\slshape m})\index{IsBijjective@\texttt{IsBijjective}}
\label{IsBijjective}
}\hfill{\scriptsize (attribute)}}\\


 Let $(\theta,\varphi)$ be a homomorphism of crossed modules. If the homomorphisms $\theta$ and $\varphi$ are injective (surjective) then $(\theta,\varphi)$ is injective (surjective). 

 The attributes \texttt{SourceHom} and \texttt{RangeHom} store the two algebra homomorphisms $\theta$ and $\varphi$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@theta:=SourceHom(f);
|
  IdentityMapping( <two-sided ideal in <algebra-with-one of dimension
  6 over GF(2)>, (dimension 5)> )
  !gapprompt@gap>| !gapinput@phi:=RangeHom(f);
|
  IdentityMapping( <algebra-with-one of dimension 6 over GF(2)> )
  !gapprompt@gap>| !gapinput@IsInjective(f);
|
  true
  !gapprompt@gap>| !gapinput@IsSurjective(f);
|
  true
  !gapprompt@gap>| !gapinput@IsBijective(f);
|
  true
  
\end{Verbatim}
 }

 }

            
\chapter{\textcolor{Chapter }{Cat1-algebras}}\label{chap-cat1}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X85527BA8786CB7FC}{}
{
  
\section{\textcolor{Chapter }{Definitions and examples}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X811B6B0F8203F972}{}
{
  \index{cat1-group} Algebraic structures which are equivalent to crossed modules of algebras,
namely; 
\begin{itemize}
\item  cat$^{1}$-algebras. (Ellis, \cite{ellis1}); 
\item  simplicial algebras with Moore complex of length 1 (Z. Arvasi and T.Porter, \cite{arvasi2}); 
\item  algebra-algebroids (Gaffar Musa's Ph.D. thesis, \cite{mosa}). 
\end{itemize}
 In this section we describe an implementation of cat$^{1}$-algebras and their morphisms. 

 The notion of cat$^{1}$-groups was defined as an algebraic model of $2$-types by Loday in \cite{loday}. Then Ellis defined the cat$^{1}$-algebras in \cite{ellis1}. 

 Let $A$and $R$be $k$-algebras, let $s,t:A\rightarrow R$ be surjections, and let $e:R\rightarrow A$ be an inclusion. 
\[ diagram~~missing~~here! \]
 If the conditions, 
\[ \mathbf{Cat1Alg1:} \quad se = id_{R}, \qquad \mathbf{Cat1Alg2:} \quad (\ker
s)(\ker t) = \{0_{A}\} \]
 are satisfied, then the algebraic system $\mathcal{C} := (e;t,s : A \rightarrow R)$ is called a cat$^{1}$-algebra. The system which satisfy the condition $\mathbf{Cat1Alg1}$ is called a \emph{precat$^{1}$-algebra}. The homomorphisms $s,t$ and $e$ are called the \emph{initial}, \emph{terminal} and \emph{embedding} homomorphisms \textsc{or} the \emph{tail}, \emph{head} and \emph{embedding} homomorphisms, respectively. 

\subsection{\textcolor{Chapter }{Cat1}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7F4221DF83D1B6D8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1({\mdseries\slshape args})\index{Cat1@\texttt{Cat1}}
\label{Cat1}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1AlgByTailHeadEmbedding({\mdseries\slshape s, t, e})\index{PreCat1AlgByTailHeadEmbedding@\texttt{PreCat1AlgByTailHeadEmbedding}}
\label{PreCat1AlgByTailHeadEmbedding}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1AlgByEndomorphisms({\mdseries\slshape s, t})\index{PreCat1AlgByEndomorphisms@\texttt{PreCat1AlgByEndomorphisms}}
\label{PreCat1AlgByEndomorphisms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1AlgObj({\mdseries\slshape C})\index{PreCat1AlgObj@\texttt{PreCat1AlgObj}}
\label{PreCat1AlgObj}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1Alg({\mdseries\slshape C})\index{PreCat1Alg@\texttt{PreCat1Alg}}
\label{PreCat1Alg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsIdentityCat1Alg({\mdseries\slshape C})\index{IsIdentityCat1Alg@\texttt{IsIdentityCat1Alg}}
\label{IsIdentityCat1Alg}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCat1Alg({\mdseries\slshape C})\index{IsCat1Alg@\texttt{IsCat1Alg}}
\label{IsCat1Alg}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreCat1Alg({\mdseries\slshape C})\index{IsPreCat1Alg@\texttt{IsPreCat1Alg}}
\label{IsPreCat1Alg}
}\hfill{\scriptsize (attribute)}}\\


 The operations listed above are used for construction of precat$^{1}$ and cat$^{1}$-algebra structures. The function \texttt{Cat1Alg} selects the operation from the above implementations up to user's input. The
operation \texttt{PreCat1AlgObj} is used for preserving the implementations, }

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape C})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape C})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Tail({\mdseries\slshape C})\index{Tail@\texttt{Tail}}
\label{Tail}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Head({\mdseries\slshape C})\index{Head@\texttt{Head}}
\label{Head}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Embedding({\mdseries\slshape C})\index{Embedding@\texttt{Embedding}}
\label{Embedding}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Kernel({\mdseries\slshape C})\index{Kernel@\texttt{Kernel}}
\label{Kernel}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Boundary({\mdseries\slshape C})\index{Boundary@\texttt{Boundary}}
\label{Boundary}
}\hfill{\scriptsize (attribute)}}\\


 These are the seven main attributes of a pre-cat$^{1}$-algebra. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@H:=GF(4);|
  GF(2^2)
  !gapprompt@gap>| !gapinput@k4:=Group((1,2),(3,4));|
  Group([ (1,2), (3,4) ])
  !gapprompt@gap>| !gapinput@R:=GroupRing(H,k4);|
  <algebra-with-one over GF(2^2), with 2 generators>
  !gapprompt@gap>| !gapinput@Size(R);|
  256
  !gapprompt@gap>| !gapinput@gR:=GeneratorsOfAlgebra(R);|
  [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ]
  !gapprompt@gap>| !gapinput@f:=AlgebraHomomorphismByImages(R,R,gR,gR);|
  [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ] ->
  [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ]
  !gapprompt@gap>| !gapinput@IsAlgebraHomomorphism(f);|
  true
  !gapprompt@gap>| !gapinput@C:=Cat1Alg(f,f,f);|
  [AlgebraWithOne( GF(2^2), [ (Z(2)^0)*(1,2), (Z(2)^0)*(3,4)
   ] ) -> AlgebraWithOne( GF(2^2), [ (Z(2)^0)*(1,2),
   (Z(2)^0)*(3,4) ] )]
  !gapprompt@gap>| !gapinput@IsCat1Alg(C);|
  true
  !gapprompt@gap>| !gapinput@Size(C);|
  [ 256, 256 ]
  !gapprompt@gap>| !gapinput@Display(C);|
  
  Cat1-algebra [..=>..] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(3,4) ]
  : the kernel is trivial.
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Cat1AlgSelect}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X839207ED855ECCB4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgSelect({\mdseries\slshape gf, size, gpnum, num})\index{Cat1AlgSelect@\texttt{Cat1AlgSelect}}
\label{Cat1AlgSelect}
}\hfill{\scriptsize (operation)}}\\


 In general, the three morphisms used for constructing the cat$^{1}$-algebra structure do not satisfy the conditions. A list of finite dimensional
group is obtained using the program complex more effectively. 

 By using the groups and Galois fields, we obtain the list of the cat$^{1}$-algebras of group algebras, and insert the list in to the program complex.
The \textsf{GAP} users can easily obtain finite cat$^{1}$-algebras by using this list. For this, we provide the function \texttt{Cat1AlgSelect} and link it to the operation \texttt{Cat1Alg}. 

 There are four basic parameters for using this operation: 
\begin{itemize}
\item  \texttt{gf}, the dimension of the Galois field, 
\item  \texttt{size}, the dimension of the group that will used, 
\item  \texttt{gpnum}, the order of the group with same dimension in the list. 
\item  \texttt{num}, the order of the cat$^{1}-$algebra constructed up to the given first three values. 
\end{itemize}
 

 Now, we will give an example for the usage of this function. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@C:=Cat1AlgSelect(4,6,2,2);|
  [GF(2^2)_c6 -> GF(2^2)_triv]
  !gapprompt@gap>| !gapinput@Size(C);|
  [ 4096, 4 ]
  !gapprompt@gap>| !gapinput@Display(C);|
  
  Pre-cat1-algebra [GF(2^2)_c6=>GF(2^2)_triv] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3)(4,5) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : kernel has generators:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3)(4,5), (Z(2)^0)*()+(Z(2)^0)*(1,3,2),
    (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*()+(Z(2)^0)*(1,2,3),
    (Z(2)^0)*()+(Z(2)^0)*(1,3,2)(4,5) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ..., <zero> of ..., <zero> of ..., <zero> of ...
    , <zero> of ...  ]
  : kernel embedding maps generators of kernel to:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2,3)(4,5), (Z(2)^0)*()+(Z(2)^0)*(1,3,2),
    (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*()+(Z(2)^0)*(1,2,3),
    (Z(2)^0)*()+(Z(2)^0)*(1,3,2)(4,5) ]
  
\end{Verbatim}
 We give additional missions to the function \texttt{Cat1AlgSelect} to give more information about the list which was inserted to the program
complex. At this vein, the function \texttt{Cat1AlgSelect} works without inputting all four parameters given above. In the usage of
single parameter, last three parameters assumed to be zero and obtained
information about the largest dimensions of groups that can be used for the
Galois field with given dimension. For example, 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@Cat1AlgSelect(11);|
  There are groups having orders maximum 9 for GF(11) in the list.
  fail
  
\end{Verbatim}
 In two parameter usage, the last two parameters are assumed to be zero. The
operation returns information about the number of groups that can be used for
the given dimensional Galois field. For example, 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@Cat1AlgSelect(11,8);|
   0 is a invalid gpnum number.
   where 0 < gpnum <= 5 for gpsize 8.
  Usage:  Cat1Alg( GF(num), gpsize, gpnum, num );
  [ "GF(11)_c8","GF(11)_c4c2","GF(11)_d8","GF(11)_q8","GF(11)_c2^3" ]
  
\end{Verbatim}
 In three parameter usage, the last parameter assumed to be zero, and obtained
information about the number of cat$^{1}-$algebras and their morphisms which can be constructed by Galois field with the
given dimensional and group. The user make selection about the last parameter
by this way. For example, 
\begin{Verbatim}[commandchars=!@B,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>B !gapinput@Cat1AlgSelect(11,8,5);B
  
  There are 13 cat1-structures for the algebra GF(11)_c2^3.
    Range Alg,     Tail Genimg,       Head Genimg
  |---------------------------------------------------|
  | GF(11)_c2^3,  identity map       identity map     |
  | GF(11)_triv,  [ 1, 1, 1, 1 ],    [ 1, 1, 1, 1 ]   |
  | GF(11)_c2,    [ 1, 1, 1, 2 ],    [ 1, 1, 1, 2 ]   |
  | GF(11)_c2,    [ 1, 1, 2, 2 ],    [ 1, 1, 2, 2 ]   |
  | GF(11)_c2,    [ 1, 2, 2, 2 ],    [ 1, 2, 2, 2 ]   |
  | GF(11)_c2,    [ 1, 2, 1, 2 ],    [ 1, 2, 1, 2 ]   |
  | GF(11)_c2,    [ 1, 2, 1, 2 ],    [ 1, 1, 1, 2 ]   |
  | GF(11)_c2,    [ 1, 2, 2, 2 ],    [ 1, 1, 2, 2 ]   |
  | GF(11)_c2,    [ 1, 2, 2, 2 ],    [ 1, 1, 1, 2 ]   |
  | GF(11)_c2,    [ 1, 2, 2, 2 ],    [ 1, 2, 1, 2 ]   |
  | GF(11)_k4,    [ 1, 1, 2, 3 ],    [ 1, 1, 2, 3 ]   |
  | GF(11)_k4,    [ 1, 3, 2, 3 ],    [ 1, 3, 2, 3 ]   |
  | GF(11)_k4,    [ 1, 3, 2, 3 ],    [ 1, 1, 2, 3 ]   |
  |---------------------------------------------------|
  Usage:  Cat1Alg( GF(num), gpsize, gpnum, num );
  Algebra has generators [ (Z(11)^0)*(), (Z(11)^0)*(1,2),
  (Z(11)^0)*(3,4), (Z(11)^0)*(5,6) ]
  13
  
  
\end{Verbatim}
 In the four parameter usage, if the $n$-th parameter, $n=2,3,4$ is not compotable with the list, then the output constructed up to the $n-1$ parameter usage. 

\subsection{\textcolor{Chapter }{SubCat1Alg}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X84E2C1038434CB53}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubCat1Alg({\mdseries\slshape arg})\index{SubCat1Alg@\texttt{SubCat1Alg}}
\label{SubCat1Alg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubPreCat1Alg({\mdseries\slshape arg})\index{SubPreCat1Alg@\texttt{SubPreCat1Alg}}
\label{SubPreCat1Alg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubCat1Alg({\mdseries\slshape arg})\index{IsSubCat1Alg@\texttt{IsSubCat1Alg}}
\label{IsSubCat1Alg}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubPreCat1Alg({\mdseries\slshape arg})\index{IsSubPreCat1Alg@\texttt{IsSubPreCat1Alg}}
\label{IsSubPreCat1Alg}
}\hfill{\scriptsize (attribute)}}\\


 Let $\mathcal{C} = (e;t,s:A\rightarrow R)$ be a cat$^{1}$-algebra, and let $A^{\prime}$, $R^{\prime}$ be subalgebras of $A$ and $R$ respectively. If the restriction morphisms 
\[ t^{\prime} = t|_{A^{\prime}} : A^{\prime}\rightarrow R^{\prime}, \qquad
s^{\prime} = s|_{A^{\prime}} : A^{\prime}\rightarrow R^{\prime}, \qquad
e^{\prime} = e|_{R^{\prime}} : R^{\prime}\rightarrow A^{\prime} \]
 satisfy the $\mathbf{Cat1Alg1}$ and $\mathbf{Cat1Alg2}$ conditions, then the system $\mathcal{C}^{\prime } = (e^{\prime};t^{\prime},s^{\prime} : A^{\prime}
\rightarrow R^{\prime})$ is called a \emph{subcat$^{1}$-algebra} of $\mathcal{C} = (e;t,s:A\rightarrow R)$. 

 If the morphisms satisfy only the $\mathbf{Cat1Alg1}$ condition then $\mathcal{C}^{\prime }$ is called a \emph{sub-precat$^{1}$-algebra} of $\mathcal{C}$. 

 The operations in this subsection are used for constructing subcat$^{1}$-algebras of a given cat$^{1}$-algebra. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@C:=Cat1AlgSelect(2,6,2,4);|
  [GF(2)_c6 -> GF(2)_c3]
  !gapprompt@gap>| !gapinput@Display(C);|
  
  Cat1-algebra [GF(2)_c6=>GF(2)_c3] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3)(4,5) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3) ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3) ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3) ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2,3) ]
  : kernel has generators:
    [ (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*(1,2,3)+
    (Z(2)^0)*(1,2,3)(4,5), (Z(2)^0)*(1,3,2)+
    (Z(2)^0)*(1,3,2)(4,5) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ..., <zero> of ..., <zero> of ... ]
  : kernel embedding maps generators of kernel to:
    [ (Z(2)^0)*()+(Z(2)^0)*(4,5), (Z(2)^0)*(1,2,3)+
    (Z(2)^0)*(1,2,3)(4,5),(Z(2)^0)*(1,3,2)
    +(Z(2)^0)*(1,3,2)(4,5) ]
  
  !gapprompt@gap>| !gapinput@A:=Source(C);|
  GF(2)_c6
  !gapprompt@gap>| !gapinput@B:=Range(C);|
  GF(2)_c3
  !gapprompt@gap>| !gapinput@eA:=Elements(A);;|
  !gapprompt@gap>| !gapinput@eB:=Elements(B);;|
  !gapprompt@gap>| !gapinput@AA:=Subalgebra(A,[eA[1],eA[2],eA[3]]);|
  <algebra over GF(2), with 3 generators>
  !gapprompt@gap>| !gapinput@A=AA;|
  false
  !gapprompt@gap>| !gapinput@BB:=Subalgebra(B,[eB[1],eB[2]]);|
  <algebra over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@BB=B;|
  false
  !gapprompt@gap>| !gapinput@CC:=SubCat1Alg(C,AA,BB);|
  [Algebra( GF(2), [ <zero> of ..., (Z(2)^0)*(), (Z(2)^0)*()
  +(Z(2)^0)*(4,5) ] ) -> Algebra( GF(2),
  [ <zero> of ..., (Z(2)^0)*() ] )]
  !gapprompt@gap>| !gapinput@IsSubCat1Alg(C,CC);|
  true
  !gapprompt@gap>| !gapinput@Display(CC);|
  
  Cat1-algebra [..=>..] :-
  : source algebra has generators:
    [ <zero> of ..., (Z(2)^0)*(), (Z(2)^0)*()+(Z(2)^0)*(4,5) ]
  :  range algebra has generators:
    [ <zero> of ..., (Z(2)^0)*() ]
  : tail homomorphism maps source generators to:
    [ <zero> of ..., (Z(2)^0)*(), <zero> of ... ]
  : head homomorphism maps source generators to:
    [ <zero> of ..., (Z(2)^0)*(), <zero> of ... ]
  : range embedding maps range generators to:
    [ <zero> of ..., (Z(2)^0)*() ]
  : kernel has generators:
    [ <zero> of ..., (Z(2)^0)*()+(Z(2)^0)*(4,5) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ..., <zero> of ... ]
  : kernel embedding maps generators of kernel to:
    [ <zero> of ..., (Z(2)^0)*()+(Z(2)^0)*(4,5) ]
  
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Cat$^{1}-$algebra morphisms}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X8159613D81C201EA}{}
{
  Let $\mathcal{C} = (e;t,s:A\rightarrow R)$, $\mathcal{C}^{\prime } = (e^{\prime}; t^{\prime }, s^{\prime } : A^{\prime}
\rightarrow R^{\prime})$ be cat$^{1}$-algebras, and let $\phi : A\rightarrow A^{\prime}$ and $\varphi : R \rightarrow R^{\prime}$ be algebra homomorphisms. If the diagram 
\[ another~~missing~~diagram \]
 commutes, (i.e $t^{\prime}\phi = \varphi t$, $s^{\prime}\phi = \varphi s$ and $e^{\prime }\varphi = \phi e$), then the pair $(\phi ,\varphi )$is called a cat$^{1}$-algebra morphism. 

\subsection{\textcolor{Chapter }{Cat1AlgMorphism}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7E381D3F85C14235}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgMorphism({\mdseries\slshape arg})\index{Cat1AlgMorphism@\texttt{Cat1AlgMorphism}}
\label{Cat1AlgMorphism}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IdentityMapping({\mdseries\slshape C})\index{IdentityMapping@\texttt{IdentityMapping}}
\label{IdentityMapping}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1AlgMorphismByHoms({\mdseries\slshape f, g})\index{PreCat1AlgMorphismByHoms@\texttt{PreCat1AlgMorphismByHoms}}
\label{PreCat1AlgMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgMorphismByHoms({\mdseries\slshape f, g})\index{Cat1AlgMorphismByHoms@\texttt{Cat1AlgMorphismByHoms}}
\label{Cat1AlgMorphismByHoms}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPreCat1AlgMorphism({\mdseries\slshape C})\index{IsPreCat1AlgMorphism@\texttt{IsPreCat1AlgMorphism}}
\label{IsPreCat1AlgMorphism}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCat1AlgMorphism({\mdseries\slshape arg})\index{IsCat1AlgMorphism@\texttt{IsCat1AlgMorphism}}
\label{IsCat1AlgMorphism}
}\hfill{\scriptsize (attribute)}}\\


 These operations are used for constructing cat$^{1}$-algebra morphisms. Details of the implementations can be found in \cite{aodabas1}. }

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Source({\mdseries\slshape m})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Range({\mdseries\slshape m})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsTotal({\mdseries\slshape m})\index{IsTotal@\texttt{IsTotal}}
\label{IsTotal}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSingleValued({\mdseries\slshape m})\index{IsSingleValued@\texttt{IsSingleValued}}
\label{IsSingleValued}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Name({\mdseries\slshape m})\index{Name@\texttt{Name}}
\label{Name}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Boundary({\mdseries\slshape m})\index{Boundary@\texttt{Boundary}}
\label{Boundary}
}\hfill{\scriptsize (attribute)}}\\


 These are the six main attributes of a cat$^{1}$-algebra morphism. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@C1:=Cat1Alg(2,1,1,1);|
  [GF(2)_triv -> GF(2)_triv]
  !gapprompt@gap>| !gapinput@Display(C1);|
  
  Cat1-algebra [GF(2)_triv=>GF(2)_triv] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : the kernel is trivial.
  
  !gapprompt@gap>| !gapinput@C2:=Cat1Alg(2,2,1,2);|
  [GF(2)_c2 -> GF(2)_triv]
  !gapprompt@gap>| !gapinput@Display(C2);|
  
  Cat1-algebra [GF(2)_c2=>GF(2)_triv] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : kernel has generators:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2) ]
  : boundary homomorphism maps generators of kernel to:
    [ <zero> of ... ]
  : kernel embedding maps generators of kernel to:
    [ (Z(2)^0)*()+(Z(2)^0)*(1,2) ]
  
  !gapprompt@gap>| !gapinput@C1=C2;|
  false
  !gapprompt@gap>| !gapinput@R1:=Source(C1);;|
  !gapprompt@gap>| !gapinput@R2:=Source(C2);;|
  !gapprompt@gap>| !gapinput@S1:=Range(C1);;|
  !gapprompt@gap>| !gapinput@S2:=Range(C2);;|
  !gapprompt@gap>| !gapinput@gR1:=GeneratorsOfAlgebra(R1);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@gR2:=GeneratorsOfAlgebra(R2);|
  [ (Z(2)^0)*(), (Z(2)^0)*(1,2) ]
  !gapprompt@gap>| !gapinput@gS1:=GeneratorsOfAlgebra(S1);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@gS2:=GeneratorsOfAlgebra(S2);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@im1:=[gR2[1],gR2[1]];|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@f1:=AlgebraHomomorphismByImages(R1,R2,gR1,im1);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ] -> [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@im2:=[gS2[1],gS2[1]];|
  [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@f2:=AlgebraHomomorphismByImages(S1,S2,gS1,im2);|
  [ (Z(2)^0)*(), (Z(2)^0)*() ] -> [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@m:=Cat1AlgMorphism(C1,C2,f1,f2);|
  [[GF(2)_triv=>GF(2)_triv] => [GF(2)_c2=>GF(2)_triv]]
  !gapprompt@gap>| !gapinput@Display(m);|
  Morphism of cat1-algebras :-
  : Source = [GF(2)_triv=>GF(2)_triv] with generating sets:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  :  Range = [GF(2)_c2=>GF(2)_triv] with generating sets:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2) ]
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : Source Homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  : Range Homomorphism maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*() ]
  !gapprompt@gap>| !gapinput@Image2dAlgMapping(m);|
  [GF(3)_c2^3=>GF(3)_c2^3]
  !gapprompt@gap>| !gapinput@IsSurjective(m);|
  false
  !gapprompt@gap>| !gapinput@IsInjective(m);|
  true
  !gapprompt@gap>| !gapinput@IsBijective(m);|
  false
  
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Equivalent Categories}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X8617844F86989A78}{}
{
  The categories $\mathbf{Cat1Alg}$ (cat$^{1}$-algebras) and $\mathbf{XModAlg}$ (crossed modules) are naturally equivalent \cite{ellis1}. This equivalence is outlined in waht follows. For a given crossed module $\partial : A \rightarrow R$ we can construct the semidirect product $R\ltimes A$ thanks to the action of $R$ on $A$. If we define $t,s : R\ltimes A \rightarrow R$ and $e : R \rightarrow R \ltimes A$ by 
\[ s(r,a) = r, \qquad t(r,a) = r+\partial(a), \qquad e(r) = (r,0), \]
 respectively, then $\mathcal{C} = (e;t,s : R \ltimes A \rightarrow R)$ is a cat$^{1}-$algebra. 

 Conversely, for a given cat$^{1}$-algebra $\mathcal{C}=(e;t,s : A \rightarrow R)$, the map $\partial : \ker s \rightarrow R$ is a crossed module, where the action is conjugate action and $\partial$is the restriction of $t$to $\ker s$. (\emph{What is conjugation \texttt{\symbol{92}}action?} 

\subsection{\textcolor{Chapter }{PreCat1AlgByPreXModAlg}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X82B6E24B85B0785E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreCat1AlgByPreXModAlg({\mdseries\slshape X0})\index{PreCat1AlgByPreXModAlg@\texttt{PreCat1AlgByPreXModAlg}}
\label{PreCat1AlgByPreXModAlg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreXModAlgByPreCat1Alg({\mdseries\slshape C})\index{PreXModAlgByPreCat1Alg@\texttt{PreXModAlgByPreCat1Alg}}
\label{PreXModAlgByPreCat1Alg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cat1AlgByXModAlg({\mdseries\slshape X0})\index{Cat1AlgByXModAlg@\texttt{Cat1AlgByXModAlg}}
\label{Cat1AlgByXModAlg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{XModAlgByCat1Alg({\mdseries\slshape C})\index{XModAlgByCat1Alg@\texttt{XModAlgByCat1Alg}}
\label{XModAlgByCat1Alg}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KernelDenkt({\mdseries\slshape t})\index{KernelDenkt@\texttt{KernelDenkt}}
\label{KernelDenkt}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KernelDenkh({\mdseries\slshape h})\index{KernelDenkh@\texttt{KernelDenkh}}
\label{KernelDenkh}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SDproduct({\mdseries\slshape C})\index{SDproduct@\texttt{SDproduct}}
\label{SDproduct}
}\hfill{\scriptsize (operation)}}\\


 These operations are used for constructing a cat$^{1}$-algebra from a given crossed module, and conversely. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R:=GroupRing(GF(3),CyclicGroup(2));|
  <algebra-with-one over GF(3), with 1 generators>
  !gapprompt@gap>| !gapinput@I:=AugmentationIdeal(R);|
  <two-sided ideal in <algebra-with-one over GF(3), with 1 generators>,
    (1 generators)>
  !gapprompt@gap>| !gapinput@CM:=XModAlgByIdeal(R,I);|
  [Algebra( GF(3), [ (Z(3))*<identity> of ...+(Z(3)^0)*f1
   ] )->AlgebraWithOne( GF(3), [ (Z(3)^0)*f1 ] )]
  !gapprompt@gap>| !gapinput@IsXModAlg(CM);|
  true
  !gapprompt@gap>| !gapinput@C:=Cat1AlgByXModAlg(CM);|
  [AlgebraWithOne( GF(3), [ (Z(3)^0)*f1 ] ) IX Algebra( GF(3),
  [ (Z(3))*<identity> of ...+(Z(3)^0)*f1 ] ) -> AlgebraWithOne( GF(3),
  [ (Z(3)^0)*f1 ] )]
  !gapprompt@gap>| !gapinput@IsCat1Alg(C);|
  true
  !gapprompt@gap>| !gapinput@SM:=XModAlgByCat1Alg(C);|
  [..->..]
  !gapprompt@gap>| !gapinput@SM=CM;|
  true
  
  
\end{Verbatim}
 Since all these operations are linked to the functions \texttt{Cat1Alg} and \texttt{XModAlg}, all of them can be done by using these two functions. We may also use the
function \texttt{Cat1Alg} instead of the operation \texttt{Cat1AlgSelect}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@C:=Cat1Alg(4,6,1,1);|
  [GF(2^2)_s3 -> GF(2^2)_s3]
  !gapprompt@gap>| !gapinput@IsCat1Alg(C);|
  true
  !gapprompt@gap>| !gapinput@Display(C);|
  
  Cat1-algebra [GF(2^2)_s3=>GF(2^2)_s3] :-
  : source algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(2,3) ]
  :  range algebra has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(2,3) ]
  : tail homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(2,3) ]
  : head homomorphism maps source generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(2,3) ]
  : range embedding maps range generators to:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(2,3) ]
  : the kernel is trivial.
  
  !gapprompt@gap>| !gapinput@CM:=XModAlg(C);|
  [Algebra( GF(2^2), [], <zero> of ... )->GF(2^2)_s3]
  !gapprompt@gap>| !gapinput@IsXModAlg(CM);|
  true
  !gapprompt@gap>| !gapinput@Display(CM);|
  
  Crossed module [..->GF(2^2)_s3] :-
  : Source group has generators:
    [  ]
  : Range group has generators:
    [ (Z(2)^0)*(), (Z(2)^0)*(1,2), (Z(2)^0)*(2,3) ]
  : Boundary homomorphism maps source generators to:
    [  ]
  
  !gapprompt@gap>| !gapinput@CC:=Cat1Alg(CM);|
  [GF(2^2)_s3=>GF(2^2)_s3]
  !gapprompt@gap>| !gapinput@CC=C;|
  true
  
\end{Verbatim}
 }

 }

            
\chapter{\textcolor{Chapter }{Crossed modules of Lie algebras}}\label{chap-lie}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X87A4C14286A3FC3F}{}
{
  To be added. }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
