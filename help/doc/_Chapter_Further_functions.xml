<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Further_functions">
<Heading>Further functions</Heading>

A short remark is probably in order on the three global variables the package is using:
<K>HeLP_CT</K>, <K>HeLP_sol</K> and <K>HeLP_settings</K>. The first one stores the character table for
which the last calculations were performed, the second one containing at the <K>k</K>'s spot the already calculated
admissible partial augmentations of elements of order <Math>k</Math> (and its powers <Math>u^d</Math> for <Math>d \not= k</Math> a divisor of <Math>k</Math>). If a function of the HeLP-package is called with
a character table different from the one saved in <K>HeLP_CT</K> then the package tries to check if the character tables
belong to the same group. This can be done in particular for tables from the ATLAS. If this check is successful
the solutions already written in <K>HeLP_sol</K> are kept, otherwise this variable is reset.
For a more detailed account see Sections <Ref Sect='Chapter_Extended_examples_Section_The_behavior_of_the_variable_HeLP_sol'/>,
<Ref Sect='Chapter_Background_Section_Partial_augmentations_and_the_structure_of_HeLP_sol'/> and <Ref Func='HeLP_ChangeCharKeepSols'/>.
In most situations, the user does not have to worry about this, the program will
take care of it as far as possible. <K>HeLP_settings</K> is a varaible which is used to store some settings of the program.
<Section Label="Chapter_Further_functions_Section_Checks_for_specific_orders">
<Heading>Checks for specific orders</Heading>

<ManSection>
  <Func Arg="CharacterTable|ListOfClassFunctions ord" Name="HeLP_WithGivenOrder" />
 <Returns>List of admissible partial augmentations
</Returns>
 <Description>
Calculates the admissible partial augmentations for elements of
order <A>ord</A> using only the data given in the first argument.
The first argument can be an ordinary
character table, a Brauer table, or a list of class functions, all having
the same underlying character table.
This function only uses the constraints of the HeLP method (from the class functions given), but does not apply
the Wagner test <Ref Sect='Chapter_Background_Section_The_Wagner_test'/>.
If the constraints allow only a finite number of solutions, these lists will
be written in <K>HeLP_sol[ord]</K>.
If for divisors <M>d</M> of <A>ord</A> solutions are already calculated and
stored in <K>HeLP_sol[d]</K>, these will be used, otherwise the function <K>HeLP_WithGivenOrder</K>
will first be applied to this order and the data given in the first argument.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("A5");
CharacterTable( "A5" )
gap> HeLP_WithGivenOrder(C, 5);
#I  Number of solutions for elements of order 5: 2; stored in HeLP_sol[5].
[ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
gap> HeLP_PrintSolution(5);
Solutions for elements of order 5:
[ [               u ],.
  [  [ "5a", "5b" ] ],
  [             --- ],
  [        [ 0, 1 ] ],
  [        [ 1, 0 ] ] ]
]]></Example>


Tests which partial augmentations for elements of order 5 are admissible.
<Example><![CDATA[
gap> C := CharacterTable("A6");
CharacterTable( "A6" )
gap> HeLP_WithGivenOrder(C, 4);
#I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
[ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
  [ [ 1 ], [ 0, 1 ] ] ]
gap> HeLP_sol[4];              
[ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
  [ [ 1 ], [ 0, 1 ] ] ]
]]></Example>


Two of the non-trivial partial augmentations can be eliminated by using the
Brauer table modulo the prime <Math>3</Math>:
<Example><![CDATA[
gap> HeLP_WithGivenOrder(C mod 3, 4);                                                                    
#I  Number of solutions for elements of order 4: 2; stored in HeLP_sol[4].
[ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
]]></Example>


When using <K>HeLP_ZC</K> also the last remaining non-trivial partial augmentation disappears,
as this function applies the Wagner test, cf. <Ref Sect='Chapter_Background_Section_The_Wagner_test'/> and <Ref Func='HeLP_WagnerTest'/>:
<Example><![CDATA[
gap> HeLP_ZC(C);               
#I  ZC can't be solved, using the given data, for the orders: [ 6 ].
false
gap> HeLP_sol[4]; HeLP_sol[6];
[ [ [ 1 ], [ 0, 1 ] ] ]
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
]]></Example>


The following example demonstrates how one can use lists of characters to
obtain constraints for partial augmentations:
<Example><![CDATA[
gap> C := CharacterTable("L2(49).2_1");   
CharacterTable( "L2(49).2_1" )
gap> HeLP_WithGivenOrder(Irr(C), 7);;
#I  Number of solutions for elements of order 7: 1; stored in HeLP_sol[7].
gap> HeLP_WithGivenOrder(Irr(C){[2]}, 14);
#I  The given data admit infinitely many solutions for elements of order 14.
gap> HeLP_WithGivenOrder(Irr(C){[44]}, 14);
#I  The given data admit infinitely many solutions for elements of order 14.
gap> HeLP_WithGivenOrder(Irr(C){[2,44]}, 14);
#I  Number of solutions for elements of order 14: 0; stored in HeLP_sol[14].
[  ]
]]></Example>


Brauer tables can provide more restrictions on partial augmentations of certain torsion units:
<Example><![CDATA[
gap> C := CharacterTable("J1");       
CharacterTable( "J1" )
gap> HeLP_WithGivenOrder(C, 6);;
#I  Number of solutions for elements of order 6: 73; stored in HeLP_sol[6].
gap> B := C mod 11;
BrauerTable( "J1", 11 )
gap> HeLP_WithGivenOrder(B, 6);;       
#I  Number of solutions for elements of order 6: 6; stored in HeLP_sol[6].
gap> HeLP_WithGivenOrder(Irr(B){[2,3]}, 6);;
#I  Number of solutions for elements of order 6: 6; stored in HeLP_sol[6].
gap> HeLP_PrintSolution(6);
Solutions for elements of order 6:
[ [                   u^3,                   u^2,                     u ],
  [              [ "2a" ],              [ "3a" ],  [ "2a", "3a", "6a" ] ],
  [                   ---,                   ---,                   --- ],
  [                 [ 1 ],                 [ 1 ],          [ -2, 0, 3 ] ],
  [                 [ 1 ],                 [ 1 ],          [ 2, 0, -1 ] ],
  [                 [ 1 ],                 [ 1 ],           [ 0, 0, 1 ] ],
  [                 [ 1 ],                 [ 1 ],          [ -4, 3, 2 ] ],
  [                 [ 1 ],                 [ 1 ],          [ 0, 3, -2 ] ],
  [                 [ 1 ],                 [ 1 ],          [ -2, 3, 0 ] ] ]
]]></Example>


The result of the previous example can be found in <Cite Key="BJK"/>. <P/>
When dealing with many variables using lists of characters instead of a complete character table might also speed up the calculations a lot,
see Section <Ref Sect='Chapter_Extended_examples_Section_Saving_time'/>.
<Example><![CDATA[
gap> C := CharacterTable("L2(27)");
CharacterTable( "L2(27)" )
gap> HeLP_WithGivenOrder(C,7);;
#I  Number of solutions for elements of order 7: 78; stored in HeLP_sol[7].
gap> SetInfoLevel(HeLP_Info,4);
gap> HeLP_WithGivenOrder(C,3*7); 
#I      Solutions for order 3 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 21: 0; stored in HeLP_sol[21].  
[  ]
gap> SetInfoLevel(HeLP_Info,1);
]]></Example>


<K>HeLP_WithGivenOrder</K> often needs to consider many cases. Set the info class HeLP_Info to a level 4 or higher to keep track
of the progress, see Section <Ref Sect='Chapter_Extended_examples_Section_Using_InfoLevels'/> on info levels.

<ManSection>
  <Func Arg="CharacterTable|ListOfClassFunctions ord partaugs" Name="HeLP_WithGivenOrderAndPA" />
 <Returns>List of admissible partial augmentations
</Returns>
 <Description>
Calculates the admissible partial augmentations for elements of
order <A>ord</A> using only the data given in the first argument.
The first argument can be an ordinary
character table, a Brauer table, or a list of class functions, all having
the same underlying character table.
The function uses the partial augmentations for the powers <M>u^d</M> with <M>d</M>
divisors of <M>k</M> different from <M>1</M> and <M>k</M> given in <A>partaugs</A>.
Here, the <M>d</M>'s have to be in a descending order (i.e. the orders of the <Math>u^d</Math>'s
are ascending).
This function only uses the constraints of the HeLP method, but does not apply
the Wagner test <Ref Sect='Chapter_Background_Section_The_Wagner_test'/>.
Note that this function will not affect <K>HeLP_sol</K>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := SmallGroup(48,33);; StructureDescription(G);
"SL(2,3) : C2"
gap> C := CharacterTable(G);;
gap> HeLP_WithGivenOrder(C, 4);;
#I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
gap> HeLP_WithGivenOrder(C, 6);;
#I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
gap> HeLP_sol[4]; HeLP_sol[6];
[ [ [ 1, 0 ], [ 0, 1, 0, 0, 0 ] ], [ [ 1, 0 ], [ 0, 0, 0, 0, 1 ] ], 
  [ [ 1, 0 ], [ 0, 0, 0, 1, 0 ] ], [ [ 1, 0 ], [ 0, 0, 1, 0, 0 ] ] ]
[ [ [ 1, 0 ], [ 0, 1 ], [ 0, 0, 0, 0, 1, 0 ] ], 
  [ [ 1, 0 ], [ 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ] ]
gap> HeLP_WithGivenOrderAndPA(C, 12, [ [ 1, 0 ],  [ 0, 1 ], [ 0, 0, 0, 0, 1 ],
>     [ 0, 0, 0, 0, 1, 0 ] ]); 
#I  Number of solutions for elements of order 12 with these partial augmentation
s for the powers: 1.
[ [ [ 1, 0 ], [ 0, 1 ], [ 0, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1, 0 ], 
      [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ] ] ]
gap> HeLP_WithGivenOrderAndPA(C, 12, [ [ 1, 0 ],  [ 0, 1 ], [ 0, 0, 0, 1, 0 ],
>     [ 0, 0, 0, 0, 1, 0 ] ]);
#I  Number of solutions for elements of order 12 with these partial augmentation
s for the powers: 0.
[  ]
]]></Example>


In the calls of <K>HeLP_WithGivenOrderAndPA</K> the function uses the following partial augmentations:
<List>
<Item>
<K>[ 1, 0 ]</K> for the element <M>u^6</M> of order 2,
</Item>
<Item>
<K>[ 0, 1 ]</K> for the element <M>u^4</M> of order 3,
</Item>
<Item>
<K>[ 0, 0, 0, 0, 1 ]</K> and <K>[ 0, 0, 0, 1, 0 ]</K> for the element <M>u^3</M> of order 4 respectively,
</Item>
<Item>
<K>[ 0, 0, 0, 0, 1, 0 ]</K> for the element <M>u^2</M> of order 6.
</Item>
</List>

<ManSection>
  <Func Arg="list ord partaugs [b]" Name="HeLP_WithGivenOrderAndPAAndSpecificSystem" />
 <Returns>List of admissible partial augmentations
</Returns>
 <Description>
Calculates the admissible partial augmentations for elements of
order <A>ord</A> using only the data given in the first argument.
The first argument is a list, which can contains as entries characters or pairs with first entry a character
and second entrie an integer or a mixture of these.
The first argument is understood as follows: If a character <M>\chi</M> is not given in a pair all
inequalities obtainable by this character are used. If it is given in a pair with the integer <M>m</M>
the inequalities obtainable from the multiplicity of <K>E(ord)</K> taken to the power <M>m</M>
as an eigenvalue of a representation affording <M>\chi</M> are used.
The function uses the partial augmentations for the powers <M>u^d</M> with <M>d</M>
divisors of <M>k</M> different from <M>1</M> and <M>k</M> given in <A>partaugs</A>.
Here, the <M>d</M>'s have to be in a descending order (i.e. the orders of the <Math>u^d</Math>'s
are ascending).
This function only uses the constraints of the HeLP method, but does not apply
the Wagner test <Ref Sect='Chapter_Background_Section_The_Wagner_test'/>.
Note that this function will not affect <K>HeLP_sol</K>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("A5");
CharacterTable( "A5" )
gap> chi := Irr(C)[2];; psi := Irr(C)[4];
Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] )
gap> HeLP_WithGivenOrderAndPAAndSpecificSystem([[chi, 1], [chi, 2]],
>  5, [ ], true);
[ [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ], [ [ -3/5, 2/5 ], [ 2/5, -3/5 ] ], [ 3/5, 3/5 ] ]
gap> sol5 := HeLP_WithGivenOrderAndPAAndSpecificSystem([[chi, 1], [chi, 2]], 
>  5, [ ]);      
[ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
]]></Example>


The inequalities in the above examples are:
<Display>\frac{-3}{5}\varepsilon_{5a}(u) + \frac{2}{5}\varepsilon_{5b}(u) + \frac{3}{5} \in \mathbb{Z}_{\geq 0} \ \ {\rm{and}} \ \ \frac{2}{5}\varepsilon_{5a}(u) + \frac{-3}{5}\varepsilon_{5b}(u) + \frac{3}{5} \in \mathbb{Z}_{\geq 0}. </Display>
Continuing the above example:
<Example><![CDATA[
gap> HeLP_WithGivenOrderAndPAAndSpecificSystem([psi], 
>  2*5, [[1], sol5[1][1]], true);     
[ [  ], [ [ 0, -2/5, -2/5 ], [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ],
 [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ], [ 0, 2/5, 2/5 ], 
 [ 0, 1/10, 1/10 ], [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ], 
[ 0, -1/10, -1/10 ] ], [ 0, 1/2, 1/2, 1/2, 1/2, 0, 1/2, 1/2, 1/2, 1/2 ] ]
gap> HeLP_WithGivenOrderAndPAAndSpecificSystem([[psi, 0], [psi, 2], [psi, 5]], 
>  2*5, [[1], sol5[2][1]], true); 
[ [  ], [ [ 0, -2/5, -2/5 ], [ 0, 1/10, 1/10 ], [ 0, 2/5, 2/5 ] ], [ 0, 1/2, 0 ] ]
]]></Example>



</Section>


<Section Label="Chapter_Further_functions_Section_Checks_for_specific_orders_with_s-constant_characters">
<Heading>Checks for specific orders with s-constant characters</Heading>

When considering elements of order <Math>st</Math> (in absence of elements of this order in the group
; in particular when trying to prove (PQ)) and there are several conjugacy classes of
elements of order <Math>s</Math>, it might be useful to consider <Math>s</Math>-constant characters
(cf. Section <Ref Sect='Chapter_Background_Section_s-constant_(and_(s,t)-constant)_characters'/>)
to reduce the computational complexity.
<ManSection>
  <Func Arg="CharacterTable|ListOfClassFunctions s t" Name="HeLP_WithGivenOrderSConstant" />
 <Returns>List of admissible "partial augmentations" or <K>"infinite"</K>
</Returns>
 <Description>
Calculates the admissible partial augmentations for elements <M>u</M> of
order <M>s*t</M> using only the <Math>s</Math>-constant class functions that are contained in the first argument.
The first argument can be an ordinary
character table, a Brauer table, or a list of class functions, all having
the same underlying character table.
<A>s</A> and <A>t</A> have to be different prime numbers, such that there are elements of order <A>s</A>
and <A>t</A> in the group, but no elements of order <M>s*t</M>. <P/>
The function filters which class functions given in the first argument are constant on all conjugacy classes
of elements of order <A>s</A>. For the element <M>u^s</M> of order <A>t</A> the partial augmentations
given in <K>HeLP_sol[t]</K> are used. If they are not yet calculated, the function calculates them first,
using the data given in the first argument and stores them in <K>HeLP_sol[t]</K>.
This function only uses the constraints of the HeLP method, but does not apply
the Wagner test <Ref Sect='Chapter_Background_Section_The_Wagner_test'/>.
If these calculations allow an infinite number of solutions of elements of order <Math>st</Math> the function returns
<K>"infinite"</K>, otherwiese it returns the finite list of solutions for elements of order <M>s*t</M>.
The first entry of every solution is a list of the partial augmentations of <M>u^s</M> and the second entry is a list of the
"partial augmentations" for <M>u</M>: the first entry of this list is the sum of the partial augmentations
on all classes of elements of order <A>s</A> and the other entries are the partial augmentations on the
classes of order <A>t</A>.
Only in the case that the existence of units of order <Math>s*t</Math> can be excluded by this function the variable
<K>HeLP_sol[s*t]</K> will be affected and <K>HeLP_sol[s*t]</K> will be set to <K>[ ]</K>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("A6");;
gap> HeLP_WithGivenOrder(C, 6);            
#I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
gap> HeLP_WithGivenOrderSConstant(C, 2, 3);
[ [ [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1, 0 ], [ -2, 1, 2 ] ] ]
gap> HeLP_WithGivenOrderSConstant(C, 3, 2);     
[ [ [ 1 ], [ 3, -2 ] ] ]
]]></Example>


<Example><![CDATA[
gap> C := CharacterTable("Sz(8)");;
gap> SetInfoLevel(HeLP_Info, 4);
gap> HeLP_WithGivenOrderSConstant(C, 7, 13);
#I    Partial augmentations for elements of order 13 not yet calculated.  Restar
t for this order.
#I    Number of non-trivial 7-constant characters in the list: 7.
[  ]
gap> SetInfoLevel(HeLP_Info, 1);
]]></Example>


The last example can also be checked by using all characters in <K>C</K>, but this takes notably longer.
<Example><![CDATA[
gap> C := CharacterTable("Sz(32)");
CharacterTable( "Sz(32)" )
gap> L := Filtered(OrdersClassRepresentatives(C), x-> x = 31);; Size(L);
15           # I.e. HeLP_WithGivenOrder(C,31) would take hopelessly long
gap> HeLP_WithGivenOrderSConstant(C mod 2, 31, 5);
[  ]
gap> IsBound(HeLP_sol[31]);
false 
]]></Example>


We still have no clue about elements of order 31, but there are none of order 5*31.

<ManSection>
  <Func Arg="CT" Name="HeLP_AddGaloisCharacterSums" />
 <Returns>List of characters
</Returns>
 <Description>
Given an ordinary character table <A>CT</A> the function calculates the orbits under the action of the Galois group
and returns a list of characters containing the ones contained in <A>CT</A> and the ones obtained by summing
up the Galois-orbits.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Further_functions_Section_Checks_for_all_orders">
<Heading>Checks for all orders</Heading>

<ManSection>
  <Func Arg="CharacterTable|Group" Name="HeLP_AllOrders" />
 <Returns><K>true</K> if (ZC) can be solved using the given data, <K>false</K> otherwise
</Returns>
 <Description>
This function does almost the same as <Ref Func='HeLP_ZC'/>. It checks whether the Zassenhaus
Conjecture can be verified for a group, but does not compute the partial augmentations
of elements of order <Math>k</Math>, if <K>HeLP_sol[k]</K> already exists. It does however verify the solutions
given in <K>HeLP_sol</K> using all available tables for the group, see <Ref Func='HeLP_VerifySolution'/>.
Thus some precalculations using e.g. <Ref Func='HeLP_WithGivenOrder'/> are respected.
In contrast to <Ref Func='HeLP_ZC'/>
this function also does not check whether the group is nilpotent to use the Weiss-result to have an
immediate positive solution for (ZC). <P/>
This function is interesting
if one wants to save time or possesses some information, which was not obtained using this package and was
entered manually into <K>HeLP_sol</K>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable(PSL(2,7));         
CharacterTable( Group([ (3,7,5)(4,8,6), (1,2,6)(3,4,8) ]) )
gap> HeLP_ZC(C);        
#I  The Brauer tables for the following primes are not available: [ 2, 3, 7 ].
#I  (ZC) can't be solved, using the given data, for the orders: [ 6 ].
false
gap> HeLP_sol[6] := [ ];
[  ]
gap> HeLP_AllOrders(C);
true
]]></Example>



<ManSection>
  <Func Arg="CharacterTable|Group" Name="HeLP_AllOrdersPQ" />
 <Returns><K>true</K> if (PQ) can be solved using the given data, <K>false</K> otherwise
</Returns>
 <Description>
This function does almost the same as <Ref Func='HeLP_PQ'/>. It checks whether the Prime Graph
Question can be verified for a group, but does not compute the partial augmentations
of elements of order <Math>k</Math>, if <K>HeLP_sol[k]</K> already exists. Thus some precalculations using
e.g. <Ref Func='HeLP_WithGivenOrder'/> are respected. In contrast to <Ref Func='HeLP_PQ'/>
this function also does not check whether the group is solvable to use the Kimmerle-result to have an
immediate positive solution for (ZC). <P/>
This function is interesting if one wants to save time or possesses some information, which was
not obtained using this package and was entered manually into <K>HeLP_sol</K>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("A12");
CharacterTable( "A12" )
gap> HeLP_WithGivenOrder(Irr(C){[2, 4, 7]}, 2);;
#I  Number of solutions for elements of order 2: 37; stored in HeLP_sol[2].
gap> HeLP_WithGivenOrderSConstant(C mod 3,11,2);
[  ]
gap> HeLP_WithGivenOrder(Irr(C mod 2){[2, 3, 4, 6]}, 3);;
#I  Number of solutions for elements of order 3: 99; stored in HeLP_sol[3].
gap> HeLP_WithGivenOrderSConstant(C mod 2, 11, 3);
[  ]
gap> HeLP_AllOrdersPQ(C);
true
]]></Example>


Thus the Prime Graph Question holds for the alternating group of degree 12.
Just using <K>HeLP_PQ(C)</K> would take hopelessly long.

</Section>


<Section Label="Chapter_Further_functions_Section_Changing_the_used_Character_Table">
<Heading>Changing the used Character Table</Heading>

<ManSection>
  <Func Arg="CT" Name="HeLP_ChangeCharKeepSols" />
 <Returns>nothing
</Returns>
 <Description>
This function changes the used character table to the character table <A>CT</A> and keeps
all the solutions calculated so far. It is in this case the responsibility of the user that the
tables belong to the same group and the ordering of the conjugacy classes in <A>CT</A> is consistent with
the one in the previously used table. This function can be used to change from one table
of the group to another, e.g. from a Brauer table to the ordinary table if the calculations will
involve <Math>p</Math>-singular elements.
(In case the involved character tables come from the ATLAS and their InfoText begins with "origin: ATLAS of finite groups",
this is done automatically by the program.)
A user may also use characters, which are normally not accessible in GAP.
 </Description>
</ManSection>


To keep track of the change of the character tables one can set HeLP_Info to level 5.
In this first example it is not realized that the character tables belong to the same group, so the
solutions for elements of order 2 are recalculated (they have been reset, as another character table
is used).
<Example><![CDATA[
gap> SetInfoLevel(HeLP_Info, 5);
gap> C := CharacterTable(SymmetricGroup(4)); 
CharacterTable( Sym( [ 1 .. 4 ] ) )
gap> HeLP_WithGivenOrder(C mod 2, 3); 
#I  USED CHARACTER TABLE CHANGED TO BrauerTable( SymmetricGroup( [ 1 .. 4 ] ), 2
 ), ALL GLOBAL VARIABLES RESET.
#I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
[ [ [ 1 ] ] ]
gap> HeLP_WithGivenOrder(C, 2*3);    
#I  USED CHARACTER TABLE CHANGED TO CharacterTable( SymmetricGroup( [ 1 .. 4 ] )
 ), ALL GLOBAL VARIABLES RESET.
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I      Solutions for order 3 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 6: 0; stored in HeLP_sol[6].
[  ]
]]></Example>


The recalculations of the solutions can be avoided by calling <K>HeLP_ChangeCharKeepSols</K>
before using another character table.
<Example><![CDATA[
gap> D := CharacterTable(SymmetricGroup(4));
CharacterTable( Sym( [ 1 .. 4 ] ) )
gap> HeLP_WithGivenOrder(D mod 2, 3);       
#I  USED CHARACTER TABLE CHANGED TO BrauerTable( SymmetricGroup( [ 1 .. 4 ] ), 2
 ), ALL GLOBAL VARIABLES RESET.
#I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
[ [ [ 1 ] ] ]
gap> HeLP_ChangeCharKeepSols(D);
#I  WARNING: Change used character table without checking if the character table
s have the same underlying groups and the ordering of the conjugacy classes are 
the same!
gap> HeLP_WithGivenOrder(D, 2*3);    
#I  Using same character table as until now; all known solutions kept.
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 6: 0; stored in HeLP_sol[6].
[  ]
]]></Example>


When using tables from the ATLAS this is done automatically:
<Example><![CDATA[
gap> CA := CharacterTable("A5");
CharacterTable( "A5" )
gap> HeLP_WithGivenOrder(CA mod 2, 5);
#I  USED CHARACTER TABLE CHANGED TO BrauerTable( "A5", 2 ), ALL GLOBAL VARIABLES
 RESET.
#I  Testing possibility 1 out of 1.
#I  Number of solutions for elements of order 5: 2; stored in HeLP_sol[5].
[ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
gap> HeLP_WithGivenOrder(CA, 2*5);    
#I  Using character table of the same group; all known solutions kept.
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 10: 0; stored in HeLP_sol[10].
[  ]
gap> SetInfoLevel(HeLP_Info, 1);
]]></Example>



<ManSection>
  <Func Arg="" Name="HeLP_Reset" />
 <Returns>nothing
</Returns>
 <Description>
This function delets all the values calculated so far and resets the global variables <K>HeLP_CT</K>
and <K>HeLP_CT</K> to their initial value <K>[ [ [1] ] ]</K> and <K>CharacterTable(SmallGroup(1,1))</K>
respectively.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Further_functions_Section_Influencing_how_the_Systems_of_Inequalities_are_solved">
<Heading>Influencing how the Systems of Inequalities are solved</Heading>

HeLP uses currently three external programs (i.e. programs that are not part of the GAP-system):
zsolve from 4ti2 and/or normaliz to solve the systems of linear inequalities and redund from lrslib to simplify the
inequlities before handing them over to the solver (HeLP can also be used without lrslib installed. In
general it is recommanded to have lrslib installed, if 4ti2 is used as the solver). The following functions can be used to influence
the behaviour of these external programms.
<ManSection>
  <Func Arg="[string]" Name="HeLP_Solver" />
 <Returns>nothing
</Returns>
 <Description>
This function can be used to change the solver used for the HeLP-system between 4ti2 and normaliz.
If the function is called without an argument it prints which solver is currently used.
If the argument it is called with is one of the stings "4ti2" or "normaliz", then the solver used
for future calculations is changed to the one given as argument in case this solver is found by the HeLP-package.
If both solvers are found when the package is loaded normaliz is taken as default.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="bool" Name="HeLP_UseRedund" />
 <Returns>nothing
</Returns>
 <Description>
This function determines whether HeLP uses 'redund' from the lrslib-package to remove redundant
equations from the HeLP system. If <A>bool</A> is <K>true</K> 'redund' will be used in all calculation that follow,
if it is <K>false</K>, 'redund' will not be used (which might take significantly longer).
If 'redund' was not found by GAP a warning will be
printed and the calculations will be performed without 'redund'.
As default 'redund' will be used in all calculations, if 4ti2 is the chosen solver, and 'redund' will not be used, if normaliz is used.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="string" Name="HeLP_Change4ti2Precision" />
 <Returns>nothing
</Returns>
 <Description>
This function changes the maximum precision of the calculations of 4ti2 to solve the occurring systems of
linear inequalities. The possible arguments are <K>"32"</K>, <K>"64"</K> and <K>"gmp"</K>. After calling the function
the new precision will be used until this function is used again. The default value is <K>"32"</K>.
A higher precision causes slower calculations.
But this function might be used to increase the precision of 4ti2, when one gets an error message like
"Error, 4ti2 Error:
Results were near maximum precision (32bit).
Please restart with higher precision!"
stating that the results were close to the maximum 4ti2-precision.
normaliz does automatically change its precision, when it reaches an overflow.
 </Description>
</ManSection>


Sometimes it is desirable to perform calculations without redund (even if it is
installed and in many cases improves the performance of the package) or with a higher
precision.
For example, determining the partial augmentations for units of order <Math>14</Math> for
<K>SmallGroup(392, 30)</K> involves very long calculations (when called with redund and precision 32)
or cause errors (when called without redund and precision 32). However, the following works in a
reasonable time.
<Example><![CDATA[
gap> C := CharacterTable(SmallGroup(392,30));
CharacterTable( <pc group of size 392 with 5 generators> )
gap> HeLP_Solver("4ti2");
'4ti2' will be used from now on.
gap> HeLP_UseRedund(false);
The calculations will be performed without using 'redund' from now on.
gap> HeLP_ZC(C);
Error, 4ti2 Error:
Results were near maximum precision (32bit).
Please restart with higher precision!
If you continue, your results might be wrong called from
4ti2Interface_zsolve_equalities_and_inequalities( 
 [ ListWithIdenticalEntries( Size( T[1] ), 1 ) ], [ 1 ], temp[1], - temp[2] 
 ) called from
HeLP_TestSystemINTERNAL( W[1], W[2], k, arg[3] ) called from
HeLP_WithGivenOrderAndPAINTERNAL( C, k, pa ) called from
HeLP_WithGivenOrderINTERNAL( Irr( T ), k ) called from
<function "HeLP_ZC">( <arguments> )
 called from read-eval loop at line 19 of *stdin*
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
gap> brk> quit;
#I  Options stack has been reset
gap> HeLP_Change4ti2Precision("64");
The calculations of 4ti2 will be performed with precision 64 from now on.
gap> HeLP_ZC(C);
true
]]></Example>



<ManSection>
  <Func Arg="string" Name="HeLP_Vertices" />
 <Returns>nothing
</Returns>
 <Description>
If normlaiz is used as the solver of the HeLP-system this function influences, whether the "VerticesOfPolyhedron"
are computed by normaliz. By default these are only computed, if the system has a trivial solution.
The function takes "vertices", "novertices" and "default" as arguments. If you do not understand what this means, don't worry.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Further_functions_Section_Checking_solutions,_calculating_and_checking_solutions">
<Heading>Checking solutions, calculating and checking solutions</Heading>

<ManSection>
  <Func Arg="CharacterTable|ListOfClassFunctions k [list_paraugs]" Name="HeLP_VerifySolution" />
 <Returns>List of admissible partial augmentations
</Returns>
 <Description>
This function checks which of the partial augmentations for elements of order <K>k</K> given
in <K>HeLP_sol[k]</K> or the optional third argument <K>list_paraugs</K>
fulfill the HeLP equations obtained from the characters in the first argument.
This function does not solve any inequalities, but only checks, if the
given partial augmentations fulfill them. It is for this reason often faster then
e.g. <Ref Func='HeLP_WithGivenOrder'/>.<P/>
If there is no third argument given, i.e. the augmentations from <K>HeLP_sol[k]</K> are used,
the result overwrites <K>HeLP_sol[k]</K>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("A6");;
gap> HeLP_WithGivenOrder(C, 4);
#I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
[ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
  [ [ 1 ], [ 0, 1 ] ] ]
gap> HeLP_VerifySolution(C mod 3, 4);
[ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
gap> HeLP_sol[4];
[ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
]]></Example>


<Example><![CDATA[
gap> C := CharacterTable("S12");;
gap> HeLP_WithGivenOrder(Irr(C mod 5){[2..6]}, 2);;
#I  Number of solutions for elements of order 2: 563; stored in HeLP_sol[2].
gap> HeLP_VerifySolution(C mod 5, 2);;
gap> Size(HeLP_sol[2]);
387
gap> HeLP_VerifySolution(C mod 3, 2);;
gap> Size(HeLP_sol[2]);
324
]]></Example>


Using <K>HeLP_WithGivenOrder(C mod 5, 2)</K> or <K>HeLP_WithGivenOrder(C mod 3, 2)</K> takes much longer
since in that case a bigger system of inequalities must be solved.

<ManSection>
  <Func Arg="CharacterTable|ListOfClassFunctions k" Name="HeLP_FindAndVerifySolution" />
 <Returns>List of admissible partial augmentations or "infinite"
</Returns>
 <Description>
This function provides the same functionality as <Ref Func='HeLP_WithGivenOrder'/> but
instead of constructiong the corresponding system with all characters from the first argument
<A>CharacterTable|ListOfClassFunctions</A> it does it consecutively with larger sets of characters
from the argument until a finite list of solutions is found and then applies <Ref Func='HeLP_VerifySolution'/>
to these solutions with the entirety of the class functions in the first argument.<P/>
This function is sometimes faster than <Ref Func='HeLP_WithGivenOrder'/>, but the output is the same,
thus the examples from <Ref Func='HeLP_WithGivenOrder'/> also apply here.
 </Description>
</ManSection>



<ManSection>
  <Func Arg="n" Name="HeLP_PossiblePartialAugmentationsOfPowers" />
 <Returns>List of partial augmentations of powers.
</Returns>
 <Description>
This function provides the possible partial augmentations of the powers of units of a given order <Math>n,</Math>
if the partial augmentations if units of order <Math>n/p</Math> have been already computed for all primes <Math>p</Math>
dividing <Math>n.</Math> The possibilities are sorted in the same way as, if the order <Math>n</Math> is checked with any other
function like e.g. <Ref Func='HeLP_WithGivenOrder'/> or <Ref Func='HeLP_ZC'/>. Thus, if the InfoLevel is
high enough and one obtains that the computation of some possibility is taking too long, one can check it
using <Ref Func='HeLP_WithGivenOrderAndPA'/>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SetInfoLevel(HeLP_Info,4);
gap> C := CharacterTable(SmallGroup(160,91));
CharacterTable( <pc group of size 160 with 6 generators> )
gap> HeLP_WithGivenOrder(C,4);;
#I      Solutions for order 2 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 4: 22; stored in HeLP_sol[4].   
gap> HeLP_WithGivenOrder(C,10);;
#I      Solutions for order 5 not yet calculated.  Restart for this order.
#I  Number of solutions for elements of order 10: 6; stored in HeLP_sol[10].  
gap> LP := HeLP_PossiblePartialAugmentationsOfPowers(20);;
gap> HeLP_WithGivenOrderAndPA(Irr(C){[2..20]},20,LP[1]);
#I  Number of solutions for elements of order 20 with these partial augmentations
 for the powers: 0.
[  ]
]]></Example>



</Section>


<Section Label="Chapter_Further_functions_Section_The_Wagner_test">
<Heading>The Wagner test</Heading>

<ManSection>
  <Func Arg="k [list_paraugs, OrdinaryCharacterTable]" Name="HeLP_WagnerTest" />
 <Returns>List of admissible partial augmentations
</Returns>
 <Description>
This function applies the Wagner test (cf. Section <Ref Sect='Chapter_Background_Section_The_Wagner_test'/>) to the given data.
If only the order <A>k</A> is given as argument,
the Wagner test will be applied to the solutions stored in <K>HeLP_sol[k]</K>.
If the arguments are the order <A>k</A>, a list of possible solutions <A>list_paraugs</A> and an ordinary character table
<A>OrdinaryCharacterTable</A> it applies the test to the solutions given in <A>list_paraugs</A> and using the number of conjugacy classes
for elements a divisor of <A>k</A>, which will be extracted from the head of <A>OrdinaryCharacterTable</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("M11");
CharacterTable( "M11" )
gap> HeLP_WithGivenOrder(C,8);;
#I  Number of solutions for elements of order 8: 36; stored in HeLP_sol[8].
gap> HeLP_sol[8] := HeLP_WagnerTest(8);;
gap> Size(HeLP_sol[8]);
24
]]></Example>


Thus the Wagner-Test eliminates 12 possible partial augmentations for elements of order 8.
Continuing the example:
<Example><![CDATA[
gap> HeLP_WithGivenOrder(C,12);
#I  Number of solutions for elements of order 12: 7; stored in HeLP_sol[12].
[ [ [ 1 ], [ 1 ], [ 2, -1 ], [ 0, 3, -2 ], [ 1, 0, -1, 1 ] ], 
  [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, 3, -2 ], [ 0, 0, 0, 1 ] ], 
  [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, 3, -2 ], [ 0, 0, 2, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ 1, 0, 1, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ -1, 0, 1, 1 ] ], 
  [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, -3, 4 ], [ 0, 0, 0, 1 ] ], 
  [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, -3, 4 ], [ 1, 0, -1, 1 ] ] ]
gap> HeLP_sol[12] := HeLP_WagnerTest(12);
[ [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, 3, -2 ], [ 0, 0, 0, 1 ] ], 
  [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, 3, -2 ], [ 0, 0, 2, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, -3, 4 ], [ 0, 0, 0, 1 ] ] ]
gap> HeLP_sol[4] := HeLP_WagnerTest(4);;
gap> HeLP_WithGivenOrder(C,12);
#I  Number of solutions for elements of order 12: 3; stored in HeLP_sol[12].
[ [ [ 1 ], [ 1 ], [ 2, -1 ], [ 0, 3, -2 ], [ 1, 0, -1, 1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ 1, 0, 1, -1 ] ], 
  [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ -1, 0, 1, 1 ] ] ]
gap> HeLP_sol[12] := HeLP_WagnerTest(12);
[  ]
]]></Example>


Thus there are no normalized units of order 12 in the integral group ring of <Math>M_{11}.</Math>
<Example><![CDATA[
gap> C := CharacterTable("M22");
CharacterTable( "M22" )
gap> HeLP_WagnerTest(12, [ [ [1], [1], [1,0], [0,0,1], [-3,3,2,3,-4] ] ],C);
[  ]
]]></Example>


This example is taken from the appendix of <Cite Key="KonovalovM22"/>.<P/>
Sometimes the Wagner-Test may even prove the Zassenhaus Conjecture:
<Example><![CDATA[
gap> G := SmallGroup(96,187);
<pc group of size 96 with 6 generators>
gap> C := CharacterTable(G);
CharacterTable( <pc group of size 96 with 6 generators> )
gap> HeLP_WithGivenOrder(C,4);;
#I  Number of solutions for elements of order 4: 34; stored in HeLP_sol[4].
gap> HeLP_WagnerTest(4);       
[ [ [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 1 ] ],
  [ [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 1, 0, 0 ] ],
  [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0, 0, 0 ] ], 
  [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 1, 0 ] ] ]
gap> HeLP_ZC(C);
true
]]></Example>



</Section>


<Section Label="Chapter_Further_functions_Section_Output">
<Heading>Output</Heading>

<ManSection>
  <Func Arg="[k]" Name="HeLP_PrintSolution" />
 <Returns>nothing
</Returns>
 <Description>
This function prints the possible solutions in a pretty way. If a positive integer <A>k</A> as argument is given, then it prints the
admissible partial augmentations of units of order <A>k</A>, if they are already calculated. If no argument is given, the
function prints information on all orders for which there are already informations.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("A5");;
gap> HeLP_ZC(C);          
true
gap> HeLP_PrintSolution();
Solutions for elements of order 2:
[ [         u ],
  [  [ "2a" ] ],
  [       --- ],
  [     [ 1 ] ] ]
Solutions for elements of order 3:
[ [         u ],
  [  [ "3a" ] ],
  [       --- ],
  [     [ 1 ] ] ]
Solutions for elements of order 5:
[ [               u ],
  [  [ "5a", "5b" ] ],
  [             --- ],
  [        [ 0, 1 ] ],
  [        [ 1, 0 ] ] ]
There are no admissible partial augmentations for elements of order 6.
There are no admissible partial augmentations for elements of order 10.
There are no admissible partial augmentations for elements of order 15.
There are no admissible partial augmentations for elements of order 30.
gap> C := CharacterTable("A6");;
gap> HeLP_ZC(C);           
#I  ZC can't be solved, using the given data, for the orders: [ 6 ].
false
gap> HeLP_PrintSolution(6);
Solutions for elements of order 6:
[ [                   u^3,                   u^2,                     u ],
  [              [ "2a" ],        [ "3a", "3b" ],  [ "2a", "3a", "3b" ] ],
  [                   ---,                   ---,                   --- ],
  [                 [ 1 ],              [ 0, 1 ],          [ -2, 2, 1 ] ],
  [                 [ 1 ],              [ 1, 0 ],          [ -2, 1, 2 ] ] ]
]]></Example>



</Section>


<Section Label="Chapter_Further_functions_Section_Eigenvalue_multiplicities_and_character_values">
<Heading>Eigenvalue multiplicities and character values</Heading>

<ManSection>
  <Func Arg="chi, k, paraugs" Name="HeLP_MultiplicitiesOfEigenvalues" />
 <Returns>a list of multiplicities of eigenvalues
</Returns>
 <Description>
The returned list contains at the <M>l</M>-th spot the multiplicity of <K>E(k)^(l-1)</K> as eigenvalue of a unit <M>u</M>
of order <A>k</A> under the representation corresponding to <A>chi</A> having the partial augmentations
<A>paraugs</A> for the elements <M>u^d</M> for divisors <M>d</M> different from <A>k</A>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="chi k paraug" Name="HeLP_CharacterValue" />
 <Returns>the character value <M>chi(u)</M>
</Returns>
 <Description>
The function returns the character value <M>chi(u)</M> of an element <M>u</M> of order <Math>k</Math> having the partial augmentations <A>paraug</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> C := CharacterTable("A6");;
gap> HeLP_WithGivenOrder(C, 6);                               
#I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
[ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
gap> chi := Irr(C)[2];;   # a character of degree 5
gap> HeLP_MultiplicitiesOfEigenvalues(chi, 6, HeLP_sol[6][2]);
[ 1, 0, 1, 2, 1, 0 ]
gap> HeLP_CharacterValue(chi, 6, HeLP_sol[6][2][3]);          
-2
gap> HeLP_CharacterValue(chi, 6, [-2,1,2]);
-2
gap> HeLP_CharacterValue(chi, 6, [-2,2,1]);
1
]]></Example>


These eigenvalues were computed manually by M. Hertweck and may be found in <Cite Key="HerA6"/>.

</Section>


</Chapter>

