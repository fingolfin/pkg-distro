% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ HeLP \mbox{}}}\\
\vfill

\hypersetup{pdftitle= HeLP }
\markright{\scriptsize \mbox{}\hfill  HeLP  \hfill\mbox{}}
{\Huge \textbf{ Hertweck-Luthar-Passi method. \mbox{}}}\\
\vfill

{\Huge  2.1 \mbox{}}\\[1cm]
{ 30/09/2015, The Lodge \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Andreas B{\"a}chle\\
    \mbox{}}}\\
{\Large \textbf{ Leo Margolis\\
    \mbox{}}}\\
\hypersetup{pdfauthor= Andreas B{\"a}chle\\
    ;  Leo Margolis\\
    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Andreas B{\"a}chle\\
    }  Email: \href{mailto://ABachle@vub.ac.be} {\texttt{ABachle@vub.ac.be}}\\
  Homepage: \href{http://homepages.vub.ac.be/~abachle/} {\texttt{http://homepages.vub.ac.be/\texttt{\symbol{126}}abachle/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Vrije Universiteit Brussel\\
 Vakgroep Wiskunde\\
 Pleinlaan 2\\
 1050 Brussels\\
 Belgium\\
 \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Leo Margolis\\
    }  Email: \href{mailto://Leo.Margolis@mathematik.uni-stuttgart.de} {\texttt{Leo.Margolis@mathematik.uni-stuttgart.de}}\\
  Homepage: \href{http://www.igt.uni-stuttgart.de/LstDiffgeo/Margolis/} {\texttt{http://www.igt.uni-stuttgart.de/LstDiffgeo/Margolis/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Institut f{\"u}r Algebra und Zahlentheorie\\
 Universit{\"a}t Stuttgart\\
 Pfaffenwaldring 57\\
 D-70569 Stuttgart\\
 Germany\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 {\copyright} 2015 by Andreas B{\"a}chle and Leo Margolis

 This package is free software and may be distributed under the terms and
conditions of the GNU Public License Version 2. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 2 ]}
 The authors are grateful to Sebastian Gutsche for endowing GAP with the
4ti2-Interface. We also would like to thank him for many very helpful
discussions. We also want to give credits to the developers of the software
4ti2. Thanks go to David Avis for writing lrslib and answering our questions
about it. We moreover thank Wolfgang Kimmerle for introducing us to the
beautiful world of group rings. The development of this package was partially
supported by the Research Foundation Flanders (FWO - Vlaanderen) and the DFG
priority program SPP 1489 Algorithmic and Experimental Methods in Algebra,
Geometry, and Number Theory. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

 \index{\textsf{HeLP}}     
\chapter{\textcolor{Chapter }{Introduction}}\label{Chapter_Introduction}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  The purpose of this package is to provide functionalities to work with torsion
units in (integral) group rings. It implements a method which was developed by
I.S. Luthar and I.B.S. Passi in \cite{LP} and which was extended by M. Hertweck in \cite{HertweckBrauer}. These names also constitute the name of the method, suggested by A.
Konovalov: \emph{He}rtweck-\emph{L}uthar-\emph{P}assi. The theory behind the method is briefly described in Chapter \ref{Chapter_Background}. 

 The package uses the software 4ti2 \cite{4ti2} and is hence only working on systems which have 4ti2 installed. For more
information on 4ti2 and to download it, please visit \href{http://www.4ti2.de} {www.4ti2.de}. To interact with 4ti2 the package makes use of the 4ti2-Interface written by
S. Gutsche, which in turn uses the package IO. Note that the latter package
needs a C-part to be compiled; see the readme-file or the documentation of
that package. The package also provides the possibility to use redund form the
lrslib software \cite{lrslib}, to remove redundant inequalities before solving the system, which might
speed up the computations significantly. However, it is not a requirement to
have lrslib installed. If the above mentioned preconditions are fulfilled, one
just has to copy the HeLP-package in the GAP pkg-directory. Now the package
can be loaded by typing \texttt{LoadPackage("HeLP");} during a GAP-session. If the HeLP-package doesn't work properly on your
computer, you might want to check Section \ref{Chapter_Remarks_on_technical_problems_and_the_implementation_Section_Making_the_HeLP-package_run} for some trouble shooting. }

   
\chapter{\textcolor{Chapter }{The main functions}}\label{Chapter_The_main_functions}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7D3DC4ED855DC13C}{}
{
  
\section{\textcolor{Chapter }{Zassenhaus Conjecture}}\label{Chapter_The_main_functions_Section_Zassenhaus_Conjecture}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7C3DBA147B6CF284}{}
{
  This function checks whether the Zassenhaus Conjecture ((ZC) for short, cf.
Section \ref{Chapter_Background_Section_The_Zassenhaus_Conjecture_and_the_Prime_Graph_Question}) can be proved using the HeLP-method with the data available in GAP. 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}ZC}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X81AF79A587054306}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}ZC({\mdseries\slshape OrdinaryCharacterTable|Group})\index{HeLPZC@\texttt{HeLP{\textunderscore}ZC}}
\label{HeLPZC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if (ZC) can be solved using the given data, \texttt{false} otherwise 



 \texttt{HeLP{\textunderscore}ZC} checks whether the Zassenhaus Conjecture can be solved for the given group
using the HeLP method, the Wagner test and all character data available. The
argument of the function can be either an ordinary character table or a group.
In the second case it will first calculate the corresponding ordinary
character table. If the group in question is nilpotent, the Zassenhaus
Conjecture holds by a result of A. Weiss and the function will return \texttt{true} without performing any calculations.

 If the group is not solvable, the function will check all orders which are
divisors of the exponent of the group. If the group is solvable, it will only
check the orders of group elements, as there can't be any torsion units of
another order. The function will use the ordinary table and, for the primes $p$ for which the group is not $p$-solvable, all $p$-Brauer tables which are available in GAP to produce as many constraints on
the torsion units as possible. Additionally, the Wagner test is applied to the
results, cf. Section \ref{Chapter_Background_Section_The_Wagner_test}. In case the information suffices to obtain a proof for the Zassenhaus
Conjecture for this group the function will return \texttt{true} and \texttt{false} otherwise. The possible partial augmentations for elements of order $k$ and all its powers will also be stored in the list entry \texttt{HeLP{\textunderscore}sol[k]}.

 The prior computed partial augmentations in \texttt{HeLP{\textunderscore}sol} will not be used and will be overwritten. If you do not like the last fact,
please use \texttt{HeLP{\textunderscore}AllOrders} (\ref{HeLPAllOrders}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := AlternatingGroup(5);|
  Alt( [ 1 .. 5 ] )
  !gapprompt@gap>| !gapinput@HeLP_ZC(G);|
  true
  !gapprompt@gap>| !gapinput@C := CharacterTable("A5");|
  CharacterTable( "A5" )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  true
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ] ] ],, 
    [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ], [  ],,,, [  ],,,,, [  ],,,,,,,,,,,,,,, [  ] 
   ]
  !gapprompt@gap>| !gapinput@HeLP_PrintSolution(); |
  Solutions for elements of order 2:
  [ [         u ],
    [  [ "2a" ] ],
    [       --- ],
    [     [ 1 ] ] ]
  Solutions for elements of order 3:
  [ [         u ],
    [  [ "3a" ] ],
    [       --- ],
    [     [ 1 ] ] ]
  Solutions for elements of order 5:
  [ [               u ],
    [  [ "5a", "5b" ] ],
    [             --- ],
    [        [ 0, 1 ] ],
    [        [ 1, 0 ] ] ]
  There are no admissible partial augmentations for elements of order 6.
  There are no admissible partial augmentations for elements of order 10.
  There are no admissible partial augmentations for elements of order 15.
  There are no admissible partial augmentations for elements of order 30.
\end{Verbatim}
 This is the classical example of Luthar and Passi to verify the Zassenhaus
Conjecture for the alternating group of degree 5, cf. \cite{LP}. In the first call of \texttt{HeLP{\textunderscore}ZC} this is checked using the character table computed by GAP using the given
group, the second call uses the character table from the character table
library. The entries of \texttt{HeLP{\textunderscore}sol} are 
\begin{itemize}
\item  lists with entries 0 and 1 (at the spots 1, 2, 3 and 5, which correspond to
torsion units that are conjugate to group elements), 
\item  empty lists (at the spots 6, 10, 15 and 30, stating that there are no
admissible partial augmentations for these orders), 
\item  or are not bound (these orders were not checked as they don't divide the
exponent of the group). 
\end{itemize}
 The function \texttt{HeLP{\textunderscore}PrintSolution} (\ref{HeLPPrintSolution}) can be used to display the result in a pretty way. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable( "A6" );|
  CharacterTable( "A6" )
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 2);|
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  #I  Checking order 2.
  #I  Checking order 3.
  #I  Checking order 4.
  #I  Checking order 5.
  #I  Checking order 6.
  #I  Checking order 10.
  #I  Checking order 12.
  #I  Checking order 15.
  #I  Checking order 20.
  #I  Checking order 30.
  #I  Checking order 60.
  #I  ZC can't be solved, using the given data, for the orders: [ 6 ].
  false
  !gapprompt@gap>| !gapinput@HeLP_sol[6];                                          |
  [ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_PrintSolution(6);                                |
  Solutions for elements of order 6:
  [ [                   u^3,                   u^2,                     u ],
    [              [ "2a" ],        [ "3a", "3b" ],  [ "2a", "3a", "3b" ] ],
    [                   ---,                   ---,                   --- ],
    [                 [ 1 ],              [ 0, 1 ],          [ -2, 2, 1 ] ],
    [                 [ 1 ],              [ 1, 0 ],          [ -2, 1, 2 ] ] ]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 1);|
\end{Verbatim}
 This is the example M. Hertweck deals with in his article \cite{HerA6}. The HeLP-method is not sufficient to verify the Zassenhaus Conjecture for
this group. There are two tuples of possible partial augmentations for torsion
units of order 6 which are admissible by the HeLP method. M. Hertweck used a
different argument to eliminate these possibilities. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := SmallGroup(48,30);;|
  !gapprompt@gap>| !gapinput@StructureDescription(G);|
  "A4 : C4"
  !gapprompt@gap>| !gapinput@HeLP_ZC(G);|
  #I  ZC can't be solved, using the given data, for the orders: [ 4 ].
  false
  !gapprompt@gap>| !gapinput@Size(HeLP_sol[4]);|
  20
\end{Verbatim}
 The group SmallGroup(48,30) is the smallest group for which the HeLP method
does not suffice to prove the Zassenhaus Conjecture. However (ZC) was proved
for this group in \cite{HoefertKimmerle}, Proposition 4.2. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := SmallGroup(96,65);;|
  !gapprompt@gap>| !gapinput@HeLP_ZC(G);|
  #I  (ZC) can't be solved, using the given data, for the orders: [ 8 ].
  false
  !gapprompt@gap>| !gapinput@Size(HeLP_sol[8]);|
  40
  !gapprompt@gap>| !gapinput@G := SmallGroup(160,13);;|
  !gapprompt@gap>| !gapinput@HeLP_ZC(G);|
  true
\end{Verbatim}
 The Zassenhaus Conjecture for the first group in the above example, i.e.
SmallGroup(96,65), was proved by A. Herman and G. Singh \cite{HermanSingh}. They did not do all the computations for SmallGroup(160,13). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := CharacterTable(SymmetricGroup(5));|
  CharacterTable( Sym( [ 1 .. 5 ] ) )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C1);|
  #I  The Brauer tables for the following primes are not available: [ 2, 3, 5 ].
  #I  ZC can't be solved, using the given data, for the orders: [ 4, 6 ].
  false
  !gapprompt@gap>| !gapinput@C2 := CharacterTable("S5");|
  CharacterTable( "A5.2" )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C2); |
  true
\end{Verbatim}
 This example demonstrates the advantage of using the GAP character table
library: Since GAP can't compute the Brauer tables from the ordinary table of $S_5$ in the current implementation, they are not used in the first calculation. But
in the second calculation \texttt{HeLP{\textunderscore}ZC} accesses the Brauer tables from the library and can prove the Zassenhaus
Conjecture for this group, see \cite{HertweckBrauer}, Section 5. This example might of course change as soon as GAP will be able
to compute the needed Brauer tables. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("M11");|
  CharacterTable( "M11" )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  #I  ZC can't be solved, using the given data, for the orders: [ 4, 6, 8 ].
  false
  !gapprompt@gap>| !gapinput@HeLP_sol[12];|
  [  ]
  !gapprompt@gap>| !gapinput@HeLP_PrintSolution(8);|
  Solutions for elements of order 8:
  [ [      u^4,                         u^2,                           u ],
    [ [ "2a" ],              [ "2a", "4a" ],  [ "2a", "4a", "8a", "8b" ] ],
    [      ---,                         ---,                         --- ],
    [    [ 1 ],                    [ 0, 1 ],              [ 0, 0, 0, 1 ] ],
    [    [ 1 ],                    [ 0, 1 ],              [ 0, 0, 1, 0 ] ],
    [    [ 1 ],                    [ 0, 1 ],             [ 0, 2, -1, 0 ] ],
    [    [ 1 ],                    [ 0, 1 ],             [ 0, 2, 0, -1 ] ],
    [    [ 1 ],                   [ 2, -1 ],              [ 0, 0, 0, 1 ] ],
    [    [ 1 ],                   [ 2, -1 ],              [ 0, 0, 1, 0 ] ],
    [    [ 1 ],                   [ 2, -1 ],             [ 0, 2, -1, 0 ] ],
    [    [ 1 ],                   [ 2, -1 ],             [ 0, 2, 0, -1 ] ] ]
\end{Verbatim}
 Comparing this example to the result in \cite{KonovalovM11} one sees, that the existence of elements of order 12 in $\mathrm{V}(\mathbb{Z}M_{11})$ may not be eliminated using only the HeLP method. This may be done however by
applying also the Wagner test, cf. Section \ref{Chapter_Background_Section_The_Wagner_test} and the example for the function \texttt{HeLP{\textunderscore}WagnerTest} (\ref{HeLPWagnerTest}).

 This example also demonstrates, why also the partial augmentations of the
powers of $u$ must be stored (and not only the partial augmentations of $u$). To prove that all elements of order $8$ in $\mathrm{V}(\mathbb{Z}M_{11})$ are rationally conjugate to group elements, it is not enough to prove that all
elements $u$ of order $8$ in $\mathrm{V}(\mathbb{Z}M_{11})$ have all partial augmentations $1$ and $0$, as the fifth and sixth possibility from above still could exist in $\mathrm{V}(\mathbb{Z}M_{11})$, which would not be rationally conjugate to group elements. }

 
\section{\textcolor{Chapter }{Prime Graph Question}}\label{Chapter_The_main_functions_Section_Prime_Graph_Question}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7B12013C7C8A6714}{}
{
  This function checks whether the Prime Graph Question ((PQ) for short, cf.
Section \ref{Chapter_Background_Section_The_Zassenhaus_Conjecture_and_the_Prime_Graph_Question}) can be verified using the HeLP method with the data available in GAP. 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}PQ}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X813A10398218E9EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}PQ({\mdseries\slshape OrdinaryCharacterTable|Group})\index{HeLPPQ@\texttt{HeLP{\textunderscore}PQ}}
\label{HeLPPQ}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if (PQ) can be solved using the given data, \texttt{false} otherwise 



 \texttt{HeLP{\textunderscore}PQ} checks whether an affirmative answer for the Prime Graph Question for the
given group can be obtained using the HeLP method, the Wagner restrictions and
the data available. The argument of the function can be either an ordinary
character table or a group. In the second case it will first calculate the
corresponding ordinary character table. If the group in question is solvable,
the Prime Graph Question has an affirmative answer by a result of W. Kimmerle
and the function will return \texttt{true} without performing any calculations.

 If the group is non-solvable, the ordinary character table and all $p$-Brauer tables for primes $p$ for which the group is not $p$-solvable and which are available in GAP will be used to produce as many
constraints on the torsion units as possible. Additionally, the Wagner test is
applied to the results, cf. Section \ref{Chapter_Background_Section_The_Wagner_test}. In case the information suffices to obtain an affirmative answer for the
Prime Graph Question, the function will return \texttt{true} and it will return \texttt{false} otherwise. Let $p$ and $q$ be distinct primes such that there are elements of order $p$ and $q$ in $G$ but no elements of order $pq$. Then for $k$ being $p$, $q$ or $pq$ the function will save the possible partial augmentations for elements of
order $k$ and its (non-trivial) powers in \texttt{HeLP{\textunderscore}sol[k]}. The function also does not use the previously computed partial augmentations
for elements of these orders but will overwrite the content of \texttt{HeLP{\textunderscore}sol}. If you do not like the last fact, please use \texttt{HeLP{\textunderscore}AllOrdersPQ} (\ref{HeLPAllOrdersPQ}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A7");|
  CharacterTable( "A7" )
  !gapprompt@gap>| !gapinput@HeLP_PQ(C);|
  true
\end{Verbatim}
 The Prime Graph Question for the alternating group of degree 7 was first
proved by M. Salim \cite{SalimA7A8}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(19)");|
  CharacterTable( "L2(19)" )
  !gapprompt@gap>| !gapinput@HeLP_PQ(C);                   |
  true
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  #I  For the following orders ZC can not be solved, using the given data: [ 10 ].
  false
  !gapprompt@gap>| !gapinput@HeLP_sol[10];|
  [ [ [ 1 ], [ 0, 1 ], [ 0, -1, 1, 0, 1 ] ], 
    [ [ 1 ], [ 0, 1 ], [ 0, 0, 0, 1, 0 ] ], 
    [ [ 1 ], [ 1, 0 ], [ 0, 0, 0, 0, 1 ] ], 
    [ [ 1 ], [ 1, 0 ], [ 0, 1, -1, 1, 0 ] ] ]
\end{Verbatim}
 The HeLP method provides an affirmative answer to the Prime Graph Question for
the group L2(19), although the method doesn't solve the Zassenhaus Conjecture
for that group, as there are two sets of possible partial augmentations for
units of order 10 left, which do not correspond to elements which are
rationally conjugate to group elements. The Zassenhaus Conjecture for this
group is proved in \cite{BaMaM10}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := CharacterTable(PSL(2,7));                                  |
  CharacterTable( Group([ (3,7,5)(4,8,6), (1,2,6)(3,4,8) ]) )
  !gapprompt@gap>| !gapinput@HeLP_PQ(C1);|
  #I  The Brauer tables for the following primes are not available: [ 2, 3, 7 ].
  #I  PQ can't be solved, using the given data, for the orders: [ 6 ].
  false
  !gapprompt@gap>| !gapinput@C2 := CharacterTable("L2(7)");  |
  CharacterTable( "L3(2)" )
  !gapprompt@gap>| !gapinput@HeLP_PQ(C2);                  |
  true
\end{Verbatim}
 This example demonstrates the advantage of using tables from the GAP character
table library: Since GAP can not compute the Brauer tables corresponding to \texttt{C1} they are not used in the first calculation. But in the second calculation \texttt{HeLP{\textunderscore}PQ} accesses the Brauer tables from the library and can prove the Prime Graph
Question for this group, see \cite{HertweckBrauer}, Section 6. This example might change, as soon as GAP will be able to compute
the Brauer tables needed. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,2);|
  !gapprompt@gap>| !gapinput@C := CharacterTable("A6");|
  CharacterTable( "A6" )
  !gapprompt@gap>| !gapinput@HeLP_PQ(C);|
  #I  Checking order 2.
  #I  Checking order 3.
  #I  Checking order 5.
  #I  Checking order 6.
  #I  Checking order 10.
  #I  Checking order 15.
  #I  PQ can't be solved, using the given data, for the orders: [ 6 ].
  false
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,1);|
\end{Verbatim}
 The Prime Graph Question can not be confirmed for the alternating group of
degree 6 with the HeLP-method. This group is handled in \cite{HerA6} by other means. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(49)");|
  CharacterTable( "L2(49)" )
  !gapprompt@gap>| !gapinput@HeLP_PQ(C);|
  #I  The Brauer tables for the following primes are not available: [ 7 ].
  #I  (PQ) can't be solved, using the given data, for the orders: [ 10, 15 ].
  false
\end{Verbatim}
 This example shows the limitations of the program. Using the Brauer table for
the prime 7 one can prove (PQ) for PSL(2,49), but this data is not available
in GAP at the moment. The fact that there are no torsion units of order 10 and
15 was proved in \cite{HertweckBrauer}, Proposition 6.7. See also the example in Section \ref{Chapter_Extended_examples_Section_Non-standard_characters}. }

 }

   
\chapter{\textcolor{Chapter }{Further functions}}\label{Chapter_Further_functions}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X85C2B0617ECCA64E}{}
{
  A short remark is probably in order on the three global variables the package
is using: \texttt{HeLP{\textunderscore}CT}, \texttt{HeLP{\textunderscore}sol} and \texttt{HeLP{\textunderscore}settings}. The first one stores the character table for which the last calculations
were performed, the second one containing at the \texttt{k}'s spot the already calculated admissible partial augmentations of elements of
order $k$ (and its powers $u^d$ for $d \not= k$ a divisor of $k$). If a function of the HeLP-package is called with a character table
different from the one saved in \texttt{HeLP{\textunderscore}CT} then the package tries to check if the character tables belong to the same
group. This can be done in particular for tables from the ATLAS. If this check
is successful the solutions already written in \texttt{HeLP{\textunderscore}sol} are kept, otherwise this variable is reset. For a more detailed account see
Sections \ref{Chapter_Extended_examples_Section_The_behavior_of_the_variable_HeLP_sol}, \ref{Chapter_Background_Section_Partial_augmentations_and_the_structure_of_HeLP_sol} and \texttt{HeLP{\textunderscore}ChangeCharKeepSols} (\ref{HeLPChangeCharKeepSols}). In most situations, the user does not have to worry about this, the program
will take care of it as far as possible. \texttt{HeLP{\textunderscore}settings} is a varaible which is used to store some settings of the program. 
\section{\textcolor{Chapter }{Checks for specific orders}}\label{Chapter_Further_functions_Section_Checks_for_specific_orders}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X85F252368293DB34}{}
{
  

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}WithGivenOrder}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7F8F6E3D80A23C1D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}WithGivenOrder({\mdseries\slshape CharacterTable|ListOfClassFunctions, ord})\index{HeLPWithGivenOrder@\texttt{HeLP{\textunderscore}WithGivenOrder}}
\label{HeLPWithGivenOrder}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of admissible partial augmentations 



 Calculates the admissible partial augmentations for elements of order \mbox{\texttt{\mdseries\slshape ord}} using only the data given in the first argument. The first argument can be an
ordinary character table, a Brauer table, or a list of class functions, all
having the same underlying character table. This function only uses the
constraints of the HeLP method (from the class functions given), but does not
apply the Wagner test \ref{Chapter_Background_Section_The_Wagner_test}. If the constraints allow only a finite number of solutions, these lists will
be written in \texttt{HeLP{\textunderscore}sol[ord]}. If for divisors $d$ of \mbox{\texttt{\mdseries\slshape ord}} solutions are already calculated and stored in \texttt{HeLP{\textunderscore}sol[d]}, these will be used, otherwise the function \texttt{HeLP{\textunderscore}WithGivenOrder} will first be applied to this order and the data given in the first argument. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A5");|
  CharacterTable( "A5" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 5);|
  #I  Number of solutions for elements of order 5: 2; stored in HeLP_sol[5].
  [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_PrintSolution(5);|
  Solutions for elements of order 5:
  [ [               u ],
    [  [ "5a", "5b" ] ],
    [             --- ],
    [        [ 0, 1 ] ],
    [        [ 1, 0 ] ] ]
\end{Verbatim}
 Tests which partial augmentations for elements of order 5 are admissible. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A6");|
  CharacterTable( "A6" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 4);|
  #I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
  [ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
    [ [ 1 ], [ 0, 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol[4];              |
  [ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
    [ [ 1 ], [ 0, 1 ] ] ]
\end{Verbatim}
 Two of the non-trivial partial augmentations can be eliminated by using the
Brauer table modulo the prime $3$: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C mod 3, 4);                                                                    |
  #I  Number of solutions for elements of order 4: 2; stored in HeLP_sol[4].
  [ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
\end{Verbatim}
 When using \texttt{HeLP{\textunderscore}ZC} also the last remaining non-trivial partial augmentation disappears, as this
function applies the Wagner test, cf. \ref{Chapter_Background_Section_The_Wagner_test} and \texttt{HeLP{\textunderscore}WagnerTest} (\ref{HeLPWagnerTest}): 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);               |
  #I  ZC can't be solved, using the given data, for the orders: [ 6 ].
  false
  !gapprompt@gap>| !gapinput@HeLP_sol[4]; HeLP_sol[6];|
  [ [ [ 1 ], [ 0, 1 ] ] ]
  [ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
\end{Verbatim}
 The following example demonstrates how one can use lists of characters to
obtain constraints for partial augmentations: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(49).2_1");   |
  CharacterTable( "L2(49).2_1" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(Irr(C){[2]}, 14);|
  #I  The given data admit infinitely many solutions for elements of order 14.
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(Irr(C){[44]}, 14);|
  #I  The given data admit infinitely many solutions for elements of order 14.
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(Irr(C){[2,44]}, 14);|
  #I  Number of solutions for elements of order 14: 0; stored in HeLP_sol[14].
  [  ]
\end{Verbatim}
 Brauer tables can provide more restrictions on partial augmentations of
certain torsion units: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("J1");       |
  CharacterTable( "J1" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 6);;|
  #I  Number of solutions for elements of order 6: 73; stored in HeLP_sol[6].
  !gapprompt@gap>| !gapinput@B := C mod 11;|
  BrauerTable( "J1", 11 )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(B, 6);;       |
  #I  Number of solutions for elements of order 6: 6; stored in HeLP_sol[6].
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(Irr(B){[2,3]}, 6);;|
  #I  Number of solutions for elements of order 6: 6; stored in HeLP_sol[6].
  !gapprompt@gap>| !gapinput@HeLP_PrintSolution(6);|
  Solutions for elements of order 6:
  [ [                   u^3,                   u^2,                     u ],
    [              [ "2a" ],              [ "3a" ],  [ "2a", "3a", "6a" ] ],
    [                   ---,                   ---,                   --- ],
    [                 [ 1 ],                 [ 1 ],          [ -2, 0, 3 ] ],
    [                 [ 1 ],                 [ 1 ],          [ 2, 0, -1 ] ],
    [                 [ 1 ],                 [ 1 ],           [ 0, 0, 1 ] ],
    [                 [ 1 ],                 [ 1 ],          [ -4, 3, 2 ] ],
    [                 [ 1 ],                 [ 1 ],          [ 0, 3, -2 ] ],
    [                 [ 1 ],                 [ 1 ],          [ -2, 3, 0 ] ] ]
\end{Verbatim}
 The result of the previous example can be found in \cite{BJK}. 

 When dealing with many variables using lists of characters instead of a
complete character table might also speed up the calculations a lot, see
Section \ref{Chapter_Extended_examples_Section_Saving_time}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(27)");|
  CharacterTable( "L2(27)" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,7);;|
  #I  Number of solutions for elements of order 7: 78; stored in HeLP_sol[7].
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,4);|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,3*7); |
  #I      Solutions for order 3 not yet calculated.  Restart for this order.
  #I  Number of solutions for elements of order 21: 0; stored in HeLP_sol[21].  
  [  ]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,1);|
\end{Verbatim}
 \texttt{HeLP{\textunderscore}WithGivenOrder} often needs to consider many cases. Set the info class
HeLP{\textunderscore}Info to a level 4 or higher to keep track of the
progress, see Section \ref{Chapter_Extended_examples_Section_Using_InfoLevels} on info levels. 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}WithGivenOrderAndPA}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7CD0CEF283F13F7B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}WithGivenOrderAndPA({\mdseries\slshape CharacterTable|ListOfClassFunctions, ord, partaugs})\index{HeLPWithGivenOrderAndPA@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{With}\-\texttt{Given}\-\texttt{Order}\-\texttt{AndPA}}
\label{HeLPWithGivenOrderAndPA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of admissible partial augmentations 



 Calculates the admissible partial augmentations for elements of order \mbox{\texttt{\mdseries\slshape ord}} using only the data given in the first argument. The first argument can be an
ordinary character table, a Brauer table, or a list of class functions, all
having the same underlying character table. The function uses the partial
augmentations for the powers $u^d$ with $d$ divisors of $k$ different from $1$ and $k$ given in \mbox{\texttt{\mdseries\slshape partaugs}}. Here, the $d$'s have to be in a descending order (i.e. the orders of the $u^d$'s are ascending). This function only uses the constraints of the HeLP method,
but does not apply the Wagner test \ref{Chapter_Background_Section_The_Wagner_test}. Note that this function will not affect \texttt{HeLP{\textunderscore}sol}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := SmallGroup(48,33);; StructureDescription(G);|
  "SL(2,3) : C2"
  !gapprompt@gap>| !gapinput@C := CharacterTable(G);;|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 4);;|
  #I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 6);;|
  #I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
  !gapprompt@gap>| !gapinput@HeLP_sol[4]; HeLP_sol[6];|
  [ [ [ 1, 0 ], [ 0, 1, 0, 0, 0 ] ], [ [ 1, 0 ], [ 0, 0, 0, 0, 1 ] ], 
    [ [ 1, 0 ], [ 0, 0, 0, 1, 0 ] ], [ [ 1, 0 ], [ 0, 0, 1, 0, 0 ] ] ]
  [ [ [ 1, 0 ], [ 0, 1 ], [ 0, 0, 0, 0, 1, 0 ] ], 
    [ [ 1, 0 ], [ 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderAndPA(C, 12, [ [ 1, 0 ],  [ 0, 1 ], [ 0, 0, 0, 0, 1 ],|
  !gapprompt@>| !gapinput@    [ 0, 0, 0, 0, 1, 0 ] ]); |
  #I  Number of solutions for elements of order 12 with these partial augmentation
  s for the powers: 1.
  [ [ [ 1, 0 ], [ 0, 1 ], [ 0, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1, 0 ], 
        [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderAndPA(C, 12, [ [ 1, 0 ],  [ 0, 1 ], [ 0, 0, 0, 1, 0 ],|
  !gapprompt@>| !gapinput@    [ 0, 0, 0, 0, 1, 0 ] ]);|
  #I  Number of solutions for elements of order 12 with these partial augmentation
  s for the powers: 0.
  [  ]
\end{Verbatim}
 In the calls of \texttt{HeLP{\textunderscore}WithGivenOrderAndPA} the function uses the following partial augmentations: 
\begin{itemize}
\item  \texttt{[ 1, 0 ]} for the element $u^6$ of order 2, 
\item  \texttt{[ 0, 1 ]} for the element $u^4$ of order 3, 
\item  \texttt{[ 0, 0, 0, 0, 1 ]} and \texttt{[ 0, 0, 0, 1, 0 ]} for the element $u^3$ of order 4 respectively, 
\item  \texttt{[ 0, 0, 0, 0, 1, 0 ]} for the element $u^2$ of order 6. 
\end{itemize}
 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}WithGivenOrderAndPAAndSpecificSystem}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X80D9773D86873CB2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}WithGivenOrderAndPAAndSpecificSystem({\mdseries\slshape list, ord, partaugs[, b]})\index{HeLPWithGivenOrderAndPAAndSpecificSystem@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{With}\-\texttt{Given}\-\texttt{Order}\-\texttt{And}\-\texttt{P}\-\texttt{A}\-\texttt{And}\-\texttt{Specific}\-\texttt{System}}
\label{HeLPWithGivenOrderAndPAAndSpecificSystem}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of admissible partial augmentations 



 Calculates the admissible partial augmentations for elements of order \mbox{\texttt{\mdseries\slshape ord}} using only the data given in the first argument. The first argument is a list,
which can contains as entries characters or pairs with first entry a character
and second entrie an integer or a mixture of these. The first argument is
understood as follows: If a character $\chi$ is not given in a pair all inequalities obtainable by this character are used.
If it is given in a pair with the integer $m$ the inequalities obtainable from the multiplicity of \texttt{E(ord)} taken to the power $m$ as an eigenvalue of a representation affording $\chi$ are used. The function uses the partial augmentations for the powers $u^d$ with $d$ divisors of $k$ different from $1$ and $k$ given in \mbox{\texttt{\mdseries\slshape partaugs}}. Here, the $d$'s have to be in a descending order (i.e. the orders of the $u^d$'s are ascending). This function only uses the constraints of the HeLP method,
but does not apply the Wagner test \ref{Chapter_Background_Section_The_Wagner_test}. Note that this function will not affect \texttt{HeLP{\textunderscore}sol}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A5");|
  CharacterTable( "A5" )
  !gapprompt@gap>| !gapinput@chi := Irr(C)[2];; psi := Irr(C)[4];|
  Character( CharacterTable( "A5" ), [ 4, 0, 1, -1, -1 ] )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderAndPAAndSpecificSystem([[chi, 1], [chi, 2]],|
  !gapprompt@>| !gapinput@ 5, [ ], true);|
  [ [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ], [ [ -3/5, 2/5 ], [ 2/5, -3/5 ] ], [ 3/5, 3/5 ] ]
  !gapprompt@gap>| !gapinput@sol5 := HeLP_WithGivenOrderAndPAAndSpecificSystem([[chi, 1], [chi, 2]], |
  !gapprompt@>| !gapinput@ 5, [ ]);      |
  [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
\end{Verbatim}
 The inequalities in the above examples are: 
\[\frac{-3}{5}\varepsilon_{5a}(u) + \frac{2}{5}\varepsilon_{5b}(u) + \frac{3}{5}
\in \mathbb{Z}_{\geq 0} \ \ {\rm{and}} \ \ \frac{2}{5}\varepsilon_{5a}(u) +
\frac{-3}{5}\varepsilon_{5b}(u) + \frac{3}{5} \in \mathbb{Z}_{\geq 0}. \]
 Continuing the above example: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderAndPAAndSpecificSystem([psi], |
  !gapprompt@>| !gapinput@ 2*5, [[1], sol5[1][1]], true);     |
  [ [  ], [ [ 0, -2/5, -2/5 ], [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ],
   [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ], [ 0, 2/5, 2/5 ], 
   [ 0, 1/10, 1/10 ], [ 0, -1/10, -1/10 ], [ 0, 1/10, 1/10 ], 
  [ 0, -1/10, -1/10 ] ], [ 0, 1/2, 1/2, 1/2, 1/2, 0, 1/2, 1/2, 1/2, 1/2 ] ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderAndPAAndSpecificSystem([[psi, 0], [psi, 2], [psi, 5]], |
  !gapprompt@>| !gapinput@ 2*5, [[1], sol5[2][1]], true); |
  [ [  ], [ [ 0, -2/5, -2/5 ], [ 0, 1/10, 1/10 ], [ 0, 2/5, 2/5 ] ], [ 0, 1/2, 0 ] ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Checks for specific orders with s-constant characters}}\label{Chapter_Further_functions_Section_Checks_for_specific_orders_with_s-constant_characters}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7FCD80AC87DD0460}{}
{
  When considering elements of order $st$ (in absence of elements of this order in the group ; in particular when trying
to prove (PQ)) and there are several conjugacy classes of elements of order $s$, it might be useful to consider $s$-constant characters (cf. Section \ref{Chapter_Background_Section_s-constant_(and_(s,t)-constant)_characters}) to reduce the computational complexity. 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}WithGivenOrderSConstant}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7CAC647C7D1E95B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}WithGivenOrderSConstant({\mdseries\slshape CharacterTable|ListOfClassFunctions, s, t})\index{HeLPWithGivenOrderSConstant@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{With}\-\texttt{Given}\-\texttt{Order}\-\texttt{S}\-\texttt{Constant}}
\label{HeLPWithGivenOrderSConstant}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of admissible "partial augmentations" or \texttt{"infinite"} 



 Calculates the admissible partial augmentations for elements $u$ of order $s*t$ using only the $s$-constant class functions that are contained in the first argument. The first
argument can be an ordinary character table, a Brauer table, or a list of
class functions, all having the same underlying character table. \mbox{\texttt{\mdseries\slshape s}} and \mbox{\texttt{\mdseries\slshape t}} have to be different prime numbers, such that there are elements of order \mbox{\texttt{\mdseries\slshape s}} and \mbox{\texttt{\mdseries\slshape t}} in the group, but no elements of order $s*t$. 

 The function filters which class functions given in the first argument are
constant on all conjugacy classes of elements of order \mbox{\texttt{\mdseries\slshape s}}. For the element $u^s$ of order \mbox{\texttt{\mdseries\slshape t}} the partial augmentations given in \texttt{HeLP{\textunderscore}sol[t]} are used. If they are not yet calculated, the function calculates them first,
using the data given in the first argument and stores them in \texttt{HeLP{\textunderscore}sol[t]}. This function only uses the constraints of the HeLP method, but does not
apply the Wagner test \ref{Chapter_Background_Section_The_Wagner_test}. If these calculations allow an infinite number of solutions of elements of
order $st$ the function returns \texttt{"infinite"}, otherwiese it returns the finite list of solutions for elements of order $s*t$. The first entry of every solution is a list of the partial augmentations of $u^s$ and the second entry is a list of the "partial augmentations" for $u$: the first entry of this list is the sum of the partial augmentations on all
classes of elements of order \mbox{\texttt{\mdseries\slshape s}} and the other entries are the partial augmentations on the classes of order \mbox{\texttt{\mdseries\slshape t}}. Only in the case that the existence of units of order $s*t$ can be excluded by this function the variable \texttt{HeLP{\textunderscore}sol[s*t]} will be affected and \texttt{HeLP{\textunderscore}sol[s*t]} will be set to \texttt{[ ]}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A6");;|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 6);            |
  #I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
  [ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(C, 2, 3);|
  [ [ [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1, 0 ], [ -2, 1, 2 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(C, 3, 2);     |
  [ [ [ 1 ], [ 3, -2 ] ] ]
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("Sz(8)");;|
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 4);|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(C, 7, 13);|
  #I    Partial augmentations for elements of order 13 not yet calculated.  Restar
  t for this order.
  #I    Number of non-trivial 7-constant characters in the list: 7.
  [  ]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 1);|
\end{Verbatim}
 The last example can also be checked by using all characters in \texttt{C}, but this takes notably longer. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("Sz(32)");|
  CharacterTable( "Sz(32)" )
  !gapprompt@gap>| !gapinput@L := Filtered(OrdersClassRepresentatives(C), x-> x = 31);; Size(L);|
  15           # I.e. HeLP_WithGivenOrder(C,31) would take hopelessly long
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(C mod 2, 31, 5);|
  [  ]
  !gapprompt@gap>| !gapinput@IsBound(HeLP_sol[31]);|
  false 
\end{Verbatim}
 We still have no clue about elements of order 31, but there are none of order
5*31. 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}AddGaloisCharacterSums}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X7B0FD19084B09AF8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}AddGaloisCharacterSums({\mdseries\slshape CT})\index{HeLPAddGaloisCharacterSums@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{Add}\-\texttt{Galois}\-\texttt{Character}\-\texttt{Sums}}
\label{HeLPAddGaloisCharacterSums}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of characters 



 Given an ordinary character table \mbox{\texttt{\mdseries\slshape CT}} the function calculates the orbits under the action of the Galois group and
returns a list of characters containing the ones contained in \mbox{\texttt{\mdseries\slshape CT}} and the ones obtained by summing up the Galois-orbits. }

 }

 
\section{\textcolor{Chapter }{Checks for all orders}}\label{Chapter_Further_functions_Section_Checks_for_all_orders}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X86A4BB01819B625D}{}
{
  

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}AllOrders}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X8727639883F787C5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}AllOrders({\mdseries\slshape CharacterTable|Group})\index{HeLPAllOrders@\texttt{HeLP{\textunderscore}AllOrders}}
\label{HeLPAllOrders}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if (ZC) can be solved using the given data, \texttt{false} otherwise 



 This function does almost the same as \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}). It checks whether the Zassenhaus Conjecture can be verified for a group, but
does not compute the partial augmentations of elements of order $k$, if \texttt{HeLP{\textunderscore}sol[k]} already exists. Thus some precalculations using e.g. \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}) are respected. In contrast to \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}) this function also does not check whether the group is nilpotent to use the
Weiss-result to have an immediate positive solution for (ZC). 

 This function is interesting if one wants to save time or possesses some
information, which was not obtained using this package and was entered
manually into \texttt{HeLP{\textunderscore}sol}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(7)");|
  CharacterTable( "L3(2)" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,6);|
  #I  Number of solutions for elements of order 6: 1; stored in HeLP_sol[6].
  [ [ [ 1 ], [ 1 ], [ -2, 3 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_AllOrders(C);|
  #I  (ZC) can't be solved, using the given data, for the orders: [ 6 ].
  false
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  true
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}AllOrdersPQ}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X7C00E1567BFF1757}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}AllOrdersPQ({\mdseries\slshape CharacterTable|Group})\index{HeLPAllOrdersPQ@\texttt{HeLP{\textunderscore}AllOrdersPQ}}
\label{HeLPAllOrdersPQ}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if (PQ) can be solved using the given data, \texttt{false} otherwise 



 This function does almost the same as \texttt{HeLP{\textunderscore}PQ} (\ref{HeLPPQ}). It checks whether the Prime Graph Question can be verified for a group, but
does not compute the partial augmentations of elements of order $k$, if \texttt{HeLP{\textunderscore}sol[k]} already exists. Thus some precalculations using e.g. \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}) are respected. In contrast to \texttt{HeLP{\textunderscore}PQ} (\ref{HeLPPQ}) this function also does not check whether the group is solvable to use the
Kimmerle-result to have an immediate positive solution for (ZC). 

 This function is interesting if one wants to save time or possesses some
information, which was not obtained using this package and was entered
manually into \texttt{HeLP{\textunderscore}sol}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A12");|
  CharacterTable( "A12" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(Irr(C){[2, 4, 7]}, 2);;|
  #I  Number of solutions for elements of order 2: 37; stored in HeLP_sol[2].
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(C mod 3,11,2);|
  [  ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(Irr(C mod 2){[2, 3, 4, 6]}, 3);;|
  #I  Number of solutions for elements of order 3: 99; stored in HeLP_sol[3].
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(C mod 2, 11, 3);|
  [  ]
  !gapprompt@gap>| !gapinput@HeLP_AllOrdersPQ(C);|
  true
\end{Verbatim}
 Thus the Prime Graph Question holds for the alternating group of degree 12.
Just using \texttt{HeLP{\textunderscore}PQ(C)} would take hopelessly long. }

 
\section{\textcolor{Chapter }{Changing the used Character Table}}\label{Chapter_Further_functions_Section_Changing_the_used_Character_Table}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X7E81639F8186F858}{}
{
  

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}ChangeCharKeepSols}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X7BB9009482784E90}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}ChangeCharKeepSols({\mdseries\slshape CT})\index{HeLPChangeCharKeepSols@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{Change}\-\texttt{Char}\-\texttt{Keep}\-\texttt{Sols}}
\label{HeLPChangeCharKeepSols}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
nothing 



 This function changes the used character table to the character table \mbox{\texttt{\mdseries\slshape CT}} and keeps all the solutions calculated so far. It is in this case the
responsibility of the user that the tables belong to the same group and the
ordering of the conjugacy classes in \mbox{\texttt{\mdseries\slshape CT}} is consistent with the one in the previously used table. This function can be
used to change from one table of the group to another, e.g. from a Brauer
table to the ordinary table if the calculations will involve $p$-singular elements. (In case the involved character tables come from the ATLAS
and their InfoText begins with "origin: ATLAS of finite groups", this is done
automatically by the program.) A user may also use characters, which are
normally not accessible in GAP. }

 To keep track of the change of the character tables one can set
HeLP{\textunderscore}Info to level 5. In this first example it is not realized
that the character tables belong to the same group, so the solutions for
elements of order 2 are recalculated (they have been reset, as another
character table is used). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 5);|
  !gapprompt@gap>| !gapinput@C := CharacterTable(SymmetricGroup(4)); |
  CharacterTable( Sym( [ 1 .. 4 ] ) )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C mod 2, 3); |
  #I  USED CHARACTER TABLE CHANGED TO BrauerTable( SymmetricGroup( [ 1 .. 4 ] ), 2
   ), ALL GLOBAL VARIABLES RESET.
  #I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
  [ [ [ 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 2*3);    |
  #I  USED CHARACTER TABLE CHANGED TO CharacterTable( SymmetricGroup( [ 1 .. 4 ] )
   ), ALL GLOBAL VARIABLES RESET.
  #I      Solutions for order 2 not yet calculated.  Restart for this order.
  #I      Solutions for order 3 not yet calculated.  Restart for this order.
  #I  Number of solutions for elements of order 6: 0; stored in HeLP_sol[6].
  [  ]
\end{Verbatim}
 The recalculations of the solutions can be avoided by calling \texttt{HeLP{\textunderscore}ChangeCharKeepSols} before using another character table. 
\begin{Verbatim}[commandchars=@|F,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>F @gapinput|D := CharacterTable(SymmetricGroup(4));F
  CharacterTable( Sym( [ 1 .. 4 ] ) )
  @gapprompt|gap>F @gapinput|HeLP_WithGivenOrder(D mod 2, 3);       F
  #I  USED CHARACTER TABLE CHANGED TO BrauerTable( SymmetricGroup( [ 1 .. 4 ] ), 2
   ), ALL GLOBAL VARIABLES RESET.
  #I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
  [ [ [ 1 ] ] ]
  @gapprompt|gap>F @gapinput|HeLP_ChangeCharKeepSols(D);F
  #I  WARNING: Change used character table without checking if the character table
  s have the same underlying groups and the ordering of the conjugacy classes are 
  the same!
  @gapprompt|gap>F @gapinput|HeLP_WithGivenOrder(D, 2*3);    F
  #I  Using same character table as until now; all known solutions kept.
  #I      Solutions for order 2 not yet calculated.  Restart for this order.
  #I  Number of solutions for elements of order 6: 0; stored in HeLP_sol[6].
  [  ]
\end{Verbatim}
 When using tables from the ATLAS this is done automatically: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CA := CharacterTable("A5");|
  CharacterTable( "A5" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(CA mod 2, 5);|
  #I  USED CHARACTER TABLE CHANGED TO BrauerTable( "A5", 2 ), ALL GLOBAL VARIABLES
   RESET.
  #I  Testing possibility 1 out of 1.
  #I  Number of solutions for elements of order 5: 2; stored in HeLP_sol[5].
  [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(CA, 2*5);    |
  #I  Using character table of the same group; all known solutions kept.
  #I      Solutions for order 2 not yet calculated.  Restart for this order.
  #I  Number of solutions for elements of order 10: 0; stored in HeLP_sol[10].
  [  ]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 1);|
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}Reset}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X7C19F3A378AAF294}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}Reset({\mdseries\slshape })\index{HeLPReset@\texttt{HeLP{\textunderscore}Reset}}
\label{HeLPReset}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
nothing 



 This function delets all the values calculated so far and resets the global
variables \texttt{HeLP{\textunderscore}CT} and \texttt{HeLP{\textunderscore}CT} to their initial value \texttt{[ [ [1] ] ]} and \texttt{CharacterTable(SmallGroup(1,1))} respectively. }

 }

 
\section{\textcolor{Chapter }{Influencing how the Systems of Inequalities are solved}}\label{Chapter_Further_functions_Section_Influencing_how_the_Systems_of_Inequalities_are_solved}
\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X7A05180B7DA5EB77}{}
{
  HeLP uses currently two external programs (i.e. programs that are not part of
the GAP-system): zsolve from 4ti2 to solve the systems of linear inequalities
and redund from lrslib to simplify the inequlities before handing them over to
zsolve (HeLP can also be used without lrslib installed, but in general it is
recommanded to have lrslib installed). The following functions can be used to
influence the behaviour of these external programms. 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}Change4ti2Precision}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X7F6C4FAD805CD7FC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}Change4ti2Precision({\mdseries\slshape string})\index{HeLPChange4ti2Precision@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{Change4ti2}\-\texttt{Precision}}
\label{HeLPChange4ti2Precision}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
nothing 



 The function changes the maximum precision of the calculations of 4ti2 to
solve the occurring systems of linear inequalities. The possible arguments are \texttt{"32"}, \texttt{"64"} and \texttt{"gmp"}. After calling the function the new precision will be used until this
function is used again. The default value is \texttt{"32"}. A higher precision causes slower calculations. But this function might be
used to increase the precision of 4ti2, when one gets an error message like
"Error, 4ti2 Error: Results were near maximum precision (32bit). Please
restart with higher precision!" stating that the results were close to the
maximum 4ti2-precision. }

 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}UseRedund}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X7A7536D9790C1901}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}UseRedund({\mdseries\slshape bool})\index{HeLPUseRedund@\texttt{HeLP{\textunderscore}UseRedund}}
\label{HeLPUseRedund}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
nothing 



 The function determines whether HeLP uses 'redund' from the lrslib-package to
remove redundant equations from the HeLP system. If \mbox{\texttt{\mdseries\slshape bool}} is \texttt{true} 'redund' will be used in all calculation that follow, if it is \texttt{false}, 'redund' will not be used (which might take significantly longer). If
'redund' was not found by GAP a warning will be printed and the calculations
will be performed without 'redund'. As default 'redund' will be used in all
calculations. }

 Sometimes it is desirable to perform calculations without redund (even if it
is installed and in many cases improves the performance of the package) or
with a higher precision. For example, determining the partial augmentations
for units of order $14$ for \texttt{SmallGroup(392, 30)} involves very long calculations (when called with redund and precision 32) or
cause errors (when called without redund and precision 32). However, the
following works in a reasonable time. 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>B @gapinput|C := CharacterTable(SmallGroup(392,30));B
  CharacterTable( <pc group of size 392 with 5 generators> )
  @gapprompt|gap>B @gapinput|HeLP_UseRedund(false);B
  The calculations will be performed without using 'redund' from now on.
  @gapprompt|gap>B @gapinput|HeLP_ZC(C);B
  Error, 4ti2 Error:
  Results were near maximum precision (32bit).
  Please restart with higher precision!
  If you continue, your results might be wrong called from
  4ti2Interface_zsolve_equalities_and_inequalities( 
   [ ListWithIdenticalEntries( Size( T[1] ), 1 ) ], [ 1 ], temp[1], - temp[2] 
   ) called from
  HeLP_TestSystemINTERNAL( W[1], W[2], k, arg[3] ) called from
  HeLP_WithGivenOrderAndPAINTERNAL( C, k, pa ) called from
  HeLP_WithGivenOrderINTERNAL( Irr( T ), k ) called from
  <function "HeLP_ZC">( <arguments> )
   called from read-eval loop at line 19 of *stdin*
  you can 'quit;' to quit to outer loop, or
  you can 'return;' to continue
  @gapprompt|gap>B @gapinput|brk> quit;B
  #I  Options stack has been reset
  @gapprompt|gap>B @gapinput|HeLP_Change4ti2Precision("64");B
  The calculations of 4ti2 will be performed with precision 64 from now on.
  @gapprompt|gap>B @gapinput|HeLP_ZC(C);B
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Checking solutions, calculating and checking solutions}}\label{Chapter_Further_functions_Section_Checking_solutions,_calculating_and_checking_solutions}
\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7990EC037D6AE938}{}
{
  

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}VerifySolution}}
\logpage{[ 3, 6, 1 ]}\nobreak
\hyperdef{L}{X7DAA7EF785621D9E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}VerifySolution({\mdseries\slshape CharacterTable|ListOfClassFunctions, k[, list{\textunderscore}paraugs]})\index{HeLPVerifySolution@\texttt{HeLP{\textunderscore}VerifySolution}}
\label{HeLPVerifySolution}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of admissible partial augmentations 



 This function checks which of the partial augmentations for elements of order \texttt{k} given in \texttt{HeLP{\textunderscore}sol[k]} or the optional third argument \texttt{list{\textunderscore}paraugs} fulfill the HeLP equations obtained from the characters in the first argument.
This function does not solve any inequalities, but only checks, if the given
partial augmentations fulfill them. It is for this reason often faster then
e.g. \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}).

 If there is no third argument given, i.e. the augmentations from \texttt{HeLP{\textunderscore}sol[k]} are used, the result overwrites \texttt{HeLP{\textunderscore}sol[k]}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A6");;|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 4);|
  #I  Number of solutions for elements of order 4: 4; stored in HeLP_sol[4].
  [ [ [ 1 ], [ -1, 2 ] ], [ [ 1 ], [ 2, -1 ] ], [ [ 1 ], [ 1, 0 ] ], 
    [ [ 1 ], [ 0, 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_VerifySolution(C mod 3, 4);|
  [ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol[4];|
  [ [ [ 1 ], [ 1, 0 ] ], [ [ 1 ], [ 0, 1 ] ] ]
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("S12");;|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(Irr(C mod 5){[2..6]}, 2);;|
  #I  Number of solutions for elements of order 2: 563; stored in HeLP_sol[2].
  !gapprompt@gap>| !gapinput@HeLP_VerifySolution(C mod 5, 2);;|
  !gapprompt@gap>| !gapinput@Size(HeLP_sol[2]);|
  387
  !gapprompt@gap>| !gapinput@HeLP_VerifySolution(C mod 3, 2);;|
  !gapprompt@gap>| !gapinput@Size(HeLP_sol[2]);|
  324
\end{Verbatim}
 Using \texttt{HeLP{\textunderscore}WithGivenOrder(C mod 5, 2)} or \texttt{HeLP{\textunderscore}WithGivenOrder(C mod 3, 2)} takes much longer since in that case a bigger system of inequalities must be
solved. 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}FindAndVerifySolution}}
\logpage{[ 3, 6, 2 ]}\nobreak
\hyperdef{L}{X8452B7F58641E7F5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}FindAndVerifySolution({\mdseries\slshape CharacterTable|ListOfClassFunctions, k})\index{HeLPFindAndVerifySolution@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{Find}\-\texttt{And}\-\texttt{Verify}\-\texttt{Solution}}
\label{HeLPFindAndVerifySolution}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of admissible partial augmentations or "infinite" 



 This function provides the same functionality as \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}) but instead of constructiong the corresponding system with all characters from
the first argument \mbox{\texttt{\mdseries\slshape CharacterTable|ListOfClassFunctions}} it does it consecutively with larger sets of characters from the argument
until a finite list of solutions is found and then applies \texttt{HeLP{\textunderscore}VerifySolution} (\ref{HeLPVerifySolution}) to these solutions with the entirety of the class functions in the first
argument.

 This function is sometimes faster than \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}), but the output is the same, thus the examples from \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}) also apply here. }

 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}PossiblePartialAugmentationsOfPowers}}
\logpage{[ 3, 6, 3 ]}\nobreak
\hyperdef{L}{X81E4BAF2815051C4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}PossiblePartialAugmentationsOfPowers({\mdseries\slshape n})\index{HeLPPossiblePartialAugmentationsOfPowers@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{Possible}\-\texttt{Partial}\-\texttt{Augmentations}\-\texttt{Of}\-\texttt{Powers}}
\label{HeLPPossiblePartialAugmentationsOfPowers}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of partial augmentations of powers. 



 This function provides the possible partial augmentations of the powers of
units of a given order $n,$ if the partial augmentations if units of order $n/p$ have been already computed for all primes $p$ dividing $n.$ The possibilities are sorted in the same way as, if the order $n$ is checked with any other function like e.g. \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}) or \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}). Thus, if the InfoLevel is high enough and one obtains that the computation
of some possibility is taking too long, one can check it using \texttt{HeLP{\textunderscore}WithGivenOrderAndPA} (\ref{HeLPWithGivenOrderAndPA}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,4);|
  !gapprompt@gap>| !gapinput@C := CharacterTable(SmallGroup(160,91));|
  CharacterTable( <pc group of size 160 with 6 generators> )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,4);;|
  #I      Solutions for order 2 not yet calculated.  Restart for this order.
  #I  Number of solutions for elements of order 4: 22; stored in HeLP_sol[4].   
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,10);;|
  #I      Solutions for order 5 not yet calculated.  Restart for this order.
  #I  Number of solutions for elements of order 10: 6; stored in HeLP_sol[10].  
  !gapprompt@gap>| !gapinput@LP := HeLP_PossiblePartialAugmentationsOfPowers(20);;|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderAndPA(Irr(C){[2..20]},20,LP[1]);|
  #I  Number of solutions for elements of order 20 with these partial augmentations
   for the powers: 0.
  [  ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The Wagner test}}\label{Chapter_Further_functions_Section_The_Wagner_test}
\logpage{[ 3, 7, 0 ]}
\hyperdef{L}{X7BA77C9F86ADD546}{}
{
  

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}WagnerTest}}
\logpage{[ 3, 7, 1 ]}\nobreak
\hyperdef{L}{X79349D80830FA89B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}WagnerTest({\mdseries\slshape k[, list{\textunderscore}paraugs, OrdinaryCharacterTable]})\index{HeLPWagnerTest@\texttt{HeLP{\textunderscore}WagnerTest}}
\label{HeLPWagnerTest}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of admissible partial augmentations 



 This function applies the Wagner test (cf. Section \ref{Chapter_Background_Section_The_Wagner_test}) to the given data. If only the order \mbox{\texttt{\mdseries\slshape k}} is given as argument, the Wagner test will be applied to the solutions stored
in \texttt{HeLP{\textunderscore}sol[k]}. If the arguments are the order \mbox{\texttt{\mdseries\slshape k}}, a list of possible solutions \mbox{\texttt{\mdseries\slshape list{\textunderscore}paraugs}} and an ordinary character table \mbox{\texttt{\mdseries\slshape OrdinaryCharacterTable}} it applies the test to the solutions given in \mbox{\texttt{\mdseries\slshape list{\textunderscore}paraugs}} and using the number of conjugacy classes for elements a divisor of \mbox{\texttt{\mdseries\slshape k}}, which will be extracted from the head of \mbox{\texttt{\mdseries\slshape OrdinaryCharacterTable}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("M11");|
  CharacterTable( "M11" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,8);;|
  #I  Number of solutions for elements of order 8: 36; stored in HeLP_sol[8].
  !gapprompt@gap>| !gapinput@HeLP_sol[8] := HeLP_WagnerTest(8);;|
  !gapprompt@gap>| !gapinput@Size(HeLP_sol[8]);|
  24
\end{Verbatim}
 Thus the Wagner-Test eliminates 12 possible partial augmentations for elements
of order 8. Continuing the example: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,12);|
  #I  Number of solutions for elements of order 12: 7; stored in HeLP_sol[12].
  [ [ [ 1 ], [ 1 ], [ 2, -1 ], [ 0, 3, -2 ], [ 1, 0, -1, 1 ] ], 
    [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, 3, -2 ], [ 0, 0, 0, 1 ] ], 
    [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, 3, -2 ], [ 0, 0, 2, -1 ] ], 
    [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ 1, 0, 1, -1 ] ], 
    [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ -1, 0, 1, 1 ] ], 
    [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, -3, 4 ], [ 0, 0, 0, 1 ] ], 
    [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, -3, 4 ], [ 1, 0, -1, 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol[12] := HeLP_WagnerTest(12);|
  [ [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, 3, -2 ], [ 0, 0, 0, 1 ] ], 
    [ [ 1 ], [ 1 ], [ -1, 2 ], [ 0, 3, -2 ], [ 0, 0, 2, -1 ] ], 
    [ [ 1 ], [ 1 ], [ 1, 0 ], [ 0, -3, 4 ], [ 0, 0, 0, 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol[4] := HeLP_WagnerTest(4);;|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,12);|
  #I  Number of solutions for elements of order 12: 3; stored in HeLP_sol[12].
  [ [ [ 1 ], [ 1 ], [ 2, -1 ], [ 0, 3, -2 ], [ 1, 0, -1, 1 ] ], 
    [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ 1, 0, 1, -1 ] ], 
    [ [ 1 ], [ 1 ], [ 0, 1 ], [ 0, 3, -2 ], [ -1, 0, 1, 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol[12] := HeLP_WagnerTest(12);|
  [  ]
\end{Verbatim}
 Thus there are no normalized units of order 12 in the integral group ring of $M_{11}.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("M22");|
  CharacterTable( "M22" )
  !gapprompt@gap>| !gapinput@HeLP_WagnerTest(12, [ [ [1], [1], [1,0], [0,0,1], [-3,3,2,3,-4] ] ],C);|
  [  ]
\end{Verbatim}
 This example is taken from the appendix of \cite{KonovalovM22}.

 Sometimes the Wagner-Test may even prove the Zassenhaus Conjecture: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := SmallGroup(96,187);|
  <pc group of size 96 with 6 generators>
  !gapprompt@gap>| !gapinput@C := CharacterTable(G);|
  CharacterTable( <pc group of size 96 with 6 generators> )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,4);;|
  #I  Number of solutions for elements of order 4: 34; stored in HeLP_sol[4].
  !gapprompt@gap>| !gapinput@HeLP_WagnerTest(4);       |
  [ [ [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 1 ] ],
    [ [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 1, 0, 0 ] ],
    [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1, 0, 0, 0 ] ], 
    [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 1, 0 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Output}}\label{Chapter_Further_functions_Section_Output}
\logpage{[ 3, 8, 0 ]}
\hyperdef{L}{X84DD5181826CA1C2}{}
{
  

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}PrintSolution}}
\logpage{[ 3, 8, 1 ]}\nobreak
\hyperdef{L}{X7A5CAEBD801EF192}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}PrintSolution({\mdseries\slshape [k]})\index{HeLPPrintSolution@\texttt{HeLP{\textunderscore}PrintSolution}}
\label{HeLPPrintSolution}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
nothing 



 This function prints the possible solutions in a pretty way. If a positive
integer \mbox{\texttt{\mdseries\slshape k}} as argument is given, then it prints the admissible partial augmentations of
units of order \mbox{\texttt{\mdseries\slshape k}}, if they are already calculated. If no argument is given, the function prints
information on all orders for which there are already informations. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A5");;|
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);          |
  true
  !gapprompt@gap>| !gapinput@HeLP_PrintSolution();|
  Solutions for elements of order 2:
  [ [         u ],
    [  [ "2a" ] ],
    [       --- ],
    [     [ 1 ] ] ]
  Solutions for elements of order 3:
  [ [         u ],
    [  [ "3a" ] ],
    [       --- ],
    [     [ 1 ] ] ]
  Solutions for elements of order 5:
  [ [               u ],
    [  [ "5a", "5b" ] ],
    [             --- ],
    [        [ 0, 1 ] ],
    [        [ 1, 0 ] ] ]
  There are no admissible partial augmentations for elements of order 6.
  There are no admissible partial augmentations for elements of order 10.
  There are no admissible partial augmentations for elements of order 15.
  There are no admissible partial augmentations for elements of order 30.
  !gapprompt@gap>| !gapinput@C := CharacterTable("A6");;|
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);           |
  #I  ZC can't be solved, using the given data, for the orders: [ 6 ].
  false
  !gapprompt@gap>| !gapinput@HeLP_PrintSolution(6);|
  Solutions for elements of order 6:
  [ [                   u^3,                   u^2,                     u ],
    [              [ "2a" ],        [ "3a", "3b" ],  [ "2a", "3a", "3b" ] ],
    [                   ---,                   ---,                   --- ],
    [                 [ 1 ],              [ 0, 1 ],          [ -2, 2, 1 ] ],
    [                 [ 1 ],              [ 1, 0 ],          [ -2, 1, 2 ] ] ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Eigenvalue multiplicities and character values}}\label{Chapter_Further_functions_Section_Eigenvalue_multiplicities_and_character_values}
\logpage{[ 3, 9, 0 ]}
\hyperdef{L}{X7F88D4667910126A}{}
{
  

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}MultiplicitiesOfEigenvalues}}
\logpage{[ 3, 9, 1 ]}\nobreak
\hyperdef{L}{X86601BE281C7B8B6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}MultiplicitiesOfEigenvalues({\mdseries\slshape chi, k, paraugs})\index{HeLPMultiplicitiesOfEigenvalues@\texttt{HeL}\-\texttt{P{\textunderscore}}\-\texttt{Multiplicities}\-\texttt{Of}\-\texttt{Eigenvalues}}
\label{HeLPMultiplicitiesOfEigenvalues}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list of multiplicities of eigenvalues 



 The returned list contains at the $l$-th spot the multiplicity of \texttt{E(k)\texttt{\symbol{94}}(l-1)} as eigenvalue of a unit $u$ of order \mbox{\texttt{\mdseries\slshape k}} under the representation corresponding to \mbox{\texttt{\mdseries\slshape chi}} having the partial augmentations \mbox{\texttt{\mdseries\slshape paraugs}} for the elements $u^d$ for divisors $d$ different from \mbox{\texttt{\mdseries\slshape k}}. }

 

\subsection{\textcolor{Chapter }{HeLP{\textunderscore}CharacterValue}}
\logpage{[ 3, 9, 2 ]}\nobreak
\hyperdef{L}{X7C4C37B681A5BC7D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeLP{\textunderscore}CharacterValue({\mdseries\slshape chi, k, paraug})\index{HeLPCharacterValue@\texttt{HeLP{\textunderscore}CharacterValue}}
\label{HeLPCharacterValue}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
the character value $chi(u)$ 



 The function returns the character value $chi(u)$ of an element $u$ of order $k$ having the partial augmentations \mbox{\texttt{\mdseries\slshape paraug}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A6");;|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 6);                               |
  #I  Number of solutions for elements of order 6: 2; stored in HeLP_sol[6].
  [ [ [ 1 ], [ 0, 1 ], [ -2, 2, 1 ] ], [ [ 1 ], [ 1, 0 ], [ -2, 1, 2 ] ] ]
  !gapprompt@gap>| !gapinput@chi := Irr(C)[2];;   # a character of degree 5|
  !gapprompt@gap>| !gapinput@HeLP_MultiplicitiesOfEigenvalues(chi, 6, HeLP_sol[6][2]);|
  [ 1, 0, 1, 2, 1, 0 ]
  !gapprompt@gap>| !gapinput@HeLP_CharacterValue(chi, 6, HeLP_sol[6][2][3]);          |
  -2
  !gapprompt@gap>| !gapinput@HeLP_CharacterValue(chi, 6, [-2,1,2]);|
  -2
  !gapprompt@gap>| !gapinput@HeLP_CharacterValue(chi, 6, [-2,2,1]);|
  1
\end{Verbatim}
 These eigenvalues were computed manually by M. Hertweck and may be found in \cite{HerA6}. }

 }

   
\chapter{\textcolor{Chapter }{Extended examples}}\label{Chapter_Extended_examples}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7CDC63A27F7790AA}{}
{
  We will give some more extended examples which are intended to give the user
an idea of the behaviour on different inputs, how to use the package more
efficently, to use characters not available in libraries and how InfoLevels
can be helpful. We will give some more examples which are intended to give the
user an idea of the behavior on different inputs and the variable
HeLP{\textunderscore}sol. We also give hints how to use the package more
efficiently, to use characters not available in libraries and how InfoLevels
can be helpful. 
\section{\textcolor{Chapter }{The Character Table Library}}\label{Chapter_Extended_examples_Section_The_Character_Table_Library}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7DEAD03D7811F9FA}{}
{
  
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := SL(2,7);|
  SL(2,7)
  !gapprompt@gap>| !gapinput@HeLP_ZC(G);|
  #I  The Brauer tables for the following primes are not available: [ 2, 3, 7 ].
  #I  (ZC) can't be solved, using the given data, for the orders: [ 8 ].
  false
  !gapprompt@gap>| !gapinput@C1 := CharacterTable(G);|
  CharacterTable( SL(2,7) )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C1);|
  #I  The Brauer tables for the following primes are not available: [ 2, 3, 7 ].
  #I  (ZC) can't be solved, using the given data, for the orders: [ 8 ].
  false
  !gapprompt@gap>| !gapinput@C2 := CharacterTable("2.L2(7)");|
  CharacterTable( "2.L3(2)" )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C2);|
  true
\end{Verbatim}
 Note that the first and the second call of \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}) are equivalent -- the only difference being that in the first version the
character table of the group is also calculated by the function, in the second
version the calculations are performed with the given character table. For the
third call of \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}) a character table for SL2(7) is used which comes from the character table
library. The different result is due to the fact, that in the third version
the Brauer tables are available (the Brauer table for the prime $p = 7$ is needed to rule out some non-trivial partial augmentations for elements of
order 8), whereas for the first and the second call no Brauer tables are
available in GAP. }

 
\section{\textcolor{Chapter }{The behavior of the variable HeLP sol}}\label{Chapter_Extended_examples_Section_The_behavior_of_the_variable_HeLP_sol}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X84ED1F0D7A47B055}{}
{
  This sections demonstrates when the global variable \texttt{HeLP{\textunderscore}sol} is reset. This is the case if calculations are performed using (the character
table of) another group than before: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("A5");|
  CharacterTable( "A5" )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  true
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ] ] ],, 
    [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ], [  ],,,, [  ],,,,, [  ],,,,,,,,,,,,,,, [  ] 
   ]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L3(7).2");|
  CharacterTable( "L3(7).2" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderAndPA(Irr(C){[3,7,9,10]},21,[[1],[3,9,-11]]);|
  #I  Number of solutions for elements of order 21 with these partial augmentation
  s for the powers: 1.
  [ [ [ 1 ], [ 3, 9, -11 ], [ -6, 0, 3, 4 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ] ]
\end{Verbatim}
 The function \texttt{HeLP{\textunderscore}WithGivenOrderAndPA} (\ref{HeLPWithGivenOrderAndPA}) does not write a result in \texttt{HeLP{\textunderscore}sol[k]} (as it does not calculate all possible solutions of order $k$). However \texttt{HeLP{\textunderscore}sol} is reset as a different character table is used. We continue the above
example. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,3);|
  #I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
  [ [ [ 1 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ],, [ [ [ 1 ] ] ] ]
\end{Verbatim}
 If HeLP detects that the table used belongs to the same group, \texttt{HeLP{\textunderscore}sol} is not reset: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C mod 7, 19);|
  #I  Number of solutions for elements of order 19: 3; stored in HeLP_sol[19].
  [ [ [ 0, 0, 1 ] ], [ [ 0, 1, 0 ] ], [ [ 1, 0, 0 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ],, [ [ [ 1 ] ] ],,,,,,,,,,,,,,,, 
    [ [ [ 0, 0, 1 ] ], [ [ 0, 1, 0 ] ], [ [ 1, 0, 0 ] ] ] ]
  # the previously calaculated result for order 3 is still there.
\end{Verbatim}
 HeLP can detect that the character tables belong to the same group, if they
are identical objects in GAP or if both are tables of the same group from the
ATLAS and their InfoText begins with "origin: ATLAS of finite groups" (which
is usually the case for ATLAS tables). If the program can verify that the
character table which is used at the current call of a function belongs to the
same group as in the previous call of a function, the solutions stored in \texttt{HeLP{\textunderscore}sol} are kept. If the character table belongs to another group or it can not be
made sure that the character tabel belongs to the same group, \texttt{HeLP{\textunderscore}sol} is reset to the initial value \texttt{[ [ [1] ] ]} representing the trivial solution for units of order $1$.

 Not reseting \texttt{HeLP{\textunderscore}sol} can also be achieved using \texttt{HeLP{\textunderscore}ChangeCharKeepSols} (\ref{HeLPChangeCharKeepSols}). However, caution should be exercised when using this command since it may
manipulate \texttt{HeLP{\textunderscore}sol} into something meaningless. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := PSL(2,7);|
  Group([ (3,7,5)(4,8,6), (1,2,6)(3,4,8) ])
  !gapprompt@gap>| !gapinput@HeLP_ZC(G);|
  #I  The Brauer tables for the following primes are not available: [ 2, 3, 7 ].
  #I  (ZC) can't be solved, using the given data, for the orders: [ 6 ].
  false
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ], [ 0, 1 ] ] ],, 
    [ [ [ 1 ], [ 1 ], [ -2, 3 ] ] ], [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ],,,,, [  ],, 
    [  ],,,,,,, [  ],,,,,,, [  ],,,,,,,,,,,,,, [  ],,,,,,,,,,,,,,,,,,,,,,,,,,,,,
    ,,,,,,,,,,,,, [  ] ]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(7)") mod 7;|
  BrauerTable( "L3(2)", 7 )
  !gapprompt@gap>| !gapinput@HeLP_ChangeCharKeepSols(C); #This table belongs to the same group.|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,6);|
  #I  Number of solutions for elements of order 6: 0; stored in HeLP_sol[6].
  [  ]
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ], [ 0, 1 ] ] ],, 
    [  ], [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ],,,,, [  ],, [  ],,,,,,, [  ],,,,,,, 
    [  ],,,,,,,,,,,,,, [  ],,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, [  ] ]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L3(7).2") mod 7;|
  BrauerTable( "L3(7).2", 7 )
  !gapprompt@gap>| !gapinput@HeLP_ChangeCharKeepSols(C); #This table is from a different group|
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,19);|
  #I  Number of solutions for elements of order 19: 3; stored in HeLP_sol[19].
  [ [ [ 0, 0, 1 ] ], [ [ 0, 1, 0 ] ], [ [ 1, 0, 0 ] ] ]
  !gapprompt@gap>| !gapinput@HeLP_sol;|
  [ [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ] ] ], [ [ [ 1 ], [ 0, 1 ] ] ],, 
    [  ], [ [ [ 0, 1 ] ], [ [ 1, 0 ] ] ],,,,, [  ],, [  ],,,,, 
    [ [ [ 0, 0, 1 ] ], [ [ 0, 1, 0 ] ], [ [ 1, 0, 0 ] ] ],, [  ],,,,,,, [  ],,,,
    ,,,,,,,,,, [  ],,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, [  ] ]
  # The content of HeLP_sol does not have a mathematical value anymore.
\end{Verbatim}
 The following functions manipulate the variable \texttt{HeLP{\textunderscore}sol}: \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}), \texttt{HeLP{\textunderscore}PQ} (\ref{HeLPPQ}), \texttt{HeLP{\textunderscore}WithGivenOrder} (\ref{HeLPWithGivenOrder}), \texttt{HeLP{\textunderscore}WithGivenOrderSConstant} (\ref{HeLPWithGivenOrderSConstant}) (for elements of order $t$ and if the existence of elements of order $st$ can be excluded also for this order), \texttt{HeLP{\textunderscore}AllOrders} (\ref{HeLPAllOrders}), \texttt{HeLP{\textunderscore}AllOrdersPQ} (\ref{HeLPAllOrdersPQ}), \texttt{HeLP{\textunderscore}VerifySolution} (\ref{HeLPVerifySolution}) (if existing solutions were checked), \texttt{HeLP{\textunderscore}FindAndVerifySolution} (\ref{HeLPFindAndVerifySolution}). Note that the functions only will write results in \texttt{HeLP{\textunderscore}sol[k]} if $k$ is a divisor of the exponent of the group as this information is enough to
decide whether (ZC) and (PQ) are valid for the group in consideration. In all
other cases an empty list will be returned but no value will be written in \texttt{HeLP{\textunderscore}sol[k]}. 

 }

 
\section{\textcolor{Chapter }{Saving time}}\label{Chapter_Extended_examples_Section_Saving_time}
\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X7E939D8483F1EE64}{}
{
  The most time consuming operation when using the functions of this package is
solving the system of inequalities given by the HeLP method, see Section \ref{Chapter_Background_Section_The_HeLP_equations}. This package uses the program 4ti2 to do this and it is not completely clear
to the authors of this package which input is solved faster by 4ti2. In any
case it is helpful to reduce the number of variables, using e.g. $p$-constant characters, and in many situations it is useful to reduce the number
of inequalities, i.e. of used characters. 

 To measure the time a function needs we use \texttt{IO{\textunderscore}gettimeofday} from the IO-package rather than functions like \texttt{time} or \texttt{Runtime}, since these measure only the GAP time, but do not return the time the
functions spend using 4ti2. We used the following function (which is
essentially due to Alexander Konovalov) to meassure the time used for the
computation: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  TimeFunction := function(f, args)
  # input: the function of which the computing time should be measured 
  #        and the list of arguments for this function
  # output: time needed for the calculations in seconds
  local start;
  start := IO_gettimeofday();
  CallFuncList(f,args);
  return IO_gettimeofday().tv_sec - start.tv_sec;
  end; 
\end{Verbatim}
 All times will be given in seconds. The computations were perfomed on an 1,6
GHz kernel.

 A lot of time might be saved by testing only a few characters instead of a
whole character table: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(49)");;|
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrder, [C,35]);|
  #I  Number of solutions for elements of order 35: 0; stored in HeLP_sol[35].
  7                 # I.e.: The computation took 7 seconds.
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_FindAndVerifySolution, [C,35]);|
  #I  Number of solutions for elements of order 35: 0; stored in HeLP_sol[35].
  1
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_FindAndVerifySolution, [Irr(C){[2]}, 35]);|
  #I  Number of solutions for elements of order 35: 0; stored in HeLP_sol[35].
  1
\end{Verbatim}
 I.e.: Using only one character instead of all of them is about seven times
faster in this situation and this is also quickly found by \texttt{HeLP{\textunderscore}FindAndVerifySolution}. 

 Using only a few characters might even be a life saver: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L4(3).2^2");|
  CharacterTable( "L4(3).2^2" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 3);;|
  #I  Number of solutions for elements of order 3: 63; stored in HeLP_sol[3].
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 13);;|
  #I  Number of solutions for elements of order 13: 198; stored in HeLP_sol[13].
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,4);|
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrder, [Irr(C){[5,11,16]}, 39]);|
  #I  Number of solutions for elements of order 39: 0; stored in HeLP_sol[39].  
  1301
  !gapprompt@gap>| !gapinput@HeLP_UseRedund(false);|
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrder, [Irr(C){[5,11,16]}, 39]);|
  #I  Number of solutions for elements of order 39: 0; stored in HeLP_sol[39].  
  670
\end{Verbatim}
 The command \texttt{HeLP{\textunderscore}WithGivenOrder(C,39);} started at the same time on another kernel was at possibility 1228 out of
12474 when the above example was already finished. Started without redund it
was at possibility 5 out of 12474 and is probably still computing while you
read this. 

 If you want to check, if the solutions you found using only a few characters
satisfy the constraints of all characters, you can use \texttt{HeLP{\textunderscore}VerifySolution} (\ref{HeLPVerifySolution}): 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L3(7).2");|
  CharacterTable( "L3(7).2" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,7);;|
  #I  Number of solutions for elements of order 7: 153; stored in HeLP_sol[7].
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,4);|
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrder, [Irr(C){[3,7,9,10]}, 21]);|
  #I  Number of solutions for elements of order 21: 416; stored in HeLP_sol[21].
  2757
  !gapprompt@gap>| !gapinput@Set(Filtered(OrdersClassRepresentatives(C), x -> IsPrime(x))); |
  [ 2, 3, 7, 19 ] # The primes dividing the order of the group
  !gapprompt@gap>| !gapinput@HeLP_VerifySolution(C mod 2, 21);;|
  !gapprompt@gap>| !gapinput@HeLP_VerifySolution(C mod 19, 21);;|
  !gapprompt@gap>| !gapinput@Size(HeLP_sol[21]);|
  416
\end{Verbatim}
 Thus the computed partial augmentations are best possible using HeLP. Compare
the time to: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrder, [C, 21]);|
  #I  Number of solutions for elements of order 21: 416; stored in HeLP_sol[21].
  3460
\end{Verbatim}
 Sometimes it is helpful to look at groups containing the group of interest: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("2F4(2)'");|
  CharacterTable( "2F4(2)'" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 13);;|
  #I  Number of solutions for elements of order 13: 316; stored in HeLP_sol[13].
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C, 3);;|
  #I  Number of solutions for elements of order 3: 1; stored in HeLP_sol[3].
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrder, [C, 39]);|
  #I  Number of solutions for elements of order 39: 0; stored in HeLP_sol[39].
  1946
  !gapprompt@gap>| !gapinput@C:=CharacterTable("2F4(2)'.2");|
  CharacterTable( "2F4(2)'.2" )
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrder, [C, 39]);|
  #I  Number of solutions for elements of order 39: 0; stored in HeLP_sol[39].
  1
\end{Verbatim}
 This is also a good example to use $p$-constant characters: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=CharacterTable("2F4(2)'");|
  CharacterTable( "2F4(2)'" )
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_WithGivenOrderSConstant, [C, 13, 3]);|
  #I    Partial augmentations for elements of order 3 not yet calculated.  Restart
   for this order.
  #I    Number of non-trivial 13-constant characters in the list: 19.           
  0
\end{Verbatim}
 For some groups switching redund on and off gives major improvements. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable(SmallGroup(160,91));|
  CharacterTable( <pc group of size 160 with 6 generators> )
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_ZC, [C]);|
  41                                                                            
\end{Verbatim}
 Without redund \texttt{HeLP{\textunderscore}ZC(C)} ran for over 400 hours without a result. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable(SmallGroup(96,12));|
  CharacterTable( <pc group of size 96 with 6 generators> )
  !gapprompt@gap>| !gapinput@HeLP_UseRedund(false);|
  !gapprompt@gap>| !gapinput@TimeFunction(HeLP_ZC, [C]);|
  6                                                                            
\end{Verbatim}
 Running this example using redund the computations does not proceed for
elements of order 12. }

 
\section{\textcolor{Chapter }{Using InfoLevels}}\label{Chapter_Extended_examples_Section_Using_InfoLevels}
\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X8242093A82FE41FA}{}
{
  HeLP provides different InfoLevels for different situations. The variable
controlling the InfoLevel is \texttt{HeLP{\textunderscore}Info} and it might be changed using \texttt{SetInfoLevel(HeLP{\textunderscore}Info, n)} to set the InfoLevel to n. The maximal \texttt{HeLP{\textunderscore}Info} entry is 5, the default InfoLevel is 1. The examples below give some idea, how
one can use \texttt{HeLP{\textunderscore}Info}, but do not give complete information on all possibilities.

 If one is only interested whether (ZC) or (PQ) can be solved using the HeLP
method, one can set \texttt{HeLP{\textunderscore}Info} to 0: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("M11");|
  CharacterTable( "M11" )
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  #I  ZC can't be solved, using the given data, for the orders: [ 4, 6, 8 ].
  false
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 0);|
  !gapprompt@gap>| !gapinput@HeLP_ZC(C);|
  false
\end{Verbatim}
 If the InfoLevel is set to 2, the functions \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}) and \texttt{HeLP{\textunderscore}PQ} (\ref{HeLPPQ}) print information which order of torsion units is currently considered, so
that the user can keep track of the progress. This may be used for bigger
groups to see, if the calculations might finish at some point. Continuing the
above example: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 2);|
  !gapprompt@gap>| !gapinput@HeLP_PQ(C);|
  #I  Checking order 2.
  #I  Checking order 3.
  #I  Checking order 5.
  #I  Checking order 10.
  #I  Checking order 11.
  #I  Checking order 15.
  #I  Checking order 22.
  #I  Checking order 33.
  #I  Checking order 55.
  true
\end{Verbatim}
 \texttt{HeLP{\textunderscore}Info} at InfoLevel 3 provides also some information about the used ordinary
character table or Brauer tables: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info, 3);|
  !gapprompt@gap>| !gapinput@HeLP_PQ(C);|
  #I  Checking order 2.
  #I    Using table BrauerTable( "M11", 3 ).
  #I  Checking order 3.
  #I    Using table BrauerTable( "M11", 3 ).
  #I    Using table BrauerTable( "M11", 11 ).
  #I  Checking order 5.
  #I    Using table BrauerTable( "M11", 3 ).
  #I  Checking order 10.
  #I    Using table BrauerTable( "M11", 3 ).
  #I  Checking order 11.
  #I    Using table BrauerTable( "M11", 3 ).
  #I  Checking order 15.
  #I    Using table BrauerTable( "M11", 3 ).
  #I    Using table BrauerTable( "M11", 11 ).
  #I  Checking order 22.
  #I    Using table BrauerTable( "M11", 3 ).
  #I  Checking order 33.
  #I    Using table BrauerTable( "M11", 3 ).
  #I    Using table BrauerTable( "M11", 11 ).
  #I    Using table BrauerTable( "M11", 2 ).
  #I  Checking order 55.
  #I    Using table BrauerTable( "M11", 3 ).
  true
\end{Verbatim}
 Setting \texttt{HeLP{\textunderscore}Info} to 4 is useful when there are many possibilities for the partial augmentations
of the powers of some unit. A good example is the example on
"L4(3).2\texttt{\symbol{94}}2" in the section on Time Saving \ref{Chapter_Extended_examples_Section_Saving_time}, see above: If you see quickly that almost nothing is happening, you might
want to change your strategy.

 \texttt{HeLP{\textunderscore}Info} at level 5 informs the user on all changes of the used character table. Using
it makes sense, if you work with the command \texttt{HeLP{\textunderscore}ChangeCharKeepSols} (\ref{HeLPChangeCharKeepSols}). }

 
\section{\textcolor{Chapter }{Non-standard characters}}\label{Chapter_Extended_examples_Section_Non-standard_characters}
\logpage{[ 4, 5, 0 ]}
\hyperdef{L}{X818A647182CA20B3}{}
{
  The package also allows using characters even if the whole character table is
not available. E.g. induced characters: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("U3(8)");|
  CharacterTable( "U3(8)" )
  !gapprompt@gap>| !gapinput@G := PSU(3,8);               |
  <permutation group of size 5515776 with 2 generators>
  !gapprompt@gap>| !gapinput@A := AutomorphismGroup(G);|
  <group of size 99283968 with 4 generators>
  !gapprompt@gap>| !gapinput@AllCharacterTableNames(Size,Size(A));|
  [ "3.U3(8).6", "3.U3(8).S3" ]
\end{Verbatim}
 This means: The character table of the automorphism group A of PSU(3,8) is not
available in GAP. However one can use induced characters: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@NN := NormalSubgroups(A);|
  [ <trivial group>, <group of size 5515776 with 2 generators>, 
    <group with 3 generators>, <group of size 16547328 with 3 generators>, 
    <group of size 49641984 with 4 generators>, 
    <group of size 33094656 with 4 generators>, 
    <group of size 99283968 with 4 generators> ]
  !gapprompt@gap>| !gapinput@H := NN[2];      #Subgroup of A isomorphic to G              |
  <group of size 5515776 with 2 generators>
  !gapprompt@gap>| !gapinput@CharacterTableWithStoredGroup(H,C); |
  CharacterTable( <group of size 5515776 with 2 generators> )
  !gapprompt@gap>| !gapinput@D := CharacterTable(H);      |
  CharacterTable( <group of size 5515776 with 2 generators> )
  !gapprompt@gap>| !gapinput@chi := InducedClassFunction(Irr(D)[2],A);|
  Character( CharacterTable( <group of size 99283968 with 4 generators> ),
   [ 1008, -144, -126, 18, 0, 0, 0, 0, 36, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -18, 0, 0, 
    0, 0 ] )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder([chi],7*19);|
  #I  Number of solutions for elements of order 133: 0; stored in HeLP_sol[133].
  [  ]
\end{Verbatim}
 One can also use characters, which are not available in GAP, but are entered
manually: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("L2(49)");|
  CharacterTable( "L2(49)" )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,15);;|
  #I  Number of solutions for elements of order 15: 56; stored in HeLP_sol[15].
  !gapprompt@gap>| !gapinput@C7 := C mod 7;|
  fail
\end{Verbatim}
 The Brauer characters for the prime 7 are well known, see e.g. \cite{SrinivasanPSL} , but are not yet available in GAP. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@OrdersClassRepresentatives(C);|
  [ 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 12, 12, 24, 24, 24, 24, 25, 25, 25, 25, 
    25, 25, 25, 25, 25, 25 ]
  !gapprompt@gap>| !gapinput@chi := ClassFunction(C, [ 3, 0, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4, 0,  |
  !gapprompt@>| !gapinput@  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]);|
  ClassFunction( CharacterTable( "L2(49)" ),
   [ 3, 0, -1, 0, -E(5)^2-E(5)^3, -E(5)-E(5)^4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] )
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder([chi],15);|
  #I  Number of solutions for elements of order 15: 0; stored in HeLP_sol[15].
  [  ]
\end{Verbatim}
 The class function \texttt{chi} above is of course not a proper character of the group, but the values
coincide with the values of a 7-Brauer character of the group on the conjugacy
classes of order 1, 3 and 5, i.e. the one needed to use HeLP for order 15. All
functions of the HeLP-package only access values of class functions on
conjugacy classes of elements with an order dividing the order of the unit in
question. That is why this class function \texttt{chi} can be used in this setting. }

 
\section{\textcolor{Chapter }{A complete example: (PQ) for the MacLaughlin simple group}}\label{Chapter_Extended_examples_Section_A_complete_example:_(PQ)_for_the_MacLaughlin_simple_group}
\logpage{[ 4, 6, 0 ]}
\hyperdef{L}{X879DC8C287C41B09}{}
{
  This section gives a demonstration of many functions of the package. The goal
is to verify the Prime Graph Question for the McLaughlin simple group, which
was proved in \cite{KonovalovMcL} 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CharacterTable("McL");|
  CharacterTable( "McL" )
  !gapprompt@gap>| !gapinput@SetInfoLevel(HeLP_Info,4);|
\end{Verbatim}
 The function \texttt{HeLP{\textunderscore}PQ(C)} would take really long. Instead one can use \texttt{HeLP{\textunderscore}AllOrdersPQ(C)} several times on a high InfoLevel. Any time you see the function needs long,
just try some manual calculations. Compute first the partial augmentations of
elements of prime order: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C,2);;|
  #I  Number of solutions for elements of order 2: 1; stored in HeLP_sol[2].    
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C mod 2,3);;|
  #I  Number of solutions for elements of order 3: 4; stored in HeLP_sol[3].    
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C mod 3,5);;|
  #I  Number of solutions for elements of order 5: 6; stored in HeLP_sol[5].    
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C mod 3,7);;|
  #I  Number of solutions for elements of order 7: 174; stored in HeLP_sol[7].  
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrder(C mod 3,11);;|
  #I  Number of solutions for elements of order 11: 20; stored in HeLP_sol[11].
\end{Verbatim}
 For mixed order in most situations $p$-constant characters are interesting. Check the tables for such characters of
small degree. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(Irr(C){[2,3,4,5]},7,3);|
  #I    Number of non-trivial 7-constant characters in the list: 4.
  [  ]
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(Irr(C){[2,3,4,5]},11,2);|
  #I    Number of non-trivial 11-constant characters in the list: 4.
  [  ]                                                                          
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(Irr(C){[2,3,4,5]},11,3);|
  #I    Number of non-trivial 11-constant characters in the list: 4.
  [  ]  
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(Irr(C mod 3){[2,3,4,5]},7,5);|
  #I    Number of non-trivial 7-constant characters in the list: 4.
  [  ]  
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(Irr(C mod 3){[2,3,4,5]},7,11);|
  #I    Number of non-trivial 7-constant characters in the list: 4.
  [  ] 
  !gapprompt@gap>| !gapinput@HeLP_WithGivenOrderSConstant(Irr(C mod 3){[2,3,4,5]},11,5);|
  #I    Number of non-trivial 11-constant characters in the list: 2.
  [  ] 
\end{Verbatim}
 These calculations are enough to obtain an affirmative answer to the Prime
Graph Question: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HeLP_AllOrdersPQ(C);|
  #I  Checking order 2.
  #I    Using the known solutions for elements of order 2.
  #I  Checking order 3.
  #I    Using the known solutions for elements of order 3.
  #I  Checking order 5.
  #I    Using the known solutions for elements of order 5.
  #I  Checking order 7.
  #I    Using the known solutions for elements of order 7.
  #I  Checking order 11.
  #I    Using the known solutions for elements of order 11.
  #I  Checking order 21.
  #I    Using the known solutions for elements of order 21.
  #I  Checking order 22.
  #I    Using the known solutions for elements of order 22.
  #I  Checking order 33.
  #I    Using the known solutions for elements of order 33.
  #I  Checking order 35.
  #I    Using the known solutions for elements of order 35.
  #I  Checking order 55.
  #I    Using the known solutions for elements of order 55.
  #I  Checking order 77.
  #I    Using the known solutions for elements of order 77.
  true
\end{Verbatim}
 Checking these computations takes a few minutes. }

 }

   
\chapter{\textcolor{Chapter }{Background}}\label{Chapter_Background}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X84AF2F1D7D4E7284}{}
{
  
\section{\textcolor{Chapter }{The Zassenhaus Conjecture and the Prime Graph Question}}\label{Chapter_Background_Section_The_Zassenhaus_Conjecture_and_the_Prime_Graph_Question}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7CAEB4DF8506EBF9}{}
{
  Let $G$ be a finite group and let $\mathbb{Z}G$ denote its integral group ring. Let $\mathrm{V}(\mathbb{Z}G)$ be the group of units of augmentation one, aka. normalized units. An element
of the unit group of $\mathbb{Z}G$ is called a torsion element, if it has finite order. 

 A long standing conjecture of H.J. Zassenhaus asserts that every normalized
torsion unit of $\mathbb{Z}G$ is conjugate within $\mathbb{Q}G$ ("rationally conjugate") to an element of $G$, see \cite{Zas} or \cite{SehgalBook2}, Section 37. This is the first of his three famous conjectures about integral
group rings and the only one which is nowadays still open, hence it is
referred to as the Zassenhaus Conjecture (ZC). This conjecture asserts that
the torsion part of the units of $\mathbb{Z}G$ is as far determined by $G$ as possible. 

 Considering the difficulty of the problem W. Kimmerle raised the question,
whether the Prime Graph of the normalized units of $\mathbb{Z}G$ coincides with that one of $G$ (cf. \cite{Ari} Problem 21). This is the so called Prime Graph Question (PQ). The prime graph
of a group is the loop-free, undirected graph having as vertices those primes $p$, for which there is an element of order $p$ in the group. Two vertices $p$ and $q$ are joined by an edge, provided there is an element of order $pq$ in the group. In the light of this description, the Prime Graph Question asks,
whether there exists an element of order $pq$ in $G$ provided there exists an element of order $pq$ in $\mathrm{V}(\mathbb{Z}G)$ for every pair of primes $(p, q)$. 

 In general, by a result of J. A. Cohn and D. Livingstone \cite{CohnLivingstone}, Corollary 4.1, and a result of M. Hertweck \cite{HertweckSolvable}, the following is known about the possible orders of torsion units in
integral group rings: 

 \emph{Theorem:} The exponents of $\mathrm{V}(\mathbb{Z}G)$ and $G$ coincide. Moreover, if $G$ is solvable, any torsion unit in $\mathrm{V}(\mathbb{Z}G)$ has the same order as some element in $G.$ }

 
\section{\textcolor{Chapter }{Partial augmentations and the structure of HeLP sol}}\label{Chapter_Background_Section_Partial_augmentations_and_the_structure_of_HeLP_sol}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7E2BFEC182B09895}{}
{
  For a finite group $G$ and an element $x \in G$ let $x^G$ denote the conjugacy class of $x$ in $G$. The partial augmentation with respect to $x$ or rather the conjugacy class of $x$ is the map $\varepsilon_x $ sending an element $u $ to the sum of the coefficients at elements of the conjugacy class of $x$, i.e. 
\[ \varepsilon_x \colon \mathbb{Z}G \to \mathbb{Z}, \ \ \sum\limits_{g \in G} z_g
g \mapsto \sum\limits_{g \in x^G} z_g. \]
 Let $u$ be a torsion element in $\mathrm{V}(\mathbb{Z}G)$. By results of G. Higman, S.D. Berman and M. Hertweck the following is known
for the partial augmentations of $u$: 

 \emph{Theorem:} (\cite{SehgalBook2}, Proposition (1.4); \cite{HertweckBrauer}, Proposition 2.2) $\varepsilon_1(u) = 0$ if $u \not= 1$ and $\varepsilon_x(u) = 0$ if the order of $x$ does not divides the order of $u$. 

 Partial augmentations are connected to (ZC) and (PQ) via the following result,
which is due to Z. Marciniak, J. Ritter, S. Sehgal and A. Weiss \cite{MRSW}, Theorem 2.5: 

 \emph{Theorem:} A torsion unit $u \in \mathrm{V}(\mathbb{Z}G)$ of order $k$ is rationally conjugate to an element of $G$ if and only if all partial augmentations of $u^d$ vanish, except one (which then is necessarily 1) for all divisors $d$ of $k$.

 The last statement also explains the structure of the variable \texttt{HeLP{\textunderscore}sol}. In \texttt{HeLP{\textunderscore}sol[k]} the possible partial augmentations for an element of order $k$ and all powers $u^d$ for $d$ dividing $k$ (except for $d=k$) are stored, sorted ascending w.r.t. order of the element $u^d$. For instance, for $k = 12$ an entry of \texttt{HeLP{\textunderscore}sol[12]} might be of the following form:

 \texttt{[ [ 1 ],[ 0, 1 ],[ -2, 2, 1 ],[ 1, -1, 1 ],[ 0, 0, 0, 1, -1, 0, 1, 0, 0 ] ]}.

 The first sublist \texttt{[ 1 ]} indicates that the element $u^6$ of order 2 has the partial augmentation 1 at the only class of elements of
order 2, the second sublist \texttt{[ 0, 1 ]} indicates that $u^4$ of order 3 has partial augmentation 0 at the first class of elements of order
3 and 1 at the second class. The third sublist \texttt{[ -2, 2, 1 ]} states that the element $u^3$ of order 4 has partial augmentation -2 at the class of elements of order 2
while 2 and 1 are the partial augmentations at the two classes of elements of
order 4 respectively, and so on. Note that this format provides all necessary
information on the partial augmentations of $u$ and its powers by the above restrictions on the partial augmentations.

 For more details on when the variable \texttt{HeLP{\textunderscore}sol} is modified or reset and how to influence this behavior see Section \ref{Chapter_Extended_examples_Section_The_behavior_of_the_variable_HeLP_sol} and \texttt{HeLP{\textunderscore}ChangeCharKeepSols} (\ref{HeLPChangeCharKeepSols}). }

 
\section{\textcolor{Chapter }{The HeLP equations}}\label{Chapter_Background_Section_The_HeLP_equations}
\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X8663389F87B9CE62}{}
{
  Denote by $x^G$ the conjugacy class of an element $x$ in $G$. Let $u$ be a torsion unit in $\mathrm{V}(\mathbb{Z}G)$ of order $k$ and $D$ an ordinary representation of $G$ over a field contained in $\mathbb{C}$ with character $\chi$. Then $D(u)$ is a matrix of finite order and thus diagonalizable over $\mathbb{C}$. Let $\zeta$ be a primitive $k$-th root of unity, then the multiplicity $\mu_l(u,\chi)$ of $\zeta^l$ as an eigenvalue of $D(u)$ can be computed via Fourier inversion and equals 
\[ \mu_l(u,\chi) = \frac{1}{k} \sum_{1 \not= d \mid k}
{\rm{Tr}}_{\mathbb{Q}(\zeta^d)/\mathbb{Q}}(\chi(u^d)\zeta^{-dl}) + \frac{1}{k}
\sum_{x^G} \varepsilon_x(u)
{\rm{Tr}}_{\mathbb{Q}(\zeta)/\mathbb{Q}}(\chi(x)\zeta^{-l}).\]
 As this multiplicity is a non-negative integer, we have the constraints 
\[\mu_l(u,\chi) \in \mathbb{Z}_{\geq 0}\]
 for all ordinary characters $\chi$ and all $l$. This formula was given by I.S. Luthar and I.B.S. Passi \cite{LP}. 

 Later M. Hertweck showed that it may also be used for a representation over a
field of characteristic $p > 0$ with character $\varphi$, if $p$ is coprime to $k$ \cite{HertweckBrauer}, {\S} 4. In that case one has to ignore the $p$-singular conjugacy classes (i.e. the classes of elements with an order
divisible by $p$) and the above formula becomes 
\[ \mu_l(u,\varphi) = \frac{1}{k} \sum_{1 \not= d \mid k}
{\rm{Tr}}_{\mathbb{Q}(\zeta^d)/\mathbb{Q}}(\varphi(u^d)\zeta^{-dl}) +
\frac{1}{k} \sum_{x^G,\ p \nmid o(x)} \varepsilon_x(u)
{\rm{Tr}}_{\mathbb{Q}(\zeta)/\mathbb{Q}}(\varphi(x)\zeta^{-l}).\]
 Again, as this multiplicity is a non-negative integer, we have the constraints 
\[\mu_l(u,\varphi) \in \mathbb{Z}_{\geq 0}\]
 for all Brauer characters $\varphi$ and all $l$. 

 These equations allow to build a system of integral inequalities for the
partial augmentations of $u$. Solving these inequalities is exactly what the HeLP method does to obtain
restrictions on the possible values of the partial augmentations of $u$. Note that some of the $\varepsilon_x(u)$ are a priori zero by the results in the above sections. 

 For $p$-solvable groups representations over fields of characteristic $p$ can not give any new information compared to ordinary representations by the
Fong-Swan-Rukolaine Theorem \cite{CR1}, Theorem 22.1. }

 
\section{\textcolor{Chapter }{The Wagner test}}\label{Chapter_Background_Section_The_Wagner_test}
\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X7BA77C9F86ADD546}{}
{
  We also included a result motivated by a theorem R. Wagner proved 1995 in his
Diplomarbeit \cite{Wa}. This result gives a further restriction on the partial augmentations of
torsion units. We included it into the functions \texttt{HeLP{\textunderscore}ZC} (\ref{HeLPZC}), \texttt{HeLP{\textunderscore}PQ} (\ref{HeLPPQ}), \texttt{HeLP{\textunderscore}AllOrders} (\ref{HeLPAllOrders}), \texttt{HeLP{\textunderscore}AllOrdersPQ} (\ref{HeLPAllOrdersPQ}) and \texttt{HeLP{\textunderscore}WagnerTest} (\ref{HeLPWagnerTest}) and call it "Wagner test". 

 \emph{Theorem:} For a torsion unit $u \in \mathrm{V}(\mathbb{Z}G)$, a group element $s$, a prime $p$ and a natural number $j$ we have 
\[ \sum\limits_{x^{p^j} \sim s} \varepsilon_x(u) \equiv \varepsilon_s(u^{p^j}) \
\ \ {\rm{mod}} \ \ p. \]
 Combining the Theorem with the HeLP-method may only give new insight, if $p^j$ is a proper divisor of the order of $u$. Wagner did obtain this result for $s = 1$, when $\varepsilon_s(u) = 0$ by the Berman-Higman Theorem. In the case that $u$ is of prime power order this is a result of J.A. Cohn and D. Livingstone \cite{CohnLivingstone}. }

 
\section{\textcolor{Chapter }{s-constant (and (s,t)-constant) characters}}\label{Chapter_Background_Section_s-constant_(and_(s,t)-constant)_characters}
\logpage{[ 5, 5, 0 ]}
\hyperdef{L}{X811E2B358243C44F}{}
{
  If one is interested in units of mixed order $s*t$ for two primes $s$ and $t$ (e.g. if one is studying the Prime Graph Question) an idea to make the HeLP
method more efficient was introduced by V. Bovdi and A. Konovalov in \cite{BKHS}, page 4. Assume one has several conjugacy classes of elements of order $s$, and a character taking the same value on all of these classes. Then the
coefficient of every of these conjugacy classes in the system of inequalities
of this character, which is obtained via the HeLP method, is the same. Also
the constant terms of the inequalities do not depend on the partial
augmentations of elements of order $s$. Thus for such characters one can reduce the number of variables in the
inequalities by replacing all the partial augmentations on classes of elements
of order $s$ by their sum. To obtain the formulas for the multiplicities of the HeLP method
one does not need the partial augmentations of elements of order $s$. Characters having the above property are called $s$-constant. In this way the existence of elements of order $s*t$ can be excluded in a quite efficient way without doing calculations for
elements of order $s$. 

 There is also the concept of $(s,t)$-constant characters, being constant on both, the conjugacy classes of
elements of order $s$ and on the conjugacy classes of elements of order $t$. The implementation of this is however not yet part of this package. }

 
\section{\textcolor{Chapter }{Known results about (ZC) and (PQ)}}\label{Chapter_Background_Section_Known_results_about_(ZC)_and_(PQ)}
\logpage{[ 5, 6, 0 ]}
\hyperdef{L}{X811213427F4177C8}{}
{
  At the moment as this documentation was written, to the best of our knowledge,
the following results were available for the Zassenhaus Conjecture and the
Prime Graph Question: 

 For the Zassenhaus Conjecture only the following reduction is available: 



 \emph{Theorem:} Assume the Zassenhaus Conjecture holds for a group $G$. Then (ZC) holds for $G \times C_2$ \cite{HoefertKimmerle}, Corollary 3.3, and $G \times \Pi$, where $\Pi$ denotes a nilpotent group of order prime to the order of $G$ \cite{HertweckEdinb}, Proposition 8.1.

 With this reductions in mind the Zassenhaus Conjecture is known for: 
\begin{itemize}
\item  Nilpotent groups \cite{Weiss91}, 
\item  Cyclic-By-Abelian groups \cite{CyclicByAbelian}, 
\item  Groups containing a normal Sylow subgroup with abelian complement \cite{HertweckColloq}, 
\item  Frobenius groups whose order is divisible by at most two different primes \cite{JuriaansMilies}, 
\item  Groups $X \rtimes A$, where $X$ is abelian, $A$ elementary abelian and $A$ acts faithfully and irreducibly on $X$ \cite{SehgalWeiss}, 
\item  Groups $X \rtimes A$, where $X$ and $A$ are abelian and $A$ is of prime order $p$ such that $p$ is smaller then any prime divisor of the order of $X$ \cite{MRSW}, 
\item  All groups of order up to 159 and some other groups of order up to 200 listed
in \cite{HermanSingh}, 
\item  The non-abelian simple groups $A_5$ \cite{LP}, $A_6 \simeq PSL(2,9)$ \cite{HerA6}, $PSL(2,7)$, $PSL(2,11)$, $PSL(2,13)$ \cite{HertweckBrauer}, $PSL(2,8)$, $PSL(2,17)$ \cite{KonovalovKimmiStAndrews} / \cite{Gildea}, $PSL(2,19)$, $PSL(2,23)$ \cite{BaMaM10} and some extensions of these groups. 
\end{itemize}
 For the Prime Graph Question the following strong reduction was obtained in \cite{KonovalovKimmiStAndrews}: 

 \emph{Theorem:} Assume the Prime Graph Question holds for all almost simple images of a group $G$. Then (PQ) also holds for $G.$

 Here a group $G$ is called almost simple, if it is sandwiched between the inner automorphism
group and the whole automorphism group of a non-abelian simple group $S$. I.e. $Inn(S) \leq G \leq Aut(S).$ Keeping this reduction in mind (PQ) is known for: 
\begin{itemize}
\item  Solvable groups \cite{KimmiPQ}, 
\item  The groups $PSL(2,p)$ where $p$ denotes a prime \cite{HertweckBrauer}, 
\item  Half of the sporadic simple groups and their automorphism groups, for an
overview see \cite{KonovalovKimmiStAndrews}, 
\item  The groups $A_7, A_8$ \cite{SalimA7A8}, $A_9, A_{10}$ \cite{SalimA9A10}, 
\item  Almost simple groups whose order is divisible by at most three different
primes \cite{KonovalovKimmiStAndrews} and \cite{BaMaM10}. (This implies that it holds for all groups with an order divisible by at
most three primes, using the reduction result above.) 
\end{itemize}
 }

 }

   
\chapter{\textcolor{Chapter }{Remarks on technical problems and the implementation}}\label{Chapter_Remarks_on_technical_problems_and_the_implementation}
\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X7B53A54C823744E9}{}
{
  
\section{\textcolor{Chapter }{Making the HeLP-package run}}\label{Chapter_Remarks_on_technical_problems_and_the_implementation_Section_Making_the_HeLP-package_run}
\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X7FBC46BC7A5D28AF}{}
{
  A checklist what to do, if the package does not work: 
\begin{itemize}
\item  Make sure you have sufficiently new versions of the following software: 
\begin{itemize}
\item  \href{http://www.gap-system.org/} {GAP} (at least 4.7.4) 
\item  the GAP-package \href{http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib/} {CTblLib} (at least 1.2.2) 
\item  the GAP-package \href{http://gap-system.github.io/io/} {IO} (at least 4.2; see also the next bullet point if this package can not be
loaded) 
\item  the GAP-package \href{http://wwwb.math.rwth-aachen.de/~gutsche/gap_packages/4ti2Interface/} {4ti2Interface} (at least 2015.04.29; this package needs the IO-package) 

 Usually all these packages should come with a sufficently recent
GAP-installation (4.7.8 or newer) and should be contained in the pkg-folder of
the GAP-installation. To see if they are working you can load them by typing \texttt{LoadPackage("[name]");} after starting GAP, where \texttt{[name]} is the name of the package. 
\end{itemize}
 
\item  The IO-package needs a C-part to be compiled. To see if this has already been
done on your system, you can enter \texttt{LoadPackage("IO");} after starting GAP. If the result is \texttt{fail} and the package is contained in the pkg-folder, than most likely the C-part is
not yet compiled. For information on installation and in particular on how to
compile the C-part, see the \href{http://gap-system.github.io/io/doc/chap0.html} {manual} (in particular Chapter 2) or the README-file of that package.

 
\item  Please make sure that \href{http://www.4ti2.de} {www.4ti2.de} (Version 1.6.5 or newer) is installed. In case of an error-message "The
executable 'zsolve' provided by the software 4ti2 was not found." after typing \texttt{LoadPackage("HeLP");} either the software is not properly installed or installed in a directory
where GAP can not find it, i.e. a directory not contained in the
path-variable. The content of this variable can typically be displayed by
typing \texttt{echo \$PATH} (Linux, Mac) \texttt{echo \%PATH\%} (Windows) in a terminal or a command prompt. The manual of 4ti2 contains
several pages of information on how to install the program. Note that the
installation of 4ti2 requires gcc (g++) and gmp installed (which come with
many Linux installations or can be installed using a package manager). Make
sure to execute all four commands indicated in the 4ti2 manual (possibly
without the \texttt{--prefix=}-command):

 \texttt{./configure --prefix=INSTALLATION-DIRECTORY}

 \texttt{make}

 \texttt{make check}

 \texttt{make install-exec}

 Depending on the settings of your system you might need root privileges (type \texttt{sudo} in front of every command) to unpack the files and install them. To check
whether the installation worked, you can enter \texttt{zsolve} in a terminal. In case one of the required programs (g++ or gmp) was not
installed when running \texttt{make} for the first time, you might need to run \texttt{make clean} and the above commands several times to complie 4ti2 succesfully. If you
already have 4ti2 installed in a directory not contained in the path-variable
and want to avoid a re-installation, in many cases the following helps: 
\begin{itemize}
\item  Start a terminal and access a path written in your bash or
system{\textunderscore}bash. Typically \texttt{usr/local/bin} should work. 

 
\item  Run \texttt{ln -s /[PathToZsolve] zsolve}, where \texttt{[PathToZsolve]} is the path to the executable zsolve. This sets a symlink to the right place.
E.g. \texttt{ln -s /opt/4ti2/bin/zsolve zsolve} was used on the (Linux) computers in Stuttgart. 
\end{itemize}
 
\item  We also recommend to install \href{http://cgm.cs.mcgill.ca/~avis/C/lrs.html} {lrslib}, at least version 4.3 (note that version 4.2 or older sometimes produces
unwanted behavior). This software provides the 'redund' command, which can be
switched on and off within HeLP, but which often leads to better performances
(cf. \texttt{HeLP{\textunderscore}UseRedund} (\ref{HeLPUseRedund})). For installation see the User's Guide or the Readme-file on the above
mentioned homepage. Usually, after unpacking in a directory contained in the
path-variable it should be enough to call

 \texttt{make all}

 (possibly as root) inside the lrslib-directory. 
\item  In case this does not help to get HeLP running, please feel more than welcome
to contact one of the maintainers of the package. 
\end{itemize}
 }

 
\section{\textcolor{Chapter }{Computations with big coefficients - precision problems}}\label{Chapter_Remarks_on_technical_problems_and_the_implementation_Section_Computations_with_big_coefficients_-_precision_problems}
\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X802D13E67EADCD32}{}
{
  When using 4ti2, HeLP calls it per default with a maximum precision of 32bit.
In case one gets error messages stating that the results of the calculations
were near the maximum precision, the used precision can be influenced by using \texttt{HeLP{\textunderscore}Change4ti2Precision} (\ref{HeLPChange4ti2Precision}). For groups with a "reasonable" order there should be no problems with the
precision. }

 
\section{\textcolor{Chapter }{How much 4ti2 is really there?}}\label{Chapter_Remarks_on_technical_problems_and_the_implementation_Section_How_much_4ti2_is_really_there?}
\logpage{[ 6, 3, 0 ]}
\hyperdef{L}{X7CACE0767DA99250}{}
{
  The reason, why the program 4ti2 is used in this package, is basically that it
can solve systems of linear inequalities efficently and there exists a good
GAP-Interface to it. However there is only one line of code where a function
is called which accesses 4ti2. Thus the effort of using another solver of
inequalities would be not so big, if there is a GAP-Interface for it. If you
are aware of such a solver and would like to use it in this package, please
contact the authors of this package. We will be happy to help. }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{HeLP.bib}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
