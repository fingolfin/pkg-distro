#############################################################################
##
#W  io.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="PlainTextDecoders">
<ManSection>
  <Func Name="TournamentLineDecoder" Arg="digraph"/>
  <Func Name="AdjacencyMatrixUpperTriangleLineDecoder" Arg="digraph"/>
  <Func Name="TCodeDecoder" Arg="digraph"/>
  <Returns></Returns>
  <Description>
    <Example><![CDATA[
]]></Example>
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphFromGraph6String">
<ManSection>
  <Oper Name="DigraphFromGraph6String" Arg="str"/>
  <Oper Name="DigraphFromDigraph6String" Arg="str"/>
  <Oper Name="DigraphFromSparse6String" Arg="str"/>
  <Oper Name="DigraphFromDiSparse6String" Arg="str"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>str</A> is a string encoding a graph in Graph6, Digraph6, Sparse6 or
    DiSparse6 format, then the corresponging function returns a digraph. In the
    case of either Graph6 or Sparse6, formats which do not support directed
    edges, this will be a digraph such that for every edge, the edge going in
    the opposite direction is also present.
    <Example><![CDATA[
gap> DigraphFromGraph6String("?");
<digraph with 0 vertices, 0 edges>
gap> DigraphFromGraph6String("C]");
<digraph with 4 vertices, 8 edges>
gap> DigraphFromGraph6String("H?AAEM{");
<digraph with 9 vertices, 22 edges>
gap> DigraphFromDigraph6String("+?");
<digraph with 0 vertices, 0 edges>
gap> DigraphFromDigraph6String("+CQFG");
<digraph with 4 vertices, 6 edges>
gap> DigraphFromDigraph6String("+IM[SrKLc~lhesbU[F_");
<digraph with 10 vertices, 51 edges>
gap> DigraphFromDiSparse6String(".CaWBGA?b");
<multidigraph with 4 vertices, 9 edges>
]]></Example>
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ReadDigraphs">
<ManSection>
  <Func Name="ReadDigraphs" Arg="filename[, decoder][, n]"/>
  <Returns>A digraph, or a list of digraphs.</Returns>
  <Description>
    If <A>filename</A> is the name of a file containing encoded digraphs
    (with one digraph per line),
    then <C>ReadDigraphs</C> returns these digraphs as a list.
    Note that if <A>filename</A> is a compressed file, which has been
    compressed appropriately to give a filename extension of
    <C>.gz</C>, <C>.bzip2</C>, or <C>.xz</C>,
    then <C>ReadDigraphs</C> can read <A>filename</A> without it first
    needing to be decompressed.
    <P/>

    If the optional argument <A>n</A> is specified, then <C>ReadDigraphs</C>
    returns the digraph from the <A>n</A>th line of the file
    <A>filename</A>.<P/>

    If the optional argument <A>decoder</A> is specified
    and is a function which decodes a string into a digraph,
    then <C>ReadDigraphs</C> will use <A>decoder</A> to decode the digraphs
    contained in <A>filename</A>.

    If the optional argument <A>decoder</A> is not specified,
    then <C>ReadDigraphs</C> will deduce which format to use based on the
    filename extension of <A>filename</A>
    (after removing the compression-related filename extensions
    <C>.gz</C>, <C>.bzip2</C>, and <C>.xz</C>).
    For example, if the filename extension if <C>.g6</C>,
    then <C>ReadDigraphs</C> will use the graph6 decoder.
    <P/>

    The currently supported file formats, and associated filename extensions,
    are:
    <List>
      <Mark>graph6 (.g6)</Mark>
      <Item>
	A standard and widely-used format for undirected graphs, with no support
	for loops or multiple edges.  Only symmetric graphs are allowed -- each
	edge is combined with its converse edge to produce a single undirected
	edge.  This format is best used for "dense" graphs -- those with many
	edges per vertex.
      </Item>
      <Mark>sparse6 (.s6)</Mark>
      <Item>
	Unlike graph6, sparse6 has support for loops and multiple edges.
	However, its use is still limited to symmetric graphs.  This format is
	better-suited to "sparse" graphs -- those with few edges per vertex.
      </Item>
      <Mark>digraph6 (.d6)</Mark>
      <Item>
	This format is based on graph6, but stores direction information -
	therefore is not limited to symmetric graphs.  Loops are allowed, but
	multiple edges are not.  Best compression with "dense" graphs.
      </Item>
      <Mark>disparse6 (.ds6)</Mark>
      <Item>
	Any type of digraph can be encoded in disparse6: directions, loops, and
	multiple edges are all allowed.  Similar to sparse6, this has the best
	compression rate with "sparse" graphs.
      </Item>
      <Mark>plain text (.txt)</Mark>
      <Item>
	This is a human-readable format which stores graphs in the form
        <C>0 7  0 8  1 7  2 8  3 8  4 8  5 8  6 8</C> i.e. pairs of vertices
        describing edges in a graph. More specifically, the vertices making up
        one edge must be separated by a single space, and pairs of vertices must
        be separated by two spaces. <P/>

        See <Ref Func="ReadPlainTextDigraph"/> for a more flexible way to store
        digraphs in a plain text file. <P/>
<!--
        Just so I remember:
        <C>ReadPlainTextDigraph("data-local/soc-Epinions1.txt.gz", "\t", 1, '#');</C>
-->
      </Item>
      
      <Mark>pickled (<F>.p</F> or <F>.pickle</F>)</Mark>
      <Item>
        Digraphs are pickled using the &IO; package. This is particularly good
        when the <Ref Attr="DigraphGroup"/> is non-trivial.
      </Item>
    </List>
    
    <Example><![CDATA[
gap> ReadDigraphs(
> Concatenation(DIGRAPHS_Dir(), "/data/graph5.g6.gz"), 10);
<digraph with 5 vertices, 8 edges>
gap> ReadDigraphs(
> Concatenation(DIGRAPHS_Dir(), "/data/graph5.g6.gz"), 17);
<digraph with 5 vertices, 12 edges>
gap> ReadDigraphs(
> Concatenation(DIGRAPHS_Dir(), "/data/tree9.4.txt"));
[ <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges>, 
  <digraph with 9 vertices, 8 edges> ]]]></Example>
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="WriteDigraphs">
<ManSection>
  <Func Name="WriteDigraphs" Arg="filename, digraphs"/>
  <Description>
    If <A>digraphs</A> is a list of digraphs, then <C>WriteDigraphs</C> writes
    its contents to a file in a compact format.  If the supplied filename ends
    in one of the extensions <C>.gz</C>, <C>.bzip2</C>, or <C>.xz</C>, the file
    will be compressed appropriately.  Excluding these extensions, if the file
    ends with an extension in the list below, the corresponding graph format
    will be used to encode it.  If such an extension is not included, an
    appropriate format will be chosen intelligently, and an extension appended,
    to minimise file length.<P/>

    For more verbose information on the progress of the function, set the info
    level of <A>InfoDigraphs</A> to 1 or higher, using <C>SetInfoLevel</C>.<P/>

    The currently supported file formats are:
    <List>
      <Mark>graph6 (.g6)</Mark>
      <Item>
	A standard and widely-used format for undirected graphs, with no support
	for loops or multiple edges.  Only symmetric graphs are allowed -- each
	edge is combined with its converse edge to produce a single undirected
	edge.  This format is best used for "dense" graphs -- those with many
	edges per vertex.
      </Item>
      <Mark>sparse6 (.s6)</Mark>
      <Item>
	Unlike graph6, sparse6 has support for loops and multiple edges.
	However, its use is still limited to symmetric graphs.  This format is
	better-suited to "sparse" graphs -- those with few edges per vertex.
      </Item>
      <Mark>digraph6 (.d6)</Mark>
      <Item>
	This format is based on graph6, but stores direction information -
	therefore is not limited to symmetric graphs.  Loops are allowed, but
	multiple edges are not.  Best compression with "dense" graphs.
      </Item>
      <Mark>disparse6 (.ds6)</Mark>
      <Item>
	Any type of digraph can be encoded in disparse6: directions, loops, and
	multiple edges are all allowed.  Similar to sparse6, this has the best
	compression rate with "sparse" graphs.
      </Item>

      <Mark>plain text (.txt)</Mark>
      <Item>
	This is a human-readable format which stores graphs in the form
        <C>0 7  0 8  1 7  2 8  3 8  4 8  5 8  6 8</C> i.e. pairs of vertices
        describing edges in a graph. More specifically, the vertices making up
        one edge must be separated by a single space, and pairs of vertices must
        be separated by two spaces. <P/>

        See <Ref Func="ReadPlainTextDigraph"/> for a more flexible way to store
        digraphs in a plain text file. <P/>
<!--
        Just so I remember:
        <C>ReadPlainTextDigraph("data-local/soc-Epinions1.txt.gz", "\t", 1, '#');</C>
-->
      </Item>
      <Mark>pickled (<F>.p</F> or <F>.pickle</F>)</Mark>
      <Item>
        Digraphs are pickled using the &IO; package. This is particularly good
        when the <Ref Attr="DigraphGroup"/> is non-trivial.
      </Item>
    </List>
    
    <Example><![CDATA[
gap> grs := [];;
gap> grs[1] := Digraph([]);
<digraph with 0 vertices, 0 edges>
gap> grs[2] := Digraph([[1, 3], [2], [1, 2]]);
<digraph with 3 vertices, 5 edges>
gap> grs[3] := Digraph([[6, 7], [6, 9], [1, 3, 4, 5, 8, 9],
> [1, 2, 3, 4, 5, 6, 7, 10], [1, 5, 6, 7, 10], [2, 4, 5, 9, 10],
> [3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7, 8, 9], [1, 2, 5],
> [1, 2, 4, 6, 7, 8]]);
<digraph with 10 vertices, 51 edges>
gap> filename := Concatenation(DIGRAPHS_Dir(), "/tst/out/man.d6.gz");;
gap> WriteDigraphs(filename, grs, "w");
gap> ReadDigraphs(filename);
[ <digraph with 0 vertices, 0 edges>, 
  <digraph with 3 vertices, 5 edges>, 
  <digraph with 10 vertices, 51 edges> ]]]></Example>
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Graph6String">
<ManSection>
  <Oper Name="Graph6String" Arg="digraph"/>
  <Oper Name="Digraph6String" Arg="digraph"/>
  <Oper Name="Sparse6String" Arg="digraph"/>
  <Oper Name="DiSparse6String" Arg="digraph"/>
  <Returns>A string.</Returns>
  <Description>
    These four functions return a highly compressed string fully describing the
    digraph <A>digraph</A>. <P/>

    Graph6 and Digraph6 are formats best used on small, dense graphs, if
    applicable. For larger, sparse graphs use <E>Sparse6</E> and
    <E>Disparse6</E> (this latter also preserves multiple edges). <P/>

    See <Ref Oper="WriteDigraphs"/>.
    <Example><![CDATA[
gap> gr := Digraph([[2,3], [1], [1]]);
<digraph with 3 vertices, 4 edges>
gap> Sparse6String(gr);
":Bc"
gap> DiSparse6String(gr);
".Bc{f"
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphPlainTextLineEncoder">
<ManSection>
  <Func Name="DigraphPlainTextLineEncoder" Arg="delimiter1, [delimiter2,] offset"/>
  <Func Name="DigraphPlainTextLineDecoder" Arg="delimiter1, [delimiter2,] offset"/>
  <Returns>A string.</Returns>
  <Description>
    These two functions return a function which encodes or decodes a digraph in
    a plain text format.<P/>

    <A>DigraphPlainTextLineEncoder</A> returns a function which takes a single
    digraph as an argument.  The function returns a string describing the edges
    of that digraph; each edge is written as a pair of integers separated by the
    string <A>delimiter2</A>, and the edges themselves are separated by the
    string <A>delimiter1</A>.  <A>DigraphPlainTextLineDecoder</A> returns the
    corresponding decoder function, which takes a string argument in this format
    and returns a digraph.<P/>

    If only one delimiter is passed as an argument to
    <A>DigraphPlainTextLineDecoder</A>, it will return a function which decodes
    a single edge, returning its contents as a list of integers.<P/>

    The argument <A>offset</A> should be an integer, which will describe a
    number to be added to each vertex before it is encoded, or after it is
    decoded.  This may be used, for example, to label vertices starting at 0
    instead of 1.<P/>

    Note that the number of vertices of a digraph is not stored, and so vertices
    which are not connected to any edge may be lost.

    <Example><![CDATA[
gap> gr := Digraph([[2,3], [1], [1]]);
<digraph with 3 vertices, 4 edges>
gap> enc := DigraphPlainTextLineEncoder("  ", " ", -1);;
gap> dec := DigraphPlainTextLineDecoder("  ", " ",  1);;
gap> enc(gr);
"0 1  0 2  1 0  2 0"
gap> dec(last);
<digraph with 3 vertices, 4 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="PlainTextString">
<ManSection>
  <Oper Name="PlainTextString" Arg="digraph"/>
  <Oper Name="DigraphFromPlainTextString" Arg="s"/>
  <Returns>A string.</Returns>
  <Description>
    <A>PlainTextString</A> takes a single digraph, and returns a string
    describing the edges of that digraph.  <A>DigraphFromPlainTextString</A>
    takes such a string and returns the digraph which it describes.  Each edge
    is written as a pair of integers separated by a single space.  The edges
    themselves are separated by a double space.  Vertex numbers are reduced by
    1 when they are encoded, so that vertices in the string are labelled
    starting at 0.<P/>

    Note that the number of vertices of a digraph is not stored, and so vertices
    which are not connected to any edge may be lost.

    <Example><![CDATA[
gap> gr := Digraph([[2,3], [1], [1]]);
<digraph with 3 vertices, 4 edges>
gap> PlainTextString(gr);
"0 1  0 2  1 0  2 0"
gap> DigraphFromPlainTextString(last);
<digraph with 3 vertices, 4 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="WritePlainTextDigraph">
<ManSection>
  <Func Name="WritePlainTextDigraph" Arg="filename, digraph, delimiter, offset"/>
  <Func Name="ReadPlainTextDigraph" Arg="filename, delimiter, offset, ignore"/>
  <Description>
    These functions write and read a single digraph in a human-readable plain
    text format as follows: each line contains a single edge, and each edge is
    written as a pair of integers separated by the string <A>delimiter</A>.<P/>

    <A>filename</A> should be the name of a file which will be written to or
    read from, and <A>offset</A> should be an integer which is added to each
    vertex number as it is written or read.  For example, if
    <C>WritePlainTextDigraph</C> is called with <A>offset</A> <C>-1</C>, then
    the vertices will be numbered in the file starting from 0 instead of 1 -
    <C>ReadPlainTextDigraph</C> would then need to be called with <A>offset</A>
    <C>1</C> to convert back to the original graph.<P/>

    <A>ignore</A> should be a list of characters which will be ignored when
    reading the graph.
    <Example><![CDATA[
gap> gr := Digraph([[1,2,3], [1,1], [2]]);
<multidigraph with 3 vertices, 6 edges>
gap> filename := Concatenation(DIGRAPHS_Dir(), "/tst/out/plain.txt");;
gap> WritePlainTextDigraph(filename, gr, ",", -1);
gap> ReadPlainTextDigraph(filename, ",", 1, ['/','%']);
<multidigraph with 3 vertices, 6 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="TournamentLineDecoder">
<ManSection>
  <Func Name="TournamentLineDecoder" Arg="str"/>
  <Returns>A digraph.</Returns>
  <Description>
    This function takes a string <A>str</A>, decodes it, and then returns the
    tournament [see <Ref Prop="IsTournament"/>] which it defines, according to
    the following rules. <P/>

    The characters of the string <A>str</A> represent the entries in the upper
    triangle of a tournament's adjacency matrix. The number of vertices
    <C>n</C> will be detected from the length of the string and will be as
    large as possible.  <P/>

    The first character represents the possible edge <C>1 -> 2</C>, the second
    represents <C>1 -> 3</C> and so on until <C>1 -> n</C>; then the following
    character represents <C>2 -> 3</C>, and so on up to the character which
    represents the edge <C>n-1 -> n</C>. <P/>

    If a character of the string with corresponding edge <C>i -> j</C> is equal
    to <C>1</C>, then the edge <C>i -> j</C> is present in the tournament.
    Otherwise, the edge <C>i -> j</C> is present instead.  In this way, all the
    possible edges are encoded one-by-one.

    <Example><![CDATA[
gap> gr := TournamentLineDecoder("100001");
<digraph with 4 vertices, 6 edges>
gap> OutNeighbours(gr);
[ [ 2 ], [  ], [ 1, 2, 4 ], [ 1, 2 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="AdjacencyMatrixUpperTriangleLineDecoder">
<ManSection>
  <Func Name="AdjacencyMatrixUpperTriangleLineDecoder" Arg="str"/>
  <Returns>A digraph.</Returns>
  <Description>
    This function takes a string <A>str</A>, decodes it, and then returns the
    topologically sorted digraph [see <Ref Prop="DigraphTopologicalSort"/>]
    which it defines, according to the following rules. <P/>

    The characters of the string <A>str</A> represent the entries in the upper
    triangle of a digraph's adjacency matrix. The number of vertices <C>n</C>
    will be detected from the length of the string and will be as large as
    possible.  <P/>

    The first character represents the possible edge <C>1 -> 2</C>, the second
    represents <C>1 -> 3</C> and so on until <C>1 -> n</C>; then the following
    character represents <C>2 -> 3</C>, and so on up to the character which
    represents the edge <C>n-1 -> n</C>.  If a character of the string with
    corresponding edge <C>i -> j</C> is equal to <C>1</C>, then this edge is
    present in the digraph. Otherwise, it is not present.  In this way, all the
    possible edges are encoded one-by-one. <P/>

    In particular, note that there exists no edge <C>[i, j]</C> if <M>j \leq
      i</M>.  In order words, the digraph will be topologically sorted.

    <Example><![CDATA[
gap> gr := AdjacencyMatrixUpperTriangleLineDecoder("100001");
<digraph with 4 vertices, 2 edges>
gap> OutNeighbours(gr);
[ [ 2 ], [  ], [ 4 ], [  ] ]
gap> gr := AdjacencyMatrixUpperTriangleLineDecoder("111111x111");
<digraph with 5 vertices, 9 edges>
gap> OutNeighbours(gr);
[ [ 2, 3, 4, 5 ], [ 3, 4 ], [ 4, 5 ], [ 5 ], [  ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="TCodeDecoder">
<ManSection>
  <Func Name="TCodeDecoder" Arg="str"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>str</A> is a string consisting of at least two non-negative integers
    separated by spaces, then this function will attempt to return the digraph
    which it defines as a TCode string. <P/>

    The first integer of the string defines the number of vertices <C>v</C> in
    the digraph, and the second defines the number of edges <C>e</C>.  The
    following <C>2e</C> integers should be vertex numbers in the range <C>[0 ..
      v-1]</C>. These integers are read in pairs and define the digraph's
    edges.  This function will return an error if <A>str</A> has fewer than
    <C>2e+2</C> entries. <P/>

    Note that the vertex numbers will be incremented by 1 in the digraph
    returned.  Hence the string fragment <C>0 6</C> will describe the edge
    <C>[1,7]</C>.
    <Example><![CDATA[
gap> gr := TCodeDecoder("3 2 0 2 2 1");
<digraph with 3 vertices, 2 edges>
gap> OutNeighbours(gr);
[ [ 3 ], [  ], [ 2 ] ]
gap> gr := TCodeDecoder("12 3 0 10 5 2 8 8");
<digraph with 12 vertices, 3 edges>
gap> OutNeighbours(gr);
[ [ 11 ], [  ], [  ], [  ], [  ], [ 3 ], [  ], [  ], [ 9 ], [  ], 
  [  ], [  ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
