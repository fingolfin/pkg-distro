% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{  \textsf{GUAVA} \mbox{}}}\\
\vfill

\hypersetup{pdftitle=  \textsf{GUAVA} }
\markright{\scriptsize \mbox{}\hfill   \textsf{GUAVA}  \hfill\mbox{}}
{\Huge \textbf{  A \textsf{GAP}4 Package for computing with error-correcting codes {\nobreakspace} \mbox{}}}\\
\vfill

{\Huge Version 3.13\mbox{}}\\[1cm]
{January 31, 2016\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Jasper Cramwinckel \mbox{}}}\\
{\Large \textbf{ Erik Roijackers \mbox{}}}\\
{\Large \textbf{ Reinald Baart \mbox{}}}\\
{\Large \textbf{ Eric Minkes \mbox{}}}\\
{\Large \textbf{ Lea Ruscio \mbox{}}}\\
{\Large \textbf{ Robert L Miller \mbox{}}}\\
{\Large \textbf{ Tom Boothby \mbox{}}}\\
{\Large \textbf{ Cen (``CJ'') Tjhai \mbox{}}}\\
{\Large \textbf{ David Joyner   \mbox{}}}\\
{\Large \textbf{ Joe Fields (Maintainer)    \mbox{}}}\\
\hypersetup{pdfauthor= Jasper Cramwinckel ;  Erik Roijackers ;  Reinald Baart ;  Eric Minkes ;  Lea Ruscio ;  Robert L Miller ;  Tom Boothby ;  Cen (``CJ'') Tjhai ;  David Joyner   ;  Joe Fields (Maintainer)    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Joe Fields (Maintainer)    }  Email: \href{mailto://fieldsj1@southernct.edu} {\texttt{fieldsj1@southernct.edu}}\\
  Homepage: \href{http://osj1961.github.io/guava/} {\texttt{http://osj1961.github.io/guava/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Mathematics Department,\\
 Southern Connecticut State University,\\
 New Haven, CT,\\
 06515 USA. \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
  \textsf{GUAVA}: {\copyright} The GUAVA Group: 1992-2003 Jasper Cramwinckel, Erik
Roijackers,Reinald Baart, Eric Minkes, Lea Ruscio (for the tex version),
Jeffrey Leon {\copyright} 2004 David Joyner, Cen Tjhai, Jasper Cramwinckel,
Erik Roijackers, Reinald Baart, Eric Minkes, Lea Ruscio. {\copyright} 2007
Robert L Miller, Tom Boothby {\copyright} 2009, 2012, 2016 Joe Fields 

 \textsf{GUAVA} is released under the GNU General Public License (GPL). 

 \textsf{GUAVA} is free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version. 

 \textsf{GUAVA} is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details. 

 You should have received a copy of the GNU General Public License along with \textsf{GUAVA}; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite
330, Boston, MA 02111-1307 USA 

 For more details, see \href{http://www.fsf.org/licenses/gpl.html} {\texttt{http://www.fsf.org/licenses/gpl.html}}. 

 For many years \textsf{GUAVA} has been released along with the ``backtracking'' C programs of J. Leon. In
one of his *.c files the following statements occur: ``Copyright (C) 1992 by
Jeffrey S. Leon. This software may be used freely for educational and research
purposes. Any other use requires permission from the author.'' The following
should now be appended: ``I, Jeffrey S. Leon, agree to license all the
partition backtrack code which I have written under the GPL (www.fsf.org) as
of this date, April 17, 2007.'' 

 \textsf{GUAVA} documentation: {\copyright} Jasper Cramwinckel, Erik Roijackers, Reinald
Baart, Eric Minkes, Lea Ruscio (for the tex version), Joe Fields, David
Joyner, Cen Tjhai. Permission is granted to copy, distribute and/or modify
this document under the terms of the GNU Free Documentation License, Version
1.2 or any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of
the license is included in the section entitled "GNU Free Documentation
License". \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 2 ]}
  

 \textsf{GUAVA} was originally written by Jasper Cramwinckel, Erik Roijackers, and Reinald
Baart in the early-to-mid 1990's as a final project during their study of
Mathematics at the Delft University of Technology, Department of Pure
Mathematics, under the direction of Professor Juriaan Simonis. This work was
continued in Aachen, at Lehrstuhl D fur Mathematik. In version 1.3, new
functions were added by Eric Minkes, also from Delft University of Technology. 

 JC, ER and RB would like to thank the GAP people at the RWTH Aachen for their
support, A.E. Brouwer for his advice and J. Simonis for his supervision. 

 The GAP 4 version of \textsf{GUAVA} (versions 1.4 and 1.5) was created by Lea Ruscio and (from 2001, starting with
version 1.6, to early 2009) was maintained by David Joyner, who (with the help
of several students) added several new functions. Starting with version 2.7,
the ``best linear code'' tables for binary codes have been updated. From 2009,
starting with version 3.10, \textsf{GUAVA} has been maintained by Joe Fields. For further details, see the CHANGES file
in the \textsf{GUAVA} directory, also available at \href{http://osj1961.github.io/guava/CHANGES.guava} {\texttt{http://osj1961.github.io/guava/CHANGES.guava}}. 

 

This documentation was prepared with the \textsf{GAPDoc} package of Frank L{\"u}beck and Max Neunh{\"o}ffer. The conversion from TeX to \textsf{GAPDoc}'s XML was done by David Joyner in 2004. 

 Please send bug reports, suggestions and other comments about \textsf{GUAVA} to \href{mailto://support@gap-system.org} {\texttt{support@gap-system.org}}. Currently known bugs and suggested \textsf{GUAVA} projects are listed on the bugs and projects web page \href{http://osj1961.github.io/guava/guava2do.html} {\texttt{http://osj1961.github.io/guava/guava2do.html}}. Older releases and further history can be found on the \textsf{GUAVA} web page \href{http://osj1961.github.io/guava/} {\texttt{http://osj1961.github.io/guava/}}. 

 \emph{Contributors}: Other than the authors listed on the title page, the following people have
contributed code to the \textsf{GUAVA} project: Alexander Hulpke, Steve Linton, Frank L{\"u}beck, Aron Foster, Wayne
Irons, Clifton (Clipper) Lennon, Jason McGowan, Shuhong Gao, Greg Gamble and
Jeffrey S. Leon. 

 For documentation on Leon's programs, see the src/leon/doc subdirectory of \textsf{GUAVA}. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

  
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
 
\section{\textcolor{Chapter }{Introduction to the \textsf{GUAVA} package}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X7E87A61A7CC53117}{}
{
  This is the manual of the GAP package \textsf{GUAVA}. \textsf{GUAVA} contains many functions that allow one to perform computations relevant to the
theory of error-correcting codes. This version of \textsf{GUAVA} requires GAP 4.4.5 or later. The current version of \textsf{GUAVA} (3.13) was updated to work with GAP 4.7.9. 

 The functions in \textsf{GUAVA} can be divided into three subcategories: 
\begin{itemize}
\item  Construction of codes: \textsf{GUAVA} can construct unrestricted, linear and cyclic codes. Information about the
code, such as operations applicable to the code, is stored in a record-like
data structure called a GAP object. 
\item  Manipulations of codes: Manipulations transform one code into another, or
construct a new code from two codes. The new code can profit from the data in
the record of the old code(s), so in these cases calculation time often
decreases. 
\item  Computations of information about codes: \textsf{GUAVA} can calculate important parameters of codes quickly. The results are stored in
the codes' object components. 
\end{itemize}
 

 Except for the automorphism group and isomorphism testing functions, which
make use of J.S. Leon's programs (see \cite{Leon91} and the documentation in the 'src/leon' subdirectory of the 'guava' directory
for some details), and \texttt{MinimumWeight} (\ref{MinimumWeight}) function, \textsf{GUAVA} is written in the GAP language, and runs on any system supporting GAP4.4 and
above. Several algorithms that need the speed were integrated in the GAP
kernel. 

 Good general references for error-correcting codes and the technical terms in
this manual are MacWilliams and Sloane \cite{MS83} and also Huffman and Pless \cite{HP03}. }

 
\section{\textcolor{Chapter }{Installing \textsf{GUAVA}}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X810ED40A85FFF6B1}{}
{
  \label{Installing GUAVA} The most recent version of GAP (4.7) comes complete with all of the packages
-- including \textsf{GUAVA}. Thus the following instructions are not usually applicable but may be needed
in certain circumstances. 

 To install \textsf{GUAVA} unpack the archive file in a directory in the `pkg' hierarchy of your version
of GAP 4. 

 After unpacking \textsf{GUAVA} the GAP-only part of \textsf{GUAVA} is installed. The parts of \textsf{GUAVA} depending on J. Leon's backtrack programs package (for computing automorphism
groups) are only available in a UNIX-like environment, where you should
proceed as follows: Go to the newly created `guava' directory and call \texttt{`./configure /gappath'} where \texttt{/gappath} is the path to the GAP home directory. So for example, if you install the
package in the main `pkg' directory call 
\begin{verbatim}  
  ./configure ../..
\end{verbatim}
 This will fetch the architecture type for which GAP has been compiled last and
create a `Makefile'. Now call 
\begin{verbatim}  
  make
\end{verbatim}
 to compile the binaries and install them in the appropriate place. (For a
Windows machine with CYGWIN installed - see \href{http://www.cygwin.com/} {\texttt{http://www.cygwin.com/}} - instructions for compiling Leon's binaries are likely to be similar to those
above. On a 64-bit SUSE linux computer, instead of the configure command above
- which will only compile the 32-bit binary - type 
\begin{verbatim}  
  ./configure ../.. --enable-libsuffix=64 
  make
\end{verbatim}
 to compile Leon's program as a 64 bit native binary. This may also work for
other 64-bit linux distributions as well.) 

 If it is not already installed, you should also install the GAP package \textsf{SONATA}. You can download this from the GAP website and unpack it in the `pkg'
subdirectory. 

 This completes the installation of \textsf{GUAVA} for a single architecture. If you use this installation of \textsf{GUAVA} on different hardware platforms you will have to compile the binaries for each
platform separately. }

 
\section{\textcolor{Chapter }{Loading \textsf{GUAVA}}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X801321C08064258D}{}
{
  After starting up GAP, the \textsf{GUAVA} package needs to be loaded. Load \textsf{GUAVA} by typing at the GAP prompt: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@LoadPackage( "guava" );|
\end{Verbatim}
 If \textsf{GUAVA} isn't already in memory, it is loaded and the author information is displayed.
If you are a frequent user of \textsf{GUAVA}, you might consider adding \textsf{GUAVA} to the "PackagesToLoad" preference in your gap initialization file. (Usually \texttt{gap.ini} which should be located in your home directory.) Type \texttt{GAPInfo.UserGapRoot;} at the GAP prompt to find the location of your initialization file. If none
exists, the command \texttt{WriteGapIniFile();} will create a default \texttt{gap.ini} file which you can then modify. }

 }

 
\chapter{\textcolor{Chapter }{A First Tutorial in \textsf{GUAVA}}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7F3C16F87BDA624A}{}
{
 \label{A First Tutorial in GUAVA} An error-correcting code is essentially just a subset of the set of all
possible messages of a given length over some finite "alphabet." 

 In algebraic coding theory, the "alphabet" is usually some finite field (very
often GF(2)) and frequently the error-correcting code is chosen to be a vector
subspace of the space of all row vectors of some fixed length $n$. Such codes are known as \emph{Linear Codes}, but, however a code is defined the point is to have a collection of
"codewords" that are said to be "in the code" and any other word (row vectors
that are \emph{not} "in the code") will be assumed to be a codeword that has been mangled by the
addition of noise. 

 When a message is received that is not a codeword, we ask ourselves the
question "Which codeword is closest to this message I've received?" In other
words we make the presumption that the received message is actually a codeword
that has been changed in a relatively small number of positions -- and \emph{we put them back the way they were supposed to be!} 

 That process is called "decoding." Developing codes that have efficient
decoding algorithms is one of the central problems of algebraic coding theory. 
\section{\textcolor{Chapter }{Working with codewords}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7B4C487180E9CBCD}{}
{
  

 So let's play around a bit. 

 Start \textsf{GAP} in a terminal window, then issue the command 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@LoadPackage("guava");|
\end{Verbatim}
 

 \textsf{GUAVA} can construct codewords in a variety of ways. One of the most typical cases is
for a codeword to consist of binary digits. In that case we say that "the code
is over GF(2)" and codewords can be constructed as follows: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c1:=Codeword("101010101");|
  [ 1 0 1 0 1 0 1 0 1 ]
  !gapprompt@gap>| !gapinput@v:=Z(2)*[1,1,1,1,1,1,1,1,1];|
  [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]
  !gapprompt@gap>| !gapinput@c2:=Codeword(v);|
  [ 1 1 1 1 1 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@c3:=c1+c2;|
  [ 0 1 0 1 0 1 0 1 0 ]
  !gapprompt@gap>| !gapinput@Weight(c1);|
  5
  !gapprompt@gap>| !gapinput@Weight(c2);|
  9
  !gapprompt@gap>| !gapinput@Weight(c3);|
  4
\end{Verbatim}
 

 The previous excerpt from a \textsf{GAP} session shows that codewords can be constructed from quoted strings or from
vectors whose entries lie in a finite field. We also see that codewords can be
added together and that there is a function called \texttt{Weight} which (if it isn't obvious) tells us how many entries in a codeword are
non-zero. 

 The \emph{Hamming distance} is used extensively in coding theory. It tells us in how many positions two
codewords differ. In \textsf{GUAVA} the Hamming distance is implemented by a function called \texttt{DistanceCodeword}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@DistanceCodeword(c1, c2);|
  4
\end{Verbatim}
 

 Note that the Hamming distance between \texttt{c1} and \texttt{c2} happens to give the same value as the weight of their sum. This is no
coincidence and has to do with the curious fact that in GF(2) adding and
subtracting are the same thing. 

 A codeword can also be constructed using a polynomial. Indeed, the internal
representation of a codeword requires either a polynomial or a vector. There
are \textsf{GUAVA} functions that allow one to switch back and forth between the two
representations. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:=Indeterminate(GF(2));|
  x_1
  !gapprompt@gap>| !gapinput@c4:=Codeword(x^7+x^2+x+1);|
  x^7 + x^2 + x + 1
  !gapprompt@gap>| !gapinput@VectorCodeword(c4);|
  <an immutable GF2 vector of length 8>
  !gapprompt@gap>| !gapinput@Display(last);|
  [ Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ]
  !gapprompt@gap>| !gapinput@c5:=Codeword([1,0,0,0,0,0,1]);|
  [ 1 0 0 0 0 0 1 ]
  !gapprompt@gap>| !gapinput@PolyCodeword(c5);|
  x_1^6+Z(2)^0
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Calculations with codes}}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7DEC2B677A1F2B03}{}
{
  A code is fundamentally just a collection of codewords. Sometimes a code is
merely a \emph{set} of codewords. Other times a code will be the vector space generated by some
small set of codewords. 

 First let's build a code that is merely a set: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@l:=["111000", "011100", "001110", "000111", "100011", "110001", "000000",$|
  [ "111000", "011100", "001110", "000111", "100011", "110001", "000000", 
    "111111" ]
  !gapprompt@gap>| !gapinput@m:=Codeword(l,6,GF(2));    |
  [ [ 1 1 1 0 0 0 ], [ 0 1 1 1 0 0 ], [ 0 0 1 1 1 0 ], [ 0 0 0 1 1 1 ], 
    [ 1 0 0 0 1 1 ], [ 1 1 0 0 0 1 ], [ 0 0 0 0 0 0 ], [ 1 1 1 1 1 1 ] ]
  !gapprompt@gap>| !gapinput@C1:=ElementsCode(m, GF(2));|
  a (6,8,1..6)2..3 user defined unrestricted code over GF(2)
  !gapprompt@gap>| !gapinput@IsLinearCode(C1);|
  false
  !gapprompt@gap>| !gapinput@WeightDistribution(C1);|
  [ 1, 0, 0, 6, 0, 0, 1 ]
\end{Verbatim}
 

 In this example we first wrote out a list of strings, then converted them into
codewords over GF(2). The call to \texttt{ElementsCode} constructs a code from a list of elements. It is possible that the set of
codewords we used actually is a vector space, but the call to \texttt{IsLinearCode} says no. Finally the last function tells us that there are 6 codewords of
weight 3, and one each of weights 0 and 6 in this code. 

 A very useful feature of \textsf{GUAVA} is the ability to construct random codes: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:= RandomLinearCode(12,5,GF(2));|
  a  [12,5,?] randomly generated code over GF(2)
\end{Verbatim}
 

 An error-correcting code's properties are fairly well captured by three
numbers which traditionally are referred to using the letters $n$, $k$ and $d$. We ask for a random code by specifying $n$ (the wordlength), and $k$ (the code's dimension) as well as the field which serves as the alphabet for
the code. 

 One of the most salient features of a code (a feature that determines how good
it will be at correcting errors) is its minimum weight, $d$. This is the smallest weight of any nonzero word in the code. If we wish to
correct $m$ errors we will need to have a minimum weight of at least $2m+1$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@MinimumWeight(C);|
  3
\end{Verbatim}
 

 This particular code would be capable of correcting single bit errors. 

 Finally, one might be interested in the entire distribution of the weights of
the words in a code. The weight distribution is a vector that tells us how
many words there are in a code with each possible weight between $0$ and $n$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@WeightDistribution(C);|
  [ 1, 0, 0, 2, 3, 6, 7, 6, 4, 2, 1, 0, 0 ]
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Codewords}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X836BAA9A7EBD08B1}{}
{
  \label{Codewords} Let $GF(q)$ denote a finite field with $q$ (a prime power) elements. A \emph{code} is a subset $C$ of some finite-dimensional vector space $V$ over $GF(q)$. The \emph{length} of $C$ is the dimension of $V$. Usually, $V=GF(q)^n$ and the length is the number of coordinate entries. When $C$ is itself a vector space over $GF(q)$ then it is called a \emph{linear code} \index{linear code} and the \emph{dimension} of $C$ is its dimension as a vector space over $GF(q)$. 

 In \textsf{GUAVA}, a `codeword' is a GAP record, with one of its components being an element in $V$. Likewise, a `code' is a GAP record, with one of its components being a
subset (or subspace with given basis, if $C$ is linear) of $V$. 
\begin{Verbatim}[commandchars=@|E,fontsize=\small,frame=single,label=Example]
    gap> C:=RandomLinearCode(20,10,GF(4));
    a  [20,10,?] randomly generated code over GF(4)
    gap> c:=Random(C);
    [ 1 a 0 0 0 1 1 a^2 0 0 a 1 1 1 a 1 1 a a 0 ]
    gap> NamesOfComponents(C);
    [ "LeftActingDomain", "GeneratorsOfLeftOperatorAdditiveGroup", "WordLength",
      "GeneratorMat", "name", "Basis", "NiceFreeLeftModule", "Dimension", 
       "Representative", "ZeroImmutable" ]
    gap> NamesOfComponents(c);
    [ "VectorCodeword", "WordLength", "treatAsPoly" ]
    gap> c!.VectorCodeword;
    [ immutable compressed vector length 20 over GF(4) ] 
    gap> Display(last);
    [ Z(2^2), Z(2^2), Z(2^2), Z(2)^0, Z(2^2), Z(2^2)^2, 0*Z(2), Z(2^2), Z(2^2),
      Z(2)^0, Z(2^2)^2, 0*Z(2), 0*Z(2), Z(2^2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2^2)^2,
      Z(2)^0, 0*Z(2) ]
    gap> C!.Dimension;
    10
\end{Verbatim}
  Mathematically, a `codeword' is an element of a code $C$, but in \textsf{GUAVA} the \texttt{Codeword} and \texttt{VectorCodeword} commands have implementations which do not check if the codeword belongs to $C$ (i.e., are independent of the code itself). They exist primarily to make it
easier for the user to construct the associated GAP record. Using these
commands, one can enter into GAP both a codeword $c$ (belonging to $C$) and a received word $r$ (not belonging to $C$) using the same command. The user can input codewords in different formats
(as strings, vectors, and polynomials), and output information is formatted in
a readable way. 

 A codeword $c$ in a linear code $C$ arises in practice by an initial encoding of a 'block' message $m$, adding enough redundancy to recover $m$ after $c$ is transmitted via a 'noisy' communication medium. In \textsf{GUAVA}, for linear codes, the map $m\longmapsto c$ is computed using the command \texttt{c:=m*C} and recovering $m$ from $c$ is obtained by the command \texttt{InformationWord(C,c)}. These commands are explained more below. 

 Many operations are available on codewords themselves, although codewords also
work together with codes (see chapter \ref{Codes} on Codes). 

 The first section describes how codewords are constructed (see \texttt{Codeword} (\ref{Codeword}) and \texttt{IsCodeword} (\ref{IsCodeword})). Sections \ref{Comparisons of Codewords} and \ref{Arithmetic Operations for Codewords} describe the arithmetic operations applicable to codewords. Section \ref{convert Codewords to Vectors or Polynomials} describe functions that convert codewords back to vectors or polynomials (see \texttt{VectorCodeword} (\ref{VectorCodeword}) and \texttt{PolyCodeword} (\ref{PolyCodeword})). Section \ref{Functions that Change the Display Form of a Codeword} describe functions that change the way a codeword is displayed (see \texttt{TreatAsVector} (\ref{TreatAsVector}) and \texttt{TreatAsPoly} (\ref{TreatAsPoly})). Finally, Section \ref{Other Codeword Functions} describes a function to generate a null word (see \texttt{NullWord} (\ref{NullWord})) and some functions for extracting properties of codewords (see \texttt{DistanceCodeword} (\ref{DistanceCodeword}), \texttt{Support} (\ref{Support}) and \texttt{WeightCodeword} (\ref{WeightCodeword})). 
\section{\textcolor{Chapter }{Construction of Codewords}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X81B73ABB87DA8E49}{}
{
  \label{Construction of Codewords} 

\subsection{\textcolor{Chapter }{Codeword}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7B9E353D852851AA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Codeword({\mdseries\slshape obj[, n][, F]})\index{Codeword@\texttt{Codeword}}
\label{Codeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{Codeword} returns a codeword or a list of codewords constructed from \mbox{\texttt{\mdseries\slshape obj}}. The object \mbox{\texttt{\mdseries\slshape obj}} can be a vector, a string, a polynomial or a codeword. It may also be a list
of those (even a mixed list). 

 If a number \mbox{\texttt{\mdseries\slshape n}} is specified, all constructed codewords have length \mbox{\texttt{\mdseries\slshape n}}. This is the only way to make sure that all elements of \mbox{\texttt{\mdseries\slshape obj}} are converted to codewords of the same length. Elements of \mbox{\texttt{\mdseries\slshape obj}} that are longer than \mbox{\texttt{\mdseries\slshape n}} are reduced in length by cutting of the last positions. Elements of \mbox{\texttt{\mdseries\slshape obj}} that are shorter than \mbox{\texttt{\mdseries\slshape n}} are lengthened by adding zeros at the end. If no \mbox{\texttt{\mdseries\slshape n}} is specified, each constructed codeword is handled individually. 

 If a Galois field \mbox{\texttt{\mdseries\slshape F}} is specified, all codewords are constructed over this field. This is the only
way to make sure that all elements of \mbox{\texttt{\mdseries\slshape obj}} are converted to the same field \mbox{\texttt{\mdseries\slshape F}} (otherwise they are converted one by one). Note that all elements of \mbox{\texttt{\mdseries\slshape obj}} must have elements over \mbox{\texttt{\mdseries\slshape F}} or over `Integers'. Converting from one Galois field to another is not
allowed. If no \mbox{\texttt{\mdseries\slshape F}} is specified, vectors or strings with integer elements will be converted to
the smallest Galois field possible. 

 Note that a significant speed increase is achieved if \mbox{\texttt{\mdseries\slshape F}} is specified, even when all elements of \mbox{\texttt{\mdseries\slshape obj}} already have elements over \mbox{\texttt{\mdseries\slshape F}}. 

 Every vector in \mbox{\texttt{\mdseries\slshape obj}} can be a finite field vector over \mbox{\texttt{\mdseries\slshape F}} or a vector over `Integers'. In the last case, it is converted to \mbox{\texttt{\mdseries\slshape F}} or, if omitted, to the smallest Galois field possible. 

 Every string in \mbox{\texttt{\mdseries\slshape obj}} must be a string of numbers, without spaces, commas or any other characters.
These numbers must be from 0 to 9. The string is converted to a codeword over \mbox{\texttt{\mdseries\slshape F}} or, if \mbox{\texttt{\mdseries\slshape F}} is omitted, over the smallest Galois field possible. Note that since all
numbers in the string are interpreted as one-digit numbers, Galois fields of
size larger than 10 are not properly represented when using strings. In fact,
no finite field of size larger than 11 arises in this fashion at all. 

 Every polynomial in \mbox{\texttt{\mdseries\slshape obj}} is converted to a codeword of length \mbox{\texttt{\mdseries\slshape n}} or, if omitted, of a length dictated by the degree of the polynomial. If \mbox{\texttt{\mdseries\slshape F}} is specified, a polynomial in \mbox{\texttt{\mdseries\slshape obj}} must be over \mbox{\texttt{\mdseries\slshape F}}. 

 Every element of \mbox{\texttt{\mdseries\slshape obj}} that is already a codeword is changed to a codeword of length \mbox{\texttt{\mdseries\slshape n}}. If no \mbox{\texttt{\mdseries\slshape n}} was specified, the codeword doesn't change. If \mbox{\texttt{\mdseries\slshape F}} is specified, the codeword must have base field \mbox{\texttt{\mdseries\slshape F}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c := Codeword([0,1,1,1,0]);|
  [ 0 1 1 1 0 ]
  !gapprompt@gap>| !gapinput@VectorCodeword( c ); |
  [ 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2) ]
  !gapprompt@gap>| !gapinput@c2 := Codeword([0,1,1,1,0], GF(3));|
  [ 0 1 1 1 0 ]
  !gapprompt@gap>| !gapinput@VectorCodeword( c2 );|
  [ 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, 0*Z(3) ]
  !gapprompt@gap>| !gapinput@Codeword([c, c2, "0110"]);|
  [ [ 0 1 1 1 0 ], [ 0 1 1 1 0 ], [ 0 1 1 0 ] ]
  !gapprompt@gap>| !gapinput@p := UnivariatePolynomial(GF(2), [Z(2)^0, 0*Z(2), Z(2)^0]);|
  Z(2)^0+x_1^2
  !gapprompt@gap>| !gapinput@Codeword(p);|
  x^2 + 1 
\end{Verbatim}
  

 This command can also be called using the syntax \texttt{Codeword(obj,C)}. In this format, the elements of \mbox{\texttt{\mdseries\slshape obj}} are converted to elements of the same ambient vector space as the elements of
a code \mbox{\texttt{\mdseries\slshape C}}. The command \texttt{Codeword(c,C)} is the same as calling \texttt{Codeword(c,n,F)}, where \mbox{\texttt{\mdseries\slshape n}} is the word length of \mbox{\texttt{\mdseries\slshape C}} and the \mbox{\texttt{\mdseries\slshape F}} is the ground field of \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := WholeSpaceCode(7,GF(5));|
  a cyclic [7,7,1]0 whole space code over GF(5)
  !gapprompt@gap>| !gapinput@Codeword(["0220110", [1,1,1]], C);|
  [ [ 0 2 2 0 1 1 0 ], [ 1 1 1 0 0 0 0 ] ]
  !gapprompt@gap>| !gapinput@Codeword(["0220110", [1,1,1]], 7, GF(5));|
  [ [ 0 2 2 0 1 1 0 ], [ 1 1 1 0 0 0 0 ] ] 
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(3));|
  a linear [10,5,1..3]3..5 random linear code over GF(3)
  !gapprompt@gap>| !gapinput@Codeword("1000000000",C);|
  [ 1 0 0 0 0 0 0 0 0 0 ]
  !gapprompt@gap>| !gapinput@Codeword("1000000000",10,GF(3));|
  [ 1 0 0 0 0 0 0 0 0 0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CodewordNr}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7E7ED91C79BF3EF3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CodewordNr({\mdseries\slshape C, list})\index{CodewordNr@\texttt{CodewordNr}}
\label{CodewordNr}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodewordNr} returns a list of codewords of \mbox{\texttt{\mdseries\slshape C}}. \mbox{\texttt{\mdseries\slshape list}} may be a list of integers or a single integer. For each integer of \mbox{\texttt{\mdseries\slshape list}}, the corresponding codeword of \mbox{\texttt{\mdseries\slshape C}} is returned. The correspondence of a number $i$ with a codeword is determined as follows: if a list of elements of \mbox{\texttt{\mdseries\slshape C}} is available, the $i^{th}$ element is taken. Otherwise, it is calculated by multiplication of the $i^{th}$ information vector by the generator matrix or generator polynomial, where the
information vectors are ordered lexicographically. In particular, the returned
codeword(s) could be a vector or a polynomial. So \texttt{CodewordNr(C, i)} is equal to \texttt{AsSSortedList(C)[i]}, described in the next chapter. The latter function first calculates the set
of all the elements of $C$ and then returns the $i^{th}$ element of that set, whereas the former only calculates the $i^{th}$ codeword. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@B := BinaryGolayCode();|
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  !gapprompt@gap>| !gapinput@c := CodewordNr(B, 4);|
  x^22 + x^20 + x^17 + x^14 + x^13 + x^12 + x^11 + x^10
  !gapprompt@gap>| !gapinput@R := ReedSolomonCode(2,2);|
  a cyclic [2,1,2]1 Reed-Solomon code over GF(3)
  !gapprompt@gap>| !gapinput@AsSSortedList(R);|
  [ [ 0 0 ], [ 1 1 ], [ 2 2 ] ]
  !gapprompt@gap>| !gapinput@CodewordNr(R, [1,3]);|
  [ [ 0 0 ], [ 2 2 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsCodeword}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X7F25479781E6E109}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCodeword({\mdseries\slshape obj})\index{IsCodeword@\texttt{IsCodeword}}
\label{IsCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCodeword} returns `true' if \mbox{\texttt{\mdseries\slshape obj}}, which can be an object of arbitrary type, is of the codeword type and
`false' otherwise. The function will signal an error if \mbox{\texttt{\mdseries\slshape obj}} is an unbound variable. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsCodeword(1);|
  false
  !gapprompt@gap>| !gapinput@IsCodeword(ReedMullerCode(2,3));|
  false
  !gapprompt@gap>| !gapinput@IsCodeword("11111");|
  false
  !gapprompt@gap>| !gapinput@IsCodeword(Codeword("11111"));|
  true 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{Comparisons of Codewords}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X8253374284B475B6}{}
{
  \label{Comparisons of Codewords} 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}= (for codewords)}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X82D4BC7380741DAE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}=({\mdseries\slshape c1, c2})\index{=@\texttt{\texttt{\symbol{92}}=}!for codewords}
\label{=:for codewords}
}\hfill{\scriptsize (method)}}\\


 The equality operator \texttt{c1 = c2} evaluates to `true' if the codewords \mbox{\texttt{\mdseries\slshape c1}} and \mbox{\texttt{\mdseries\slshape c2}} are equal, and to `false' otherwise. Note that codewords are equal if and only
if their base vectors are equal. Whether they are represented as a vector or
polynomial has nothing to do with the comparison. 

 Comparing codewords with objects of other types is not recommended, although
it is possible. If \mbox{\texttt{\mdseries\slshape c2}} is the codeword, the other object \mbox{\texttt{\mdseries\slshape c1}} is first converted to a codeword, after which comparison is possible. This
way, a codeword can be compared with a vector, polynomial, or string. If \mbox{\texttt{\mdseries\slshape c1}} is the codeword, then problems may arise if \mbox{\texttt{\mdseries\slshape c2}} is a polynomial. In that case, the comparison always yields a `false', because
the polynomial comparison is called. 

 The equality operator is also denoted \texttt{EQ}, and \texttt{EQ(c1,c2)} is the same as \texttt{c1 = c2}. There is also an inequality operator, {\textless} {\textgreater}, or \texttt{not EQ}. \index{not =} \index{{\textless} {\textgreater}} }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@P := UnivariatePolynomial(GF(2), Z(2)*[1,0,0,1]);|
  Z(2)^0+x_1^3
  !gapprompt@gap>| !gapinput@c := Codeword(P, GF(2));|
  x^3 + 1
  !gapprompt@gap>| !gapinput@P = c;        # codeword operation|
  true
  !gapprompt@gap>| !gapinput@c2 := Codeword("1001", GF(2));|
  [ 1 0 0 1 ]
  !gapprompt@gap>| !gapinput@c = c2;|
  true 
  !gapprompt@gap>| !gapinput@C:=HammingCode(3);|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@c1:=Random(C);|
  [ 1 0 0 1 1 0 0 ]
  !gapprompt@gap>| !gapinput@c2:=Random(C);|
  [ 0 1 0 0 1 0 1 ]
  !gapprompt@gap>| !gapinput@EQ(c1,c2);|
  false
  !gapprompt@gap>| !gapinput@not EQ(c1,c2);|
  true
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{Arithmetic Operations for Codewords}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X7ADE7E95867A14E1}{}
{
  \label{Arithmetic Operations for Codewords} 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}+ (for codewords)}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X84BD38C87F3956FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}+({\mdseries\slshape c1, c2})\index{+@\texttt{\texttt{\symbol{92}}+}!for codewords}
\label{+:for codewords}
}\hfill{\scriptsize (method)}}\\


 The following operations are always available for codewords. The operands must
have a common base field, and must have the same length. No implicit
conversions are performed. \index{codewords, addition} 

 The operator \texttt{+} evaluates to the sum of the codewords \mbox{\texttt{\mdseries\slshape c1}} and \mbox{\texttt{\mdseries\slshape c2}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(3));|
  a linear [10,5,1..3]3..5 random linear code over GF(3)
  !gapprompt@gap>| !gapinput@c:=Random(C);|
  [ 1 0 2 2 2 2 1 0 2 0 ]
  !gapprompt@gap>| !gapinput@Codeword(c+"2000000000");|
  [ 0 0 2 2 2 2 1 0 2 0 ]
  !gapprompt@gap>| !gapinput@Codeword(c+"1000000000");|
\end{Verbatim}
  The last command returns a GAP ERROR since the `codeword' which \textsf{GUAVA} associates to "1000000000" belongs to $GF(2)$ and not $GF(3)$. 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}- (for codewords)}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X8692958781AF6CA8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}-({\mdseries\slshape c1, c2})\index{-@\texttt{\texttt{\symbol{92}}-}!for codewords}
\label{-:for codewords}
}\hfill{\scriptsize (method)}}\\


 Similar to addition: the operator \texttt{-} evaluates to the difference of the codewords \mbox{\texttt{\mdseries\slshape c1}} and \mbox{\texttt{\mdseries\slshape c2}}. \index{codewords, subtraction} }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}+ (for codeword and code)}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X86DC36217EC11723}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}+({\mdseries\slshape v, C})\index{+@\texttt{\texttt{\symbol{92}}+}!for codeword and code}
\label{+:for codeword and code}
}\hfill{\scriptsize (method)}}\\


 The operator \texttt{v+C} evaluates to the coset code of code \mbox{\texttt{\mdseries\slshape C}} after adding a `codeword' \mbox{\texttt{\mdseries\slshape v}} to all codewords in \mbox{\texttt{\mdseries\slshape C}}. Note that if $c \in C$ then mathematically $c+C=C$ but \textsf{GUAVA} only sees them equal as \emph{sets}. See \texttt{CosetCode} (\ref{CosetCode}). 

 Note that the command \texttt{C+v} returns the same output as the command \texttt{v+C}. 

 \index{codewords, cosets} }

 \index{coset} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5);|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@c:=Random(C);|
  [ 0 0 0 0 0 0 0 0 0 0 ]
  !gapprompt@gap>| !gapinput@c+C;|
  [ add. coset of a  [10,5,?] randomly generated code over GF(2) ]
  !gapprompt@gap>| !gapinput@c+C=C;|
  true
  !gapprompt@gap>| !gapinput@IsLinearCode(c+C);|
  false
  !gapprompt@gap>| !gapinput@v:=Codeword("100000000");|
  [ 1 0 0 0 0 0 0 0 0 ]
  !gapprompt@gap>| !gapinput@v+C;|
  [ add. coset of a  [10,5,?] randomly generated code over GF(2) ]
  !gapprompt@gap>| !gapinput@C=v+C;|
  false
  !gapprompt@gap>| !gapinput@C := GeneratorMatCode( [ [1, 0,0,0], [0, 1,0,0] ], GF(2) );|
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@Elements(C);|
  [ [ 0 0 0 0 ], [ 0 1 0 0 ], [ 1 0 0 0 ], [ 1 1 0 0 ] ]
  !gapprompt@gap>| !gapinput@v:=Codeword("0011");|
  [ 0 0 1 1 ]
  !gapprompt@gap>| !gapinput@C+v;|
  [ add. coset of a linear [4,2,4]1 code defined by generator matrix over GF(2) ]
  !gapprompt@gap>| !gapinput@Elements(C+v);|
  [ [ 0 0 1 1 ], [ 0 1 1 1 ], [ 1 0 1 1 ], [ 1 1 1 1 ] ]
\end{Verbatim}
  In general, the operations just described can also be performed on codewords
expressed as vectors, strings or polynomials, although this is not
recommended. The vector, string or polynomial is first converted to a
codeword, after which the normal operation is performed. For this to go right,
make sure that at least one of the operands is a codeword. Further more, it
will not work when the right operand is a polynomial. In that case, the
polynomial operations (\texttt{FiniteFieldPolynomialOps}) are called, instead of the codeword operations (\texttt{CodewordOps}). 

 Some other code-oriented operations with codewords are described in \ref{Operations for Codes}. }

 
\section{\textcolor{Chapter }{ Functions that Convert Codewords to Vectors or Polynomials }}\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X7BBA5DCD7A8BD60D}{}
{
  \label{convert Codewords to Vectors or Polynomials} 

\subsection{\textcolor{Chapter }{VectorCodeword}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X87C8B0B178496F6A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VectorCodeword({\mdseries\slshape obj})\index{VectorCodeword@\texttt{VectorCodeword}}
\label{VectorCodeword}
}\hfill{\scriptsize (function)}}\\


 Here \mbox{\texttt{\mdseries\slshape obj}} can be a code word or a list of code words. This function returns the
corresponding vectors over a finite field. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := Codeword("011011");; |
  !gapprompt@gap>| !gapinput@VectorCodeword(a);|
  [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, Z(2)^0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{PolyCodeword}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X822465E884D0F484}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolyCodeword({\mdseries\slshape obj})\index{PolyCodeword@\texttt{PolyCodeword}}
\label{PolyCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{PolyCodeword} returns a polynomial or a list of polynomials over a Galois field, converted
from \mbox{\texttt{\mdseries\slshape obj}}. The object \mbox{\texttt{\mdseries\slshape obj}} can be a codeword, or a list of codewords. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := Codeword("011011");; |
  !gapprompt@gap>| !gapinput@PolyCodeword(a);|
  x_1+x_1^2+x_1^4+x_1^5
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Functions that Change the Display Form of a Codeword }}\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X81D3230A797FE6E3}{}
{
  \label{Functions that Change the Display Form of a Codeword} 

\subsection{\textcolor{Chapter }{TreatAsVector}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X7E3E174B7954AA6B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TreatAsVector({\mdseries\slshape obj})\index{TreatAsVector@\texttt{TreatAsVector}}
\label{TreatAsVector}
}\hfill{\scriptsize (function)}}\\


 \texttt{TreatAsVector} adapts the codewords in \mbox{\texttt{\mdseries\slshape obj}} to make sure they are printed as vectors. \mbox{\texttt{\mdseries\slshape obj}} may be a codeword or a list of codewords. Elements of \mbox{\texttt{\mdseries\slshape obj}} that are not codewords are ignored. After this function is called, the
codewords will be treated as vectors. The vector representation is obtained by
using the coefficient list of the polynomial. 

 Note that this \emph{only} changes the way a codeword is \emph{printed}. \texttt{TreatAsVector} returns nothing, it is called only for its side effect. The function \texttt{VectorCodeword} converts codewords to vectors (see \texttt{VectorCodeword} (\ref{VectorCodeword})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@B := BinaryGolayCode();|
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  !gapprompt@gap>| !gapinput@c := CodewordNr(B, 4);|
  x^22 + x^20 + x^17 + x^14 + x^13 + x^12 + x^11 + x^10
  !gapprompt@gap>| !gapinput@TreatAsVector(c);|
  !gapprompt@gap>| !gapinput@c;|
  [ 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 0 0 1 0 1 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{TreatAsPoly}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X7A6828148490BD2E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TreatAsPoly({\mdseries\slshape obj})\index{TreatAsPoly@\texttt{TreatAsPoly}}
\label{TreatAsPoly}
}\hfill{\scriptsize (function)}}\\


 \texttt{TreatAsPoly} adapts the codewords in \mbox{\texttt{\mdseries\slshape obj}} to make sure they are printed as polynomials. \mbox{\texttt{\mdseries\slshape obj}} may be a codeword or a list of codewords. Elements of \mbox{\texttt{\mdseries\slshape obj}} that are not codewords are ignored. After this function is called, the
codewords will be treated as polynomials. The finite field vector that defines
the codeword is used as a coefficient list of the polynomial representation,
where the first element of the vector is the coefficient of degree zero, the
second element is the coefficient of degree one, etc, until the last element,
which is the coefficient of highest degree. 

 Note that this \emph{only} changes the way a codeword is \emph{printed}. \texttt{TreatAsPoly} returns nothing, it is called only for its side effect. The function \texttt{PolyCodeword} converts codewords to polynomials (see \texttt{PolyCodeword} (\ref{PolyCodeword})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := Codeword("00001",GF(2));|
  [ 0 0 0 0 1 ]
  !gapprompt@gap>| !gapinput@TreatAsPoly(a); a;|
  x^4
  !gapprompt@gap>| !gapinput@b := NullWord(6,GF(4));|
  [ 0 0 0 0 0 0 ]
  !gapprompt@gap>| !gapinput@TreatAsPoly(b); b;|
  0 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Other Codeword Functions }}\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X805BF7147C68CACD}{}
{
  \label{Other Codeword Functions} 

\subsection{\textcolor{Chapter }{NullWord}}
\logpage{[ 3, 6, 1 ]}\nobreak
\hyperdef{L}{X8000B6597EF0282F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NullWord({\mdseries\slshape n, F})\index{NullWord@\texttt{NullWord}}
\label{NullWord}
}\hfill{\scriptsize (function)}}\\


 Other uses: \texttt{NullWord( n )} (default $F=GF(2)$) and \texttt{NullWord( C )}. \texttt{NullWord} returns a codeword of length \mbox{\texttt{\mdseries\slshape n}} over the field \mbox{\texttt{\mdseries\slshape F}} of only zeros. The integer \mbox{\texttt{\mdseries\slshape n}} must be greater then zero. If only a code \mbox{\texttt{\mdseries\slshape C}} is specified, \texttt{NullWord} will return a null word with both the word length and the Galois field of \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@NullWord(8);|
  [ 0 0 0 0 0 0 0 0 ]
  !gapprompt@gap>| !gapinput@Codeword("0000") = NullWord(4);|
  true
  !gapprompt@gap>| !gapinput@NullWord(5,GF(16));|
  [ 0 0 0 0 0 ]
  !gapprompt@gap>| !gapinput@NullWord(ExtendedTernaryGolayCode());|
  [ 0 0 0 0 0 0 0 0 0 0 0 0 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DistanceCodeword}}
\logpage{[ 3, 6, 2 ]}\nobreak
\hyperdef{L}{X7CDA1B547D55E6FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DistanceCodeword({\mdseries\slshape c1, c2})\index{DistanceCodeword@\texttt{DistanceCodeword}}
\label{DistanceCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistanceCodeword} returns the Hamming distance from \mbox{\texttt{\mdseries\slshape c1}} to \mbox{\texttt{\mdseries\slshape c2}}. Both variables must be codewords with equal word length over the same Galois
field. The Hamming distance between two words is the number of places in which
they differ. As a result, \texttt{DistanceCodeword} always returns an integer between zero and the word length of the codewords. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := Codeword([0, 1, 2, 0, 1, 2]);; b := NullWord(6, GF(3));;|
  !gapprompt@gap>| !gapinput@DistanceCodeword(a, b);|
  4
  !gapprompt@gap>| !gapinput@DistanceCodeword(b, a);|
  4
  !gapprompt@gap>| !gapinput@DistanceCodeword(a, a);|
  0 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Support}}
\logpage{[ 3, 6, 3 ]}\nobreak
\hyperdef{L}{X7B689C0284AC4296}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Support({\mdseries\slshape c})\index{Support@\texttt{Support}}
\label{Support}
}\hfill{\scriptsize (function)}}\\


 \texttt{Support} returns a set of integers indicating the positions of the non-zero entries in
a codeword \mbox{\texttt{\mdseries\slshape c}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := Codeword("012320023002");; Support(a);|
  [ 2, 3, 4, 5, 8, 9, 12 ]
  !gapprompt@gap>| !gapinput@Support(NullWord(7));|
  [  ] 
\end{Verbatim}
  The support of a list with codewords can be calculated by taking the union of
the individual supports. The weight of the support is the length of the set. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L := Codeword(["000000", "101010", "222000"], GF(3));;|
  !gapprompt@gap>| !gapinput@S := Union(List(L, i -> Support(i)));|
  [ 1, 2, 3, 5 ]
  !gapprompt@gap>| !gapinput@Length(S);|
  4 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{WeightCodeword}}
\logpage{[ 3, 6, 4 ]}\nobreak
\hyperdef{L}{X7AD61C237D8D3849}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeightCodeword({\mdseries\slshape c})\index{WeightCodeword@\texttt{WeightCodeword}}
\label{WeightCodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{WeightCodeword} returns the weight of a codeword $c$, the number of non-zero entries in \mbox{\texttt{\mdseries\slshape c}}. As a result, \texttt{WeightCodeword} always returns an integer between zero and the word length of the codeword. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@WeightCodeword(Codeword("22222"));|
  5
  !gapprompt@gap>| !gapinput@WeightCodeword(NullWord(3));|
  0
  !gapprompt@gap>| !gapinput@C := HammingCode(3);|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@Minimum(List(AsSSortedList(C){[2..Size(C)]}, WeightCodeword ) );|
  3 
\end{Verbatim}
  }

 }

 
\chapter{\textcolor{Chapter }{Codes}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X85FDDF0B7B7D87FB}{}
{
  \label{Codes} A \emph{code} is a set of codewords (recall a \index{code} \index{code, elements of} codeword in \textsf{GUAVA} is simply a sequence of elements of a finite field $GF(q)$, where $q$ is a prime power). We call these the \emph{elements} of the code. Depending on the type of code, a codeword can be interpreted as a
vector or as a polynomial. This is explained in more detail in Chapter \ref{Codewords}. 

 In \textsf{GUAVA}, codes can be a set specified by its elements (this will be called an \emph{unrestricted code}), \index{code, unrestricted} by a generator matrix listing a set of basis elements (for a linear code) or
by a generator polynomial (for a cyclic code). 

 Any code can be defined by its elements. If you like, you can give the code a
name. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ElementsCode(["1100", "1010", "0001"], "example code", GF(2) );|
  a (4,3,1..4)2..4 example code over GF(2) 
\end{Verbatim}
 An $(n,M,d)$ code is a code with word \emph{length} $n$, \emph{size} $M$ and \emph{minimum distance} $d$. \index{code, $(n,M,d)$} \index{minimum distance} \index{length} \index{size} If the minimum distance has not yet been calculated, the lower bound and upper
bound are printed (except in the case where the code is a random linear codes,
where these are not printed for efficiency reasons). So 
\begin{verbatim}  
  a (4,3,1..4)2..4 code over GF(2)
\end{verbatim}
 means a binary unrestricted code of length $4$, with $3$ elements and the minimum distance is greater than or equal to $1$ and less than or equal to $4$ and the covering radius is greater than or equal to $2$ and less than or equal to $4$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ElementsCode(["1100", "1010", "0001"], "example code", GF(2) );|
  a (4,3,1..4)2..4 example code over GF(2) 
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  2
  !gapprompt@gap>| !gapinput@C;|
  a (4,3,2)2..4 example code over GF(2) 
\end{Verbatim}
  If the set of elements is a linear subspace of $GF(q)^n$, the code is called \emph{linear}. If a code is linear, it can be defined by its \emph{generator matrix} or \emph{parity check matrix}. \index{code, linear} \index{parity check matrix} By definition, the rows of the generator matrix is a basis for the code (as a
vector space over $GF(q)$). By definition, the rows of the parity check matrix is a basis for the dual
space of the code, 
\[ C^* = \{ v \in GF(q)^n\ |\ v\cdot c = 0,\ for \ all\ c \in C \}. \]
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := GeneratorMatCode([[1,0,1],[0,1,2]], "demo code", GF(3) );|
  a linear [3,2,1..2]1 demo code over GF(3) 
\end{Verbatim}
 So a linear $[n, k, d]r$ code \index{code, $[n, k, d]r$} is a code with word \emph{length} $n$, \emph{dimension} $k$, \emph{minimum distance} $d$ and \emph{covering radius} $r$. 

 If the code is linear and all cyclic shifts of its codewords (regarded as $n$-tuples) are again codewords, the code is called \emph{cyclic}. \index{code, cyclic} All elements of a cyclic code are multiples of the monic polynomial modulo a
polynomial $x^n -1$, where $n$ is the word length of the code. Such a polynomial is called a \emph{generator polynomial} \index{generator polynomial} The generator polynomial must divide $x^n-1$ and its quotient is called a \emph{check polynomial}. \index{check polynomial} Multiplying a codeword in a cyclic code by the check polynomial yields zero
(modulo the polynomial $x^n -1$). In \textsf{GUAVA}, a cyclic code can be defined by either its generator polynomial or check
polynomial. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := GeneratorPolCode(Indeterminate(GF(2))+Z(2)^0, 7, GF(2) );|
  a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
\end{Verbatim}
 It is possible that \textsf{GUAVA} does not know that an unrestricted code is in fact linear. This situation
occurs for example when a code is generated from a list of elements with the
function \texttt{ElementsCode} (see \texttt{ElementsCode} (\ref{ElementsCode})). By calling the function \texttt{IsLinearCode} (see \texttt{IsLinearCode} (\ref{IsLinearCode})), \textsf{GUAVA} tests if the code can be represented by a generator matrix. If so, the code
record and the operations are converted accordingly. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L := Z(2)*[ [0,0,0], [1,0,0], [0,1,1], [1,1,1] ];;|
  !gapprompt@gap>| !gapinput@C := ElementsCode( L, GF(2) );|
  a (3,4,1..3)1 user defined unrestricted code over GF(2)
  # so far, GUAVA does not know what kind of code this is
  !gapprompt@gap>| !gapinput@IsLinearCode( C );|
  true                      # it is linear
  !gapprompt@gap>| !gapinput@C;|
  a linear [3,2,1]1 user defined unrestricted code over GF(2) 
\end{Verbatim}
  Of course the same holds for unrestricted codes that in fact are cyclic, or
codes, defined by a generator matrix, that actually are cyclic. 

 Codes are printed simply by giving a small description of their parameters,
the word length, size or dimension and perhaps the minimum distance, followed
by a short description and the base field of the code. The function \texttt{Display} gives a more detailed description, showing the construction history of the
code. 

 \textsf{GUAVA} doesn't place much emphasis on the actual encoding and decoding processes;
some algorithms have been included though. Encoding works simply by
multiplying an information vector with a code, decoding is done by the
functions \texttt{Decode} or \texttt{Decodeword}. For more information about encoding and decoding, see sections \ref{Operations for Codes} and \ref{Decode}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R := ReedMullerCode( 1, 3 );|
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  !gapprompt@gap>| !gapinput@w := [ 1, 0, 1, 1 ] * R;|
  [ 1 0 0 1 1 0 0 1 ]
  !gapprompt@gap>| !gapinput@Decode( R, w );|
  [ 1 0 1 1 ]
  !gapprompt@gap>| !gapinput@Decode( R, w + "10000000" ); # One error at the first position|
  [ 1 0 1 1 ]                       # Corrected by Guava 
\end{Verbatim}
  Sections \ref{Comparisons of Codes} and \ref{Operations for Codes} describe the operations that are available for codes. Section \ref{Boolean Functions for Codes} describe the functions that tests whether an object is a code and what kind of
code it is (see \texttt{IsCode}, \texttt{IsLinearCode} (\ref{IsLinearCode}) and \texttt{IsCyclicCode}) and various other boolean functions for codes. Section \ref{Equivalence and Isomorphism of Codes} describe functions about equivalence and isomorphism of codes (see \texttt{IsEquivalent} (\ref{IsEquivalent}), \texttt{CodeIsomorphism} (\ref{CodeIsomorphism}) and \texttt{AutomorphismGroup} (\ref{AutomorphismGroup})). Section \ref{Domain Functions for Codes} describes functions that work on \emph{domains} (see Chapter "Domains and their Elements" in the GAP Reference Manual).
Section \ref{Printing and Displaying Codes} describes functions for printing and displaying codes. Section \ref{Generating (Check) Matrices and Polynomials} describes functions that return the matrices and polynomials that define a
code (see \texttt{GeneratorMat} (\ref{GeneratorMat}), \texttt{CheckMat} (\ref{CheckMat}), \texttt{GeneratorPol} (\ref{GeneratorPol}), \texttt{CheckPol} (\ref{CheckPol}), \texttt{RootsOfCode} (\ref{RootsOfCode})). Section \ref{Parameters of Codes} describes functions that return the basic parameters of codes (see \texttt{WordLength} (\ref{WordLength}), \texttt{Redundancy} (\ref{Redundancy}) and \texttt{MinimumDistance} (\ref{MinimumDistance})). Section \ref{Distributions} describes functions that return distance and weight distributions (see \texttt{WeightDistribution} (\ref{WeightDistribution}), \texttt{InnerDistribution} (\ref{InnerDistribution}), \texttt{OuterDistribution} (\ref{OuterDistribution}) and \texttt{DistancesDistribution} (\ref{DistancesDistribution})). Section \ref{Decoding Functions} describes functions that are related to decoding (see \texttt{Decode} (\ref{Decode}), \texttt{Decodeword} (\ref{Decodeword}), \texttt{Syndrome} (\ref{Syndrome}), \texttt{SyndromeTable} (\ref{SyndromeTable}) and \texttt{StandardArray} (\ref{StandardArray})). In Chapters \ref{Generating Codes} and \ref{Manipulating Codes} which follow, we describe functions that generate and manipulate codes. 
\section{\textcolor{Chapter }{Comparisons of Codes}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7ECE60E1873B49A6}{}
{
  \label{Comparisons of Codes} 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}= (for codes)}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X8686D5FA839F1A3D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}=({\mdseries\slshape C1, C2})\index{=@\texttt{\texttt{\symbol{92}}=}!for codes}
\label{=:for codes}
}\hfill{\scriptsize (method)}}\\


 The equality operator \texttt{C1 = C2} evaluates to `true' if the codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} are equal, and to `false' otherwise. 

 The equality operator is also denoted \texttt{EQ}, and \texttt{Eq(C1,C2)} is the same as \texttt{C1 = C2}. There is also an inequality operator, {\textless} {\textgreater}, or \texttt{not EQ}. 

 Note that codes are equal if and only if their set of elements are equal.
Codes can also be compared with objects of other types. Of course they are
never equal. }

 \index{not =} \index{{\textless} {\textgreater}} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := [ [0, 0], [1, 0], [0, 1], [1, 1] ];;|
  !gapprompt@gap>| !gapinput@C1 := ElementsCode( M, GF(2) );|
  a (2,4,1..2)0 user defined unrestricted code over GF(2)
  !gapprompt@gap>| !gapinput@M = C1;|
  false
  !gapprompt@gap>| !gapinput@C2 := GeneratorMatCode( [ [1, 0], [0, 1] ], GF(2) );|
  a linear [2,2,1]0 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@C1 = C2;|
  true
  !gapprompt@gap>| !gapinput@ReedMullerCode( 1, 3 ) = HadamardCode( 8 );|
  true
  !gapprompt@gap>| !gapinput@WholeSpaceCode( 5, GF(4) ) = WholeSpaceCode( 5, GF(2) );|
  false
\end{Verbatim}
  Another way of comparing codes is \texttt{IsEquivalent}, which checks if two codes are equivalent (see \texttt{IsEquivalent} (\ref{IsEquivalent})). By the way, this called \texttt{CodeIsomorphism}. For the current version of \textsf{GUAVA}, unless one of the codes is unrestricted, this calls Leon's C program (which
only works for binary linear codes and only on a unix/linux computer). }

 
\section{\textcolor{Chapter }{ Operations for Codes }}\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X832DA51986A3882C}{}
{
  \label{Operations for Codes} 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}+ (for codes)}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X82E2E5127CD25168}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}+({\mdseries\slshape C1, C2})\index{+@\texttt{\texttt{\symbol{92}}+}!for codes}
\label{+:for codes}
}\hfill{\scriptsize (method)}}\\


 \index{codes, addition} \index{codes, direct sum} The operator `+' evaluates to the direct sum of the codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. See \texttt{DirectSumCode} (\ref{DirectSumCode}). 

 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1:=RandomLinearCode(10,5);|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@C2:=RandomLinearCode(9,4);|
  a  [9,4,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@C1+C2;|
  a linear [10,9,1]0..10 unknown linear code over GF(2)
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (for codes)}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X7EFA08EE7BA22261}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape C1, C2})\index{*@\texttt{\texttt{\symbol{92}}*}!for codes}
\label{*:for codes}
}\hfill{\scriptsize (method)}}\\


 \index{codes, product} The operator `*' evaluates to the direct product of the codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. See \texttt{DirectProductCode} (\ref{DirectProductCode}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := GeneratorMatCode( [ [1, 0,0,0], [0, 1,0,0] ], GF(2) );|
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@C2 := GeneratorMatCode( [ [0,0,1, 1], [0,0,0, 1] ], GF(2) );|
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@C1*C2;|
  a linear [16,4,1]4..12 direct product code
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (for message and code)}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X84D8B18F7C494A58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}*({\mdseries\slshape m, C})\index{*@\texttt{\texttt{\symbol{92}}*}!for message and code}
\label{*:for message and code}
}\hfill{\scriptsize (method)}}\\


 \index{codes, encoding} \index{encoder map} The operator \texttt{m*C} evaluates to the element of \mbox{\texttt{\mdseries\slshape C}} belonging to information word ('message') \mbox{\texttt{\mdseries\slshape m}}. Here \mbox{\texttt{\mdseries\slshape m}} may be a vector, polynomial, string or codeword or a list of those. This is
the way to do encoding in \textsf{GUAVA}. \mbox{\texttt{\mdseries\slshape C}} must be linear, because in \textsf{GUAVA}, encoding by multiplication is only defined for linear codes. If \mbox{\texttt{\mdseries\slshape C}} is a cyclic code, this multiplication is the same as multiplying an
information polynomial \mbox{\texttt{\mdseries\slshape m}} by the generator polynomial of \mbox{\texttt{\mdseries\slshape C}}. If \mbox{\texttt{\mdseries\slshape C}} is a linear code, it is equal to the multiplication of an information vector \mbox{\texttt{\mdseries\slshape m}} by a generator matrix of \mbox{\texttt{\mdseries\slshape C}}. 

 To invert this, use the function \texttt{InformationWord} (see \texttt{InformationWord} (\ref{InformationWord}), which simply calls the function \texttt{Decode}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := GeneratorMatCode( [ [1, 0,0,0], [0, 1,0,0] ], GF(2) );|
  a linear [4,2,1]1 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@m:=Codeword("11");|
  [ 1 1 ]
  !gapprompt@gap>| !gapinput@m*C;|
  [ 1 1 0 0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{InformationWord}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X8744BA5E78BCF3F9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InformationWord({\mdseries\slshape C, c})\index{InformationWord@\texttt{InformationWord}}
\label{InformationWord}
}\hfill{\scriptsize (function)}}\\


 \index{codes, decoding} \index{information bits} Here \mbox{\texttt{\mdseries\slshape C}} is a linear code and \mbox{\texttt{\mdseries\slshape c}} is a codeword in it. The command \texttt{InformationWord} returns the message word (or 'information digits') $m$ satisfying \texttt{c=m*C}. This command simply calls \texttt{Decode}, provided \texttt{c in C} is true. Otherwise, it returns an error. 

 To invert this, use the encoding function \texttt{*} (see \texttt{\texttt{\symbol{92}}*} (\ref{*:for message and code})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=HammingCode(3);|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@c:=Random(C);|
  [ 0 0 0 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@InformationWord(C,c);|
  [ 0 1 1 1 ]
  !gapprompt@gap>| !gapinput@c:=Codeword("1111100");|
  [ 1 1 1 1 1 0 0 ]
  !gapprompt@gap>| !gapinput@InformationWord(C,c);|
  "ERROR: codeword must belong to code"
  !gapprompt@gap>| !gapinput@C:=NordstromRobinsonCode();|
  a (16,256,6)4 Nordstrom-Robinson code over GF(2)
  !gapprompt@gap>| !gapinput@c:=Random(C);|
  [ 0 0 0 1 0 0 0 1 0 0 1 0 1 1 0 1 ]
  !gapprompt@gap>| !gapinput@InformationWord(C,c);|
  "ERROR: code must be linear"
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Boolean Functions for Codes }}\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X864091AA7D4AFE86}{}
{
  \label{Boolean Functions for Codes} 

\subsection{\textcolor{Chapter }{in}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X87BDB89B7AAFE8AD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{in({\mdseries\slshape c, C})\index{in@\texttt{in}}
\label{in}
}\hfill{\scriptsize (function)}}\\


 \index{code, element test} The command \texttt{c in C} evaluates to `true' if \mbox{\texttt{\mdseries\slshape C}} contains the codeword or list of codewords specified by \mbox{\texttt{\mdseries\slshape c}}. Of course, \mbox{\texttt{\mdseries\slshape c}} and \mbox{\texttt{\mdseries\slshape C}} must have the same word lengths and base fields. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:= HammingCode( 2 );; eC:= AsSSortedList( C );|
  [ [ 0 0 0 ], [ 1 1 1 ] ]
  !gapprompt@gap>| !gapinput@eC[2] in C;|
  true
  !gapprompt@gap>| !gapinput@[ 0 ] in C;|
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsSubset}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X79CA175481F8105F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubset({\mdseries\slshape C1, C2})\index{IsSubset@\texttt{IsSubset}}
\label{IsSubset}
}\hfill{\scriptsize (function)}}\\


 \index{code, subcode} The command \texttt{IsSubset(C1,C2)} returns `true' if \mbox{\texttt{\mdseries\slshape C2}} is a subcode of \mbox{\texttt{\mdseries\slshape C1}}, i.e. if \mbox{\texttt{\mdseries\slshape C1}} contains all the elements of \mbox{\texttt{\mdseries\slshape C2}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsSubset( HammingCode(3), RepetitionCode( 7 ) );|
  true
  !gapprompt@gap>| !gapinput@IsSubset( RepetitionCode( 7 ), HammingCode( 3 ) );|
  false
  !gapprompt@gap>| !gapinput@IsSubset( WholeSpaceCode( 7 ), HammingCode( 3 ) );|
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsCode}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X7F71186281DEA83A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCode({\mdseries\slshape obj})\index{IsCode@\texttt{IsCode}}
\label{IsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCode} returns `true' if \mbox{\texttt{\mdseries\slshape obj}}, which can be an object of arbitrary type, is a code and `false' otherwise.
Will cause an error if \mbox{\texttt{\mdseries\slshape obj}} is an unbound variable. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsCode( 1 );|
  false
  !gapprompt@gap>| !gapinput@IsCode( ReedMullerCode( 2,3 ) );|
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsLinearCode}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X7B24748A7CE8D4B9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLinearCode({\mdseries\slshape obj})\index{IsLinearCode@\texttt{IsLinearCode}}
\label{IsLinearCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsLinearCode} checks if object \mbox{\texttt{\mdseries\slshape obj}} (not necessarily a code) is a linear code. If a code has already been marked
as linear or cyclic, the function automatically returns `true'. Otherwise, the
function checks if a basis $G$ of the elements of \mbox{\texttt{\mdseries\slshape obj}} exists that generates the elements of \mbox{\texttt{\mdseries\slshape obj}}. If so, $G$ is recorded as a generator matrix of \mbox{\texttt{\mdseries\slshape obj}} and the function returns `true'. If not, the function returns `false'. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ElementsCode( [ [0,0,0],[1,1,1] ], GF(2) );|
  a (3,2,1..3)1 user defined unrestricted code over GF(2)
  !gapprompt@gap>| !gapinput@IsLinearCode( C );|
  true
  !gapprompt@gap>| !gapinput@IsLinearCode( ElementsCode( [ [1,1,1] ], GF(2) ) );|
  false
  !gapprompt@gap>| !gapinput@IsLinearCode( 1 );|
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsCyclicCode}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X850C23D07C9A9B19}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCyclicCode({\mdseries\slshape obj})\index{IsCyclicCode@\texttt{IsCyclicCode}}
\label{IsCyclicCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCyclicCode} checks if the object \mbox{\texttt{\mdseries\slshape obj}} is a cyclic code. If a code has already been marked as cyclic, the function
automatically returns `true'. Otherwise, the function checks if a polynomial $g$ exists that generates the elements of \mbox{\texttt{\mdseries\slshape obj}}. If so, $g$ is recorded as a generator polynomial of \mbox{\texttt{\mdseries\slshape obj}} and the function returns `true'. If not, the function returns `false'. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ElementsCode( [ [0,0,0], [1,1,1] ], GF(2) );|
  a (3,2,1..3)1 user defined unrestricted code over GF(2)
  !gapprompt@gap>| !gapinput@# GUAVA does not know the code is cyclic|
  !gapprompt@gap>| !gapinput@IsCyclicCode( C );      # this command tells GUAVA to find out|
  true
  !gapprompt@gap>| !gapinput@IsCyclicCode( HammingCode( 4, GF(2) ) );|
  false
  !gapprompt@gap>| !gapinput@IsCyclicCode( 1 );|
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsPerfectCode}}
\logpage{[ 4, 3, 6 ]}\nobreak
\hyperdef{L}{X85E3BD26856424F7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPerfectCode({\mdseries\slshape C})\index{IsPerfectCode@\texttt{IsPerfectCode}}
\label{IsPerfectCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsPerfectCode(C)} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is a perfect code. If $C\subset GF(q)^n$ then, by definition, this means that for some positive integer $t$, the space $GF(q)^n$ is covered by non-overlapping spheres of (Hamming) radius $t$ centered at the codewords in \mbox{\texttt{\mdseries\slshape C}}. For a code with odd minimum distance $d = 2t+1$, this is the case when every word of the vector space of \mbox{\texttt{\mdseries\slshape C}} is at distance at most $t$ from exactly one element of \mbox{\texttt{\mdseries\slshape C}}. Codes with even minimum distance are never perfect. 

 In fact, a code that is not "trivially perfect" (the binary repetition codes
of odd length, the codes consisting of one word, and the codes consisting of
the whole vector space), and does not have the parameters of a Hamming or
Golay code, cannot be perfect (see section 1.12 in \cite{HP03}). }

 \index{code, perfect} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H := HammingCode(2);|
  a linear [3,1,3]1 Hamming (2,2) code over GF(2)
  !gapprompt@gap>| !gapinput@IsPerfectCode( H );|
  true
  !gapprompt@gap>| !gapinput@IsPerfectCode( ElementsCode([[1,1,0],[0,0,1]],GF(2)) );|
  true
  !gapprompt@gap>| !gapinput@IsPerfectCode( ReedSolomonCode( 6, 3 ) );|
  false
  !gapprompt@gap>| !gapinput@IsPerfectCode( BinaryGolayCode() );|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsMDSCode}}
\logpage{[ 4, 3, 7 ]}\nobreak
\hyperdef{L}{X789380D28018EC3F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsMDSCode({\mdseries\slshape C})\index{IsMDSCode@\texttt{IsMDSCode}}
\label{IsMDSCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsMDSCode(C)} returns true if \mbox{\texttt{\mdseries\slshape C}} is a maximum distance separable (MDS) code. A linear $[n, k, d]$-code of length $n$, dimension $k$ and minimum distance $d$ is an MDS code if $k=n-d+1$, in other words if \mbox{\texttt{\mdseries\slshape C}} meets the Singleton bound (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton})). An unrestricted $(n, M, d)$ code is called \emph{MDS} if $k=n-d+1$, with $k$ equal to the largest integer less than or equal to the logarithm of $M$ with base $q$, the size of the base field of \mbox{\texttt{\mdseries\slshape C}}. 

 Well-known MDS codes include the repetition codes, the whole space codes, the
even weight codes (these are the only \emph{binary} MDS codes) and the Reed-Solomon codes. }

 \index{code, maximum distance separable} \index{MDS} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := ReedSolomonCode( 6, 3 );|
  a cyclic [6,4,3]2 Reed-Solomon code over GF(7)
  !gapprompt@gap>| !gapinput@IsMDSCode( C1 );|
  true    # 6-3+1 = 4
  !gapprompt@gap>| !gapinput@IsMDSCode( QRCode( 23, GF(2) ) );|
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IsSelfDualCode}}
\logpage{[ 4, 3, 8 ]}\nobreak
\hyperdef{L}{X80166D8D837FEB58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSelfDualCode({\mdseries\slshape C})\index{IsSelfDualCode@\texttt{IsSelfDualCode}}
\label{IsSelfDualCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsSelfDualCode(C)} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is self-dual, i.e. when \mbox{\texttt{\mdseries\slshape C}} is equal to its dual code (see also \texttt{DualCode} (\ref{DualCode})). A code is self-dual if it contains all vectors that its elements are
orthogonal to. If a code is self-dual, it automatically is self-orthogonal
(see \texttt{IsSelfOrthogonalCode} (\ref{IsSelfOrthogonalCode})). 

 If \mbox{\texttt{\mdseries\slshape C}} is a non-linear code, it cannot be self-dual (the dual code is always linear),
so `false' is returned. A linear code can only be self-dual when its dimension $k$ is equal to the redundancy $r$. }

 \index{code, self-dual} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsSelfDualCode( ExtendedBinaryGolayCode() );|
  true
  !gapprompt@gap>| !gapinput@C := ReedMullerCode( 1, 3 );|
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  !gapprompt@gap>| !gapinput@DualCode( C ) = C;|
  true 
\end{Verbatim}
 \index{self-orthogonal} 

\subsection{\textcolor{Chapter }{IsSelfOrthogonalCode}}
\logpage{[ 4, 3, 9 ]}\nobreak
\hyperdef{L}{X7B2A0CC481D2366F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSelfOrthogonalCode({\mdseries\slshape C})\index{IsSelfOrthogonalCode@\texttt{IsSelfOrthogonalCode}}
\label{IsSelfOrthogonalCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsSelfOrthogonalCode(C)} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is self-orthogonal. A code is \emph{self-orthogonal} if every element of \mbox{\texttt{\mdseries\slshape C}} is orthogonal to all elements of \mbox{\texttt{\mdseries\slshape C}}, including itself. (In the linear case, this simply means that the generator
matrix of \mbox{\texttt{\mdseries\slshape C}} multiplied with its transpose yields a null matrix.) }

 \index{code, self-orthogonal} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R := ReedMullerCode(1,4);|
  a linear [16,5,8]6 Reed-Muller (1,4) code over GF(2)
  !gapprompt@gap>| !gapinput@IsSelfOrthogonalCode(R);|
  true
  !gapprompt@gap>| !gapinput@IsSelfDualCode(R);|
  false 
\end{Verbatim}
  \index{doubly-even} 

\subsection{\textcolor{Chapter }{IsDoublyEvenCode}}
\logpage{[ 4, 3, 10 ]}\nobreak
\hyperdef{L}{X8358D43981EBE970}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsDoublyEvenCode({\mdseries\slshape C})\index{IsDoublyEvenCode@\texttt{IsDoublyEvenCode}}
\label{IsDoublyEvenCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsDoublyEvenCode(C)} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is a binary linear code which has codewords of weight divisible by 4 only.
According to \cite{HP03}, a doubly-even code is self-orthogonal and every row in its generator matrix
has weight that is divisible by 4. }

 \index{code, doubly-even} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=BinaryGolayCode();|
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  !gapprompt@gap>| !gapinput@WeightDistribution(C);|
  [ 1, 0, 0, 0, 0, 0, 0, 253, 506, 0, 0, 1288, 1288, 0, 0, 506, 253, 0, 0, 0, 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@IsDoublyEvenCode(C);  |
  false
  !gapprompt@gap>| !gapinput@C:=ExtendedCode(C);  |
  a linear [24,12,8]4 extended code
  !gapprompt@gap>| !gapinput@WeightDistribution(C);|
  [ 1, 0, 0, 0, 0, 0, 0, 0, 759, 0, 0, 0, 2576, 0, 0, 0, 759, 0, 0, 0, 0, 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@IsDoublyEvenCode(C);  |
  true
\end{Verbatim}
  \index{singly-even} 

\subsection{\textcolor{Chapter }{IsSinglyEvenCode}}
\logpage{[ 4, 3, 11 ]}\nobreak
\hyperdef{L}{X79ACAEF5865414A0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSinglyEvenCode({\mdseries\slshape C})\index{IsSinglyEvenCode@\texttt{IsSinglyEvenCode}}
\label{IsSinglyEvenCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsSinglyEvenCode(C)} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is a binary self-orthogonal linear code which is not doubly-even. In other
words, \mbox{\texttt{\mdseries\slshape C}} is a binary self-orthogonal code which has codewords of even weight. }

 \index{code, singly-even} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:=Indeterminate(GF(2));                     |
  x_1
  !gapprompt@gap>| !gapinput@C:=QuasiCyclicCode( [x^0, 1+x^3+x^5+x^6+x^7], 11, GF(2) );|
  a linear [22,11,1..6]4..7 quasi-cyclic code over GF(2)
  !gapprompt@gap>| !gapinput@IsSelfDualCode(C);  # self-dual is a restriction of self-orthogonal|
  true
  !gapprompt@gap>| !gapinput@IsDoublyEvenCode(C);|
  false
  !gapprompt@gap>| !gapinput@IsSinglyEvenCode(C);|
  true
\end{Verbatim}
  \index{even} 

\subsection{\textcolor{Chapter }{IsEvenCode}}
\logpage{[ 4, 3, 12 ]}\nobreak
\hyperdef{L}{X7CE150ED7C3DC455}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsEvenCode({\mdseries\slshape C})\index{IsEvenCode@\texttt{IsEvenCode}}
\label{IsEvenCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsEvenCode(C)} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is a binary linear code which has codewords of even weight--regardless whether
or not it is self-orthogonal. }

 \index{code, even} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=BinaryGolayCode();|
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  !gapprompt@gap>| !gapinput@IsSelfOrthogonalCode(C);|
  false
  !gapprompt@gap>| !gapinput@IsEvenCode(C);|
  false
  !gapprompt@gap>| !gapinput@C:=ExtendedCode(C);|
  a linear [24,12,8]4 extended code
  !gapprompt@gap>| !gapinput@IsSelfOrthogonalCode(C);|
  true
  !gapprompt@gap>| !gapinput@IsEvenCode(C);|
  true
  !gapprompt@gap>| !gapinput@C:=ExtendedCode(QRCode(17,GF(2)));|
  a linear [18,9,6]3..5 extended code
  !gapprompt@gap>| !gapinput@IsSelfOrthogonalCode(C);|
  false
  !gapprompt@gap>| !gapinput@IsEvenCode(C);|
  true
\end{Verbatim}
  \index{self complementary code} 

\subsection{\textcolor{Chapter }{IsSelfComplementaryCode}}
\logpage{[ 4, 3, 13 ]}\nobreak
\hyperdef{L}{X7B6DB8CC84FCAC1C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSelfComplementaryCode({\mdseries\slshape C})\index{IsSelfComplementaryCode@\texttt{IsSelfComplementaryCode}}
\label{IsSelfComplementaryCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsSelfComplementaryCode} returns `true' if 
\[ v \in C \Rightarrow 1 - v \in C, \]
 where $1$ is the all-one word of length $n$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsSelfComplementaryCode( HammingCode( 3, GF(2) ) );|
  true
  !gapprompt@gap>| !gapinput@IsSelfComplementaryCode( EvenWeightSubcode(|
  !gapprompt@>| !gapinput@HammingCode( 3, GF(2) ) ) );|
  false 
\end{Verbatim}
 \index{affine code} 

\subsection{\textcolor{Chapter }{IsAffineCode}}
\logpage{[ 4, 3, 14 ]}\nobreak
\hyperdef{L}{X7AFD3844859B20BF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsAffineCode({\mdseries\slshape C})\index{IsAffineCode@\texttt{IsAffineCode}}
\label{IsAffineCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsAffineCode} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is an affine code. A code is called \emph{affine} if it is an affine space. In other words, a code is affine if it is a coset of
a linear code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsAffineCode( HammingCode( 3, GF(2) ) );|
  true
  !gapprompt@gap>| !gapinput@IsAffineCode( CosetCode( HammingCode( 3, GF(2) ),|
  !gapprompt@>| !gapinput@[ 1, 0, 0, 0, 0, 0, 0 ] ) );|
  true
  !gapprompt@gap>| !gapinput@IsAffineCode( NordstromRobinsonCode() );|
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsAlmostAffineCode}}
\logpage{[ 4, 3, 15 ]}\nobreak
\hyperdef{L}{X861D32FB81EF0D77}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsAlmostAffineCode({\mdseries\slshape C})\index{IsAlmostAffineCode@\texttt{IsAlmostAffineCode}}
\label{IsAlmostAffineCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsAlmostAffineCode} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is an almost affine code. A code is called \emph{almost affine} if the size of any punctured code of \mbox{\texttt{\mdseries\slshape C}} is $q^r$ for some $r$, where $q$ is the size of the alphabet of the code. Every affine code is also almost
affine, and every code over $GF(2)$ and $GF(3)$ that is almost affine is also affine. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@code := ElementsCode( [ [0,0,0], [0,1,1], [0,2,2], [0,3,3],|
  !gapprompt@>| !gapinput@                            [1,0,1], [1,1,0], [1,2,3], [1,3,2],|
  !gapprompt@>| !gapinput@                            [2,0,2], [2,1,3], [2,2,0], [2,3,1],|
  !gapprompt@>| !gapinput@                            [3,0,3], [3,1,2], [3,2,1], [3,3,0] ],|
  !gapprompt@>| !gapinput@                            GF(4) );;|
  !gapprompt@gap>| !gapinput@IsAlmostAffineCode( code );|
  true
  !gapprompt@gap>| !gapinput@IsAlmostAffineCode( NordstromRobinsonCode() );|
  false 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Equivalence and Isomorphism of Codes }}\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X86442DCD7A0B2146}{}
{
  \label{Equivalence and Isomorphism of Codes} \index{permutation equivalent codes} \index{equivalent codes} 

\subsection{\textcolor{Chapter }{IsEquivalent}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X843034687D9C75B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsEquivalent({\mdseries\slshape C1, C2})\index{IsEquivalent@\texttt{IsEquivalent}}
\label{IsEquivalent}
}\hfill{\scriptsize (function)}}\\


 We say that \mbox{\texttt{\mdseries\slshape C1}} is \emph{permutation equivalent} to \mbox{\texttt{\mdseries\slshape C2}} if \mbox{\texttt{\mdseries\slshape C1}} can be obtained from \mbox{\texttt{\mdseries\slshape C2}} by carrying out column permutations. \texttt{IsEquivalent} returns true if \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} are equivalent codes. At this time, \texttt{IsEquivalent} only handles \emph{binary} codes. (The external unix/linux program \textsc{desauto} from J. S. Leon is called by \texttt{IsEquivalent}.) Of course, if \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} are equal, they are also equivalent. 

 Note that the algorithm is \emph{very slow} for non-linear codes. 

 More generally, we say that \mbox{\texttt{\mdseries\slshape C1}} is \emph{equivalent} to \mbox{\texttt{\mdseries\slshape C2}} if \mbox{\texttt{\mdseries\slshape C1}} can be obtained from \mbox{\texttt{\mdseries\slshape C2}} by carrying out column permutations and a permutation of the alphabet. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:= Indeterminate( GF(2) );; pol:= x^3+x+1; |
  Z(2)^0+x_1+x_1^3
  !gapprompt@gap>| !gapinput@H := GeneratorPolCode( pol, 7, GF(2));          |
  a cyclic [7,4,1..3]1 code defined by generator polynomial over GF(2)
  !gapprompt@gap>| !gapinput@H = HammingCode(3, GF(2));|
  false
  !gapprompt@gap>| !gapinput@IsEquivalent(H, HammingCode(3, GF(2)));|
  true                        # H is equivalent to a Hamming code
  !gapprompt@gap>| !gapinput@CodeIsomorphism(H, HammingCode(3, GF(2)));|
  (3,4)(5,6,7) 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CodeIsomorphism}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X874DED8E86BC180B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CodeIsomorphism({\mdseries\slshape C1, C2})\index{CodeIsomorphism@\texttt{CodeIsomorphism}}
\label{CodeIsomorphism}
}\hfill{\scriptsize (function)}}\\


 If the two codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} are permutation equivalent codes (see \texttt{IsEquivalent} (\ref{IsEquivalent})), \texttt{CodeIsomorphism} returns the permutation that transforms \mbox{\texttt{\mdseries\slshape C1}} into \mbox{\texttt{\mdseries\slshape C2}}. If the codes are not equivalent, it returns `false'. 

 At this time, \texttt{IsEquivalent} only computes isomorphisms between \emph{binary} codes on a linux/unix computer (since it calls Leon's C program \textsc{desauto}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:= Indeterminate( GF(2) );; pol:= x^3+x+1; |
  Z(2)^0+x_1+x_1^3
  !gapprompt@gap>| !gapinput@H := GeneratorPolCode( pol, 7, GF(2));          |
  a cyclic [7,4,1..3]1 code defined by generator polynomial over GF(2)
  !gapprompt@gap>| !gapinput@CodeIsomorphism(H, HammingCode(3, GF(2)));|
  (3,4)(5,6,7) 
  !gapprompt@gap>| !gapinput@PermutedCode(H, (3,4)(5,6,7)) = HammingCode(3, GF(2));|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{AutomorphismGroup}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X87677B0787B4461A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AutomorphismGroup({\mdseries\slshape C})\index{AutomorphismGroup@\texttt{AutomorphismGroup}}
\label{AutomorphismGroup}
}\hfill{\scriptsize (function)}}\\


 \texttt{AutomorphismGroup} returns the automorphism group of a linear code \mbox{\texttt{\mdseries\slshape C}}. For a binary code, the automorphism group is the largest permutation group
of degree $n$ such that each permutation applied to the columns of \mbox{\texttt{\mdseries\slshape C}} again yields \mbox{\texttt{\mdseries\slshape C}}. \textsf{GUAVA} calls the external program \textsc{desauto} written by J. S. Leon, if it exists, to compute the automorphism group. If
Leon's program is not compiled on the system (and in the default directory)
then it calls instead the much slower program \texttt{PermutationAutomorphismGroup}. 

 See Leon \cite{Leon82} for a more precise description of the method, and the \texttt{guava/src/leon/doc} subdirectory for for details about Leon's C programs. 

 The function \texttt{PermutedCode} permutes the columns of a code (see \texttt{PermutedCode} (\ref{PermutedCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R := RepetitionCode(7,GF(2));|
  a cyclic [7,1,7]3 repetition code over GF(2)
  !gapprompt@gap>| !gapinput@AutomorphismGroup(R);|
  Sym( [ 1 .. 7 ] )
                          # every permutation keeps R identical
  !gapprompt@gap>| !gapinput@C := CordaroWagnerCode(7);|
  a linear [7,2,4]3 Cordaro-Wagner code over GF(2)
  !gapprompt@gap>| !gapinput@AsSSortedList(C);|
  [ [ 0 0 0 0 0 0 0 ], [ 0 0 1 1 1 1 1 ], [ 1 1 0 0 0 1 1 ], [ 1 1 1 1 1 0 0 ] ]
  !gapprompt@gap>| !gapinput@AutomorphismGroup(C);|
  Group([ (3,4), (4,5), (1,6)(2,7), (1,2), (6,7) ])
  !gapprompt@gap>| !gapinput@C2 :=  PermutedCode(C, (1,6)(2,7));|
  a linear [7,2,4]3 permuted code
  !gapprompt@gap>| !gapinput@AsSSortedList(C2);|
  [ [ 0 0 0 0 0 0 0 ], [ 0 0 1 1 1 1 1 ], [ 1 1 0 0 0 1 1 ], [ 1 1 1 1 1 0 0 ] ]
  !gapprompt@gap>| !gapinput@C2 = C;|
  true 
\end{Verbatim}
  \index{PermutationAutomorphismGroup} 

\subsection{\textcolor{Chapter }{PermutationAutomorphismGroup}}
\logpage{[ 4, 4, 4 ]}\nobreak
\hyperdef{L}{X79F3261F86C29F6D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PermutationAutomorphismGroup({\mdseries\slshape C})\index{PermutationAutomorphismGroup@\texttt{PermutationAutomorphismGroup}}
\label{PermutationAutomorphismGroup}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutationAutomorphismGroup} returns the permutation automorphism group of a linear code \mbox{\texttt{\mdseries\slshape C}}. This is the largest permutation group of degree $n$ such that each permutation applied to the columns of \mbox{\texttt{\mdseries\slshape C}} again yields \mbox{\texttt{\mdseries\slshape C}}. It is written in GAP, so is much slower than \texttt{AutomorphismGroup}. 

 When \mbox{\texttt{\mdseries\slshape C}} is binary \texttt{PermutationAutomorphismGroup} does \emph{not} call \texttt{AutomorphismGroup}, even though they agree mathematically in that case. This way \texttt{PermutationAutomorphismGroup} can be called on any platform which runs GAP. 

 The older name for this command, \texttt{PermutationGroup}, will become obsolete in the next version of GAP. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R := RepetitionCode(3,GF(3));|
  a cyclic [3,1,3]2 repetition code over GF(3)
  !gapprompt@gap>| !gapinput@G:=PermutationAutomorphismGroup(R);|
  Group([ (), (1,3), (1,2,3), (2,3), (1,3,2), (1,2) ])
  !gapprompt@gap>| !gapinput@G=SymmetricGroup(3);|
  true
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Domain Functions for Codes }}\logpage{[ 4, 5, 0 ]}
\hyperdef{L}{X866EB39483DDAE72}{}
{
  \label{Domain Functions for Codes} These are some GAP functions that work on `Domains' in general. Their specific
effect on `Codes' is explained here. 

\subsection{\textcolor{Chapter }{IsFinite}}
\logpage{[ 4, 5, 1 ]}\nobreak
\hyperdef{L}{X808A4061809A6E67}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFinite({\mdseries\slshape C})\index{IsFinite@\texttt{IsFinite}}
\label{IsFinite}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsFinite} is an implementation of the GAP domain function \texttt{IsFinite}. It returns true for a code \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsFinite( RepetitionCode( 1000, GF(11) ) );|
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Size}}
\logpage{[ 4, 5, 2 ]}\nobreak
\hyperdef{L}{X858ADA3B7A684421}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Size({\mdseries\slshape C})\index{Size@\texttt{Size}}
\label{Size}
}\hfill{\scriptsize (function)}}\\


 \texttt{Size} returns the size of \mbox{\texttt{\mdseries\slshape C}}, the number of elements of the code. If the code is linear, the size of the
code is equal to $q^k$, where $q$ is the size of the base field of \mbox{\texttt{\mdseries\slshape C}} and $k$ is the dimension. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Size( RepetitionCode( 1000, GF(11) ) );|
  11
  !gapprompt@gap>| !gapinput@Size( NordstromRobinsonCode() );|
  256 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LeftActingDomain}}
\logpage{[ 4, 5, 3 ]}\nobreak
\hyperdef{L}{X86F070E0807DC34E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LeftActingDomain({\mdseries\slshape C})\index{LeftActingDomain@\texttt{LeftActingDomain}}
\label{LeftActingDomain}
}\hfill{\scriptsize (function)}}\\


 \texttt{LeftActingDomain} returns the base field of a code \mbox{\texttt{\mdseries\slshape C}}. Each element of \mbox{\texttt{\mdseries\slshape C}} consists of elements of this base field. If the base field is $F$, and the word length of the code is $n$, then the codewords are elements of $F^n$. If \mbox{\texttt{\mdseries\slshape C}} is a cyclic code, its elements are interpreted as polynomials with
coefficients over $F$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := ElementsCode([[0,0,0], [1,0,1], [0,1,0]], GF(4));|
  a (3,3,1..3)2..3 user defined unrestricted code over GF(4)
  !gapprompt@gap>| !gapinput@LeftActingDomain( C1 );|
  GF(2^2)
  !gapprompt@gap>| !gapinput@LeftActingDomain( HammingCode( 3, GF(9) ) );|
  GF(3^2) 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Dimension}}
\logpage{[ 4, 5, 4 ]}\nobreak
\hyperdef{L}{X7E6926C6850E7C4E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Dimension({\mdseries\slshape C})\index{Dimension@\texttt{Dimension}}
\label{Dimension}
}\hfill{\scriptsize (function)}}\\


 \texttt{Dimension} returns the parameter $k$ of \mbox{\texttt{\mdseries\slshape C}}, the dimension of the code, or the number of information symbols in each
codeword. The dimension is not defined for non-linear codes; \texttt{Dimension} then returns an error. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Dimension( NullCode( 5, GF(5) ) );|
  0
  !gapprompt@gap>| !gapinput@C := BCHCode( 15, 4, GF(4) );|
  a cyclic [15,9,5]3..4 BCH code, delta=5, b=1 over GF(4)
  !gapprompt@gap>| !gapinput@Dimension( C );|
  9
  !gapprompt@gap>| !gapinput@Size( C ) = Size( LeftActingDomain( C ) ) ^ Dimension( C );|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{AsSSortedList}}
\logpage{[ 4, 5, 5 ]}\nobreak
\hyperdef{L}{X856D927378C33548}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AsSSortedList({\mdseries\slshape C})\index{AsSSortedList@\texttt{AsSSortedList}}
\label{AsSSortedList}
}\hfill{\scriptsize (function)}}\\


 \texttt{AsSSortedList} (as strictly sorted list) returns an immutable, duplicate free list of the
elements of \mbox{\texttt{\mdseries\slshape C}}. For a finite field $GF(q)$ generated by powers of $Z(q)$, the ordering on 
\[ GF(q)=\{ 0 , Z(q)^0, Z(q), Z(q)^2, ...Z(q)^{q-2} \} \]
 is that determined by the exponents $i$. These elements are of the type codeword (see \texttt{Codeword} (\ref{Codeword})). Note that for large codes, generating the elements may be very time- and
memory-consuming. For generating a specific element or a subset of the
elements, use \texttt{CodewordNr} (see \texttt{CodewordNr} (\ref{CodewordNr})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ConferenceCode( 5 );|
  a (5,12,2)1..4 conference code over GF(2)
  !gapprompt@gap>| !gapinput@AsSSortedList( C );|
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 1 1 ], [ 0 1 1 0 1 ], [ 0 1 1 1 0 ], 
    [ 1 0 0 1 1 ], [ 1 0 1 0 1 ], [ 1 0 1 1 0 ], [ 1 1 0 0 1 ], [ 1 1 0 1 0 ], 
    [ 1 1 1 0 0 ], [ 1 1 1 1 1 ] ]
  !gapprompt@gap>| !gapinput@CodewordNr( C, [ 1, 2 ] );|
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ] ]
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Printing and Displaying Codes }}\logpage{[ 4, 6, 0 ]}
\hyperdef{L}{X823827927D6A8235}{}
{
  \label{Printing and Displaying Codes} 

\subsection{\textcolor{Chapter }{Print}}
\logpage{[ 4, 6, 1 ]}\nobreak
\hyperdef{L}{X7AFA64D97A1F39A3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Print({\mdseries\slshape C})\index{Print@\texttt{Print}}
\label{Print}
}\hfill{\scriptsize (function)}}\\


 \texttt{Print} prints information about \mbox{\texttt{\mdseries\slshape C}}. This is the same as typing the identifier \mbox{\texttt{\mdseries\slshape C}} at the GAP-prompt. 

 If the argument is an unrestricted code, information in the form 
\begin{verbatim}  
  a (n,M,d)r ... code over GF(q)
\end{verbatim}
 is printed, where \mbox{\texttt{\mdseries\slshape n}} is the word length, \mbox{\texttt{\mdseries\slshape M}} the number of elements of the code, \mbox{\texttt{\mdseries\slshape d}} the minimum distance and \mbox{\texttt{\mdseries\slshape r}} the covering radius. 

 If the argument is a linear code, information in the form 
\begin{verbatim}  
  a linear [n,k,d]r ... code over GF(q)
\end{verbatim}
 is printed, where \mbox{\texttt{\mdseries\slshape n}} is the word length, \mbox{\texttt{\mdseries\slshape k}} the dimension of the code, \mbox{\texttt{\mdseries\slshape d}} the minimum distance and \mbox{\texttt{\mdseries\slshape r}} the covering radius. 

 Except for codes produced by \texttt{RandomLinearCode}, if \mbox{\texttt{\mdseries\slshape d}} is not yet known, it is displayed in the form 
\begin{verbatim}  
  lowerbound..upperbound
\end{verbatim}
 and if \mbox{\texttt{\mdseries\slshape r}} is not yet known, it is displayed in the same way. For certain ranges of $n$, the values of \mbox{\texttt{\mdseries\slshape lowerbound}} and \mbox{\texttt{\mdseries\slshape upperbound}} are obtained from tables. 

 The function \texttt{Display} gives more information. See \texttt{Display} (\ref{Display}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := ExtendedCode( HammingCode( 3, GF(2) ) );|
  a linear [8,4,4]2 extended code
  !gapprompt@gap>| !gapinput@Print( "This is ", NordstromRobinsonCode(), ". \n");|
  This is a (16,256,6)4 Nordstrom-Robinson code over GF(2). 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{String}}
\logpage{[ 4, 6, 2 ]}\nobreak
\hyperdef{L}{X81FB5BE27903EC32}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{String({\mdseries\slshape C})\index{String@\texttt{String}}
\label{String}
}\hfill{\scriptsize (function)}}\\


 \texttt{String} returns information about \mbox{\texttt{\mdseries\slshape C}} in a string. This function is used by \texttt{Print}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:= Indeterminate( GF(3) );; pol:= x^2+1;|
  x_1^2+Z(3)^0
  !gapprompt@gap>| !gapinput@Factors(pol);|
  [ x_1^2+Z(3)^0 ]
  !gapprompt@gap>| !gapinput@H := GeneratorPolCode( pol, 8, GF(3));|
  a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)
  !gapprompt@gap>| !gapinput@String(H);|
  "a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)"
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Display}}
\logpage{[ 4, 6, 3 ]}\nobreak
\hyperdef{L}{X83A5C59278E13248}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Display({\mdseries\slshape C})\index{Display@\texttt{Display}}
\label{Display}
}\hfill{\scriptsize (function)}}\\


 \texttt{Display} prints the method of construction of code \mbox{\texttt{\mdseries\slshape C}}. With this history, in most cases an equal or equivalent code can be
reconstructed. If \mbox{\texttt{\mdseries\slshape C}} is an unmanipulated code, the result is equal to output of the function \texttt{Print} (see \texttt{Print} (\ref{Print})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Display( RepetitionCode( 6, GF(3) ) );|
  a cyclic [6,1,6]4 repetition code over GF(3)
  !gapprompt@gap>| !gapinput@C1 := ExtendedCode( HammingCode(2) );;|
  !gapprompt@gap>| !gapinput@C2 := PuncturedCode( ReedMullerCode( 2, 3 ) );;|
  !gapprompt@gap>| !gapinput@Display( LengthenedCode( UUVCode( C1, C2 ) ) );|
  a linear [12,8,2]2..4 code, lengthened with 1 column(s) of
  a linear [11,8,1]1..2 U U+V construction code of
  U: a linear [4,1,4]2 extended code of
     a linear [3,1,3]1 Hamming (2,2) code over GF(2)
  V: a linear [7,7,1]0 punctured code of
     a cyclic [8,7,2]1 Reed-Muller (2,3) code over GF(2)
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DisplayBoundsInfo}}
\logpage{[ 4, 6, 4 ]}\nobreak
\hyperdef{L}{X7CD08C8C780543C4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DisplayBoundsInfo({\mdseries\slshape bds})\index{DisplayBoundsInfo@\texttt{DisplayBoundsInfo}}
\label{DisplayBoundsInfo}
}\hfill{\scriptsize (function)}}\\


 \texttt{DisplayBoundsInfo} prints the method of construction of the code $C$ indicated in \texttt{bds:= BoundsMinimumDistance( n, k, GF(q) )}. }

 
\begin{Verbatim}[commandchars=!|C,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>C !gapinput|bounds := BoundsMinimumDistance( 20, 17, GF(4) );C
  !gapprompt|gap>C !gapinput|DisplayBoundsInfo(bounds);C
  an optimal linear [20,17,d] code over GF(4) has d=3
  --------------------------------------------------------------------------------------------------
  Lb(20,17)=3, by shortening of:
  Lb(21,18)=3, by applying contruction B to a [81,77,3] code
  Lb(81,77)=3, by shortening of:
  Lb(85,81)=3, reference: Ham
  --------------------------------------------------------------------------------------------------
  Ub(20,17)=3, by considering shortening to:
  Ub(7,4)=3, by considering puncturing to:
  Ub(6,4)=2, by construction B applied to:
  Ub(2,1)=2, repetition code
  --------------------------------------------------------------------------------------------------
  Reference Ham:
  %T this reference is unknown, for more info
  %T contact A.E. Brouwer (aeb@cwi.nl)
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Generating (Check) Matrices and Polynomials }}\logpage{[ 4, 7, 0 ]}
\hyperdef{L}{X7D0F48B685A3ECDD}{}
{
  \label{Generating (Check) Matrices and Polynomials} 

\subsection{\textcolor{Chapter }{GeneratorMat}}
\logpage{[ 4, 7, 1 ]}\nobreak
\hyperdef{L}{X817224657C9829C4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneratorMat({\mdseries\slshape C})\index{GeneratorMat@\texttt{GeneratorMat}}
\label{GeneratorMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorMat} returns a generator matrix of \mbox{\texttt{\mdseries\slshape C}}. The code consists of all linear combinations of the rows of this matrix. 

 If until now no generator matrix of \mbox{\texttt{\mdseries\slshape C}} was determined, it is computed from either the parity check matrix, the
generator polynomial, the check polynomial or the elements (if possible),
whichever is available. 

 If \mbox{\texttt{\mdseries\slshape C}} is a non-linear code, the function returns an error. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GeneratorMat( HammingCode( 3, GF(2) ) );|
  [ [ an immutable GF2 vector of length 7], 
    [ an immutable GF2 vector of length 7], 
    [ an immutable GF2 vector of length 7], 
    [ an immutable GF2 vector of length 7] ]
  !gapprompt@gap>| !gapinput@Display(last);|
   1 1 1 . . . .
   1 . . 1 1 . .
   . 1 . 1 . 1 .
   1 1 . 1 . . 1
  !gapprompt@gap>| !gapinput@GeneratorMat( RepetitionCode( 5, GF(25) ) );|
  [ [ Z(5)^0, Z(5)^0, Z(5)^0, Z(5)^0, Z(5)^0 ] ]
  !gapprompt@gap>| !gapinput@GeneratorMat( NullCode( 14, GF(4) ) );|
  [  ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckMat}}
\logpage{[ 4, 7, 2 ]}\nobreak
\hyperdef{L}{X85D4B26E7FB38D57}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CheckMat({\mdseries\slshape C})\index{CheckMat@\texttt{CheckMat}}
\label{CheckMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckMat} returns a parity check matrix of \mbox{\texttt{\mdseries\slshape C}}. The code consists of all words orthogonal to each of the rows of this
matrix. The transpose of the matrix is a right inverse of the generator
matrix. The parity check matrix is computed from either the generator matrix,
the generator polynomial, the check polynomial or the elements of \mbox{\texttt{\mdseries\slshape C}} (if possible), whichever is available. 

 If \mbox{\texttt{\mdseries\slshape C}} is a non-linear code, the function returns an error. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CheckMat( HammingCode(3, GF(2) ) );|
  [ [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ], 
    [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, Z(2)^0 ],
    [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ] ]
  !gapprompt@gap>| !gapinput@Display(last);|
   . . . 1 1 1 1
   . 1 1 . . 1 1
   1 . 1 . 1 . 1
  !gapprompt@gap>| !gapinput@CheckMat( RepetitionCode( 5, GF(25) ) );|
  [ [ Z(5)^0, Z(5)^2, 0*Z(5), 0*Z(5), 0*Z(5) ],
    [ 0*Z(5), Z(5)^0, Z(5)^2, 0*Z(5), 0*Z(5) ],
    [ 0*Z(5), 0*Z(5), Z(5)^0, Z(5)^2, 0*Z(5) ],
    [ 0*Z(5), 0*Z(5), 0*Z(5), Z(5)^0, Z(5)^2 ] ]
  !gapprompt@gap>| !gapinput@CheckMat( WholeSpaceCode( 12, GF(4) ) );|
  [  ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneratorPol}}
\logpage{[ 4, 7, 3 ]}\nobreak
\hyperdef{L}{X78E33C3A843B0261}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneratorPol({\mdseries\slshape C})\index{GeneratorPol@\texttt{GeneratorPol}}
\label{GeneratorPol}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorPol} returns the generator polynomial of \mbox{\texttt{\mdseries\slshape C}}. The code consists of all multiples of the generator polynomial modulo $x^{n}-1$, where $n$ is the word length of \mbox{\texttt{\mdseries\slshape C}}. The generator polynomial is determined from either the check polynomial, the
generator or check matrix or the elements of \mbox{\texttt{\mdseries\slshape C}} (if possible), whichever is available. 

 If \mbox{\texttt{\mdseries\slshape C}} is not a cyclic code, the function returns `false'. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GeneratorPol(GeneratorMatCode([[1, 1, 0], [0, 1, 1]], GF(2)));|
  Z(2)^0+x_1
  !gapprompt@gap>| !gapinput@GeneratorPol( WholeSpaceCode( 4, GF(2) ) );|
  Z(2)^0
  !gapprompt@gap>| !gapinput@GeneratorPol( NullCode( 7, GF(3) ) );|
  -Z(3)^0+x_1^7
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckPol}}
\logpage{[ 4, 7, 4 ]}\nobreak
\hyperdef{L}{X7C45AA317BB1195F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CheckPol({\mdseries\slshape C})\index{CheckPol@\texttt{CheckPol}}
\label{CheckPol}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckPol} returns the check polynomial of \mbox{\texttt{\mdseries\slshape C}}. The code consists of all polynomials $f$ with 
\[ f\cdot h \equiv 0 \ ({\rm mod}\ x^n-1), \]
 where $h$ is the check polynomial, and $n$ is the word length of \mbox{\texttt{\mdseries\slshape C}}. The check polynomial is computed from the generator polynomial, the
generator or parity check matrix or the elements of \mbox{\texttt{\mdseries\slshape C}} (if possible), whichever is available. 

 If \mbox{\texttt{\mdseries\slshape C}} if not a cyclic code, the function returns an error. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CheckPol(GeneratorMatCode([[1, 1, 0], [0, 1, 1]], GF(2)));|
  Z(2)^0+x_1+x_1^2
  !gapprompt@gap>| !gapinput@CheckPol(WholeSpaceCode(4, GF(2)));|
  Z(2)^0+x_1^4
  !gapprompt@gap>| !gapinput@CheckPol(NullCode(7,GF(3)));|
  Z(3)^0
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RootsOfCode}}
\logpage{[ 4, 7, 5 ]}\nobreak
\hyperdef{L}{X7F4CB9DB7CD97178}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RootsOfCode({\mdseries\slshape C})\index{RootsOfCode@\texttt{RootsOfCode}}
\label{RootsOfCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RootsOfCode} returns a list of all zeros of the generator polynomial of a cyclic code \mbox{\texttt{\mdseries\slshape C}}. These are finite field elements in the splitting field of the generator
polynomial, $GF(q^m)$, $m$ is the multiplicative order of the size of the base field of the code, modulo
the word length. 

 The reverse process, constructing a code from a set of roots, can be carried
out by the function \texttt{RootsCode} (see \texttt{RootsCode} (\ref{RootsCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := ReedSolomonCode( 16, 5 );|
  a cyclic [16,12,5]3..4 Reed-Solomon code over GF(17)
  !gapprompt@gap>| !gapinput@RootsOfCode( C1 );|
  [ Z(17), Z(17)^2, Z(17)^3, Z(17)^4 ]
  !gapprompt@gap>| !gapinput@C2 := RootsCode( 16, last );|
  a cyclic [16,12,5]3..4 code defined by roots over GF(17)
  !gapprompt@gap>| !gapinput@C1 = C2;|
  true 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Parameters of Codes }}\logpage{[ 4, 8, 0 ]}
\hyperdef{L}{X8170B52D7C154247}{}
{
  \label{Parameters of Codes} 

\subsection{\textcolor{Chapter }{WordLength}}
\logpage{[ 4, 8, 1 ]}\nobreak
\hyperdef{L}{X7A36C3C67B0062E8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WordLength({\mdseries\slshape C})\index{WordLength@\texttt{WordLength}}
\label{WordLength}
}\hfill{\scriptsize (function)}}\\


 \texttt{WordLength} returns the parameter $n$ of \mbox{\texttt{\mdseries\slshape C}}, the word length of the elements. Elements of cyclic codes are polynomials of
maximum degree $n-1$, as calculations are carried out modulo $x^{n}-1$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@WordLength( NordstromRobinsonCode() );|
  16
  !gapprompt@gap>| !gapinput@WordLength( PuncturedCode( WholeSpaceCode(7) ) );|
  6
  !gapprompt@gap>| !gapinput@WordLength( UUVCode( WholeSpaceCode(7), RepetitionCode(7) ) );|
  14 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Redundancy}}
\logpage{[ 4, 8, 2 ]}\nobreak
\hyperdef{L}{X7E33FD56792DBF3D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Redundancy({\mdseries\slshape C})\index{Redundancy@\texttt{Redundancy}}
\label{Redundancy}
}\hfill{\scriptsize (function)}}\\


 \texttt{Redundancy} returns the redundancy $r$ of \mbox{\texttt{\mdseries\slshape C}}, which is equal to the number of check symbols in each element. If \mbox{\texttt{\mdseries\slshape C}} is not a linear code the redundancy is not defined and \texttt{Redundancy} returns an error. 

 If a linear code \mbox{\texttt{\mdseries\slshape C}} has dimension $k$ and word length $n$, it has redundancy $r=n-k$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := TernaryGolayCode();|
  a cyclic [11,6,5]2 ternary Golay code over GF(3)
  !gapprompt@gap>| !gapinput@Redundancy(C);|
  5
  !gapprompt@gap>| !gapinput@Redundancy( DualCode(C) );|
  6 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MinimumDistance}}
\logpage{[ 4, 8, 3 ]}\nobreak
\hyperdef{L}{X7B31613D8538BD29}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimumDistance({\mdseries\slshape C})\index{MinimumDistance@\texttt{MinimumDistance}}
\label{MinimumDistance}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumDistance} returns the minimum distance of \mbox{\texttt{\mdseries\slshape C}}, the largest integer $d$ with the property that every element of \mbox{\texttt{\mdseries\slshape C}} has at least a Hamming distance $d$ (see \texttt{DistanceCodeword} (\ref{DistanceCodeword})) to any other element of \mbox{\texttt{\mdseries\slshape C}}. For linear codes, the minimum distance is equal to the minimum weight. This
means that $d$ is also the smallest positive value with $w[d+1] \neq 0$, where $w=(w[1],w[2],...,w[n])$ is the weight distribution of \mbox{\texttt{\mdseries\slshape C}} (see \texttt{WeightDistribution} (\ref{WeightDistribution})). For unrestricted codes, $d$ is the smallest positive value with $w[d+1] \neq 0$, where $w$ is the inner distribution of \mbox{\texttt{\mdseries\slshape C}} (see \texttt{InnerDistribution} (\ref{InnerDistribution})). 

 For codes with only one element, the minimum distance is defined to be equal
to the word length. 

 For linear codes \mbox{\texttt{\mdseries\slshape C}}, the algorithm used is the following: After replacing \mbox{\texttt{\mdseries\slshape C}} by a permutation equivalent \mbox{\texttt{\mdseries\slshape C'}}, one may assume the generator matrix has the following form $G=(I_{k} \, | \, A)$, for some $k\times (n-k)$ matrix $A$. If $A=0$ then return $d(C)=1$. Next, find the minimum distance of the code spanned by the rows of $A$. Call this distance $d(A)$. Note that $d(A)$ is equal to the the Hamming distance $d(v,0)$ where $v$ is some proper linear combination of $i$ distinct rows of $A$. Return $d(C)=d(A)+i$, where $i$ is as in the previous step. 

 This command may also be called using the syntax \texttt{MinimumDistance(C, w)}. In this form, \texttt{MinimumDistance} returns the minimum distance of a codeword \mbox{\texttt{\mdseries\slshape w}} to the code \mbox{\texttt{\mdseries\slshape C}}, also called the \emph{distance from \mbox{\texttt{\mdseries\slshape w}} to} \mbox{\texttt{\mdseries\slshape C}}. This is the smallest value $d$ for which there is an element $c$ of the code \mbox{\texttt{\mdseries\slshape C}} which is at distance $d$ from \mbox{\texttt{\mdseries\slshape w}}. So $d$ is also the minimum value for which $D[d+1] \neq 0$, where $D$ is the distance distribution of \mbox{\texttt{\mdseries\slshape w}} to \mbox{\texttt{\mdseries\slshape C}} (see \texttt{DistancesDistribution} (\ref{DistancesDistribution})). 

 Note that \mbox{\texttt{\mdseries\slshape w}} must be an element of the same vector space as the elements of \mbox{\texttt{\mdseries\slshape C}}. \mbox{\texttt{\mdseries\slshape w}} does not necessarily belong to the code (if it does, the minimum distance is
zero). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := MOLSCode(7);; MinimumDistance(C);|
  3
  !gapprompt@gap>| !gapinput@WeightDistribution(C);|
  [ 1, 0, 0, 24, 24 ]
  !gapprompt@gap>| !gapinput@MinimumDistance( WholeSpaceCode( 5, GF(3) ) );|
  1
  !gapprompt@gap>| !gapinput@MinimumDistance( NullCode( 4, GF(2) ) );|
  4
  !gapprompt@gap>| !gapinput@C := ConferenceCode(9);; MinimumDistance(C);|
  4
  !gapprompt@gap>| !gapinput@InnerDistribution(C);|
  [ 1, 0, 0, 0, 63/5, 9/5, 18/5, 0, 9/10, 1/10 ] 
  !gapprompt@gap>| !gapinput@C := MOLSCode(7);; w := CodewordNr( C, 17 );|
  [ 3 3 6 2 ]
  !gapprompt@gap>| !gapinput@MinimumDistance( C, w );|
  0
  !gapprompt@gap>| !gapinput@C := RemovedElementsCode( C, w );; MinimumDistance( C, w );|
  3                           # so w no longer belongs to C 
\end{Verbatim}
  See also the \textsf{GUAVA} commands relating to bounds on the minimum distance in section \ref{Distance bounds on codes}. 

\subsection{\textcolor{Chapter }{MinimumDistanceLeon}}
\logpage{[ 4, 8, 4 ]}\nobreak
\hyperdef{L}{X813F226F855590EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimumDistanceLeon({\mdseries\slshape C})\index{MinimumDistanceLeon@\texttt{MinimumDistanceLeon}}
\label{MinimumDistanceLeon}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumDistanceLeon} returns the ``probable'' minimum distance $d_{Leon}$ of a linear binary code \mbox{\texttt{\mdseries\slshape C}}, using an implementation of Leon's probabilistic polynomial time algorithm.
Briefly: Let \mbox{\texttt{\mdseries\slshape C}} be a linear code of dimension $k$ over $GF(q)$ as above. The algorithm has input parameters $s$ and $\rho$, where $s$ is an integer between $2$ and $n-k$, and $\rho$ is an integer between $2$ and $k$. 
\begin{itemize}
\item  Find a generator matrix $G$ of $C$. 
\item  Randomly permute the columns of $G$. 
\item  Perform Gaussian elimination on the permuted matrix to obtain a new matrix of
the following form: 
\[ G=(I_{k} \, | \, Z \, | \, B) \]
 with $Z$ a $k\times s$ matrix. If $(Z,B)$ is the zero matrix then return $1$ for the minimum distance. If $Z=0$ but not $B$ then either choose another permutation of the rows of \mbox{\texttt{\mdseries\slshape C}} or return `method fails'. 
\item  Search $Z$ for at most $\rho$ rows that lead to codewords of weight less than $\rho$. 
\item  For these codewords, compute the weight of the whole word in \mbox{\texttt{\mdseries\slshape C}}. Return this weight. 
\end{itemize}
 (See for example J. S. Leon, \cite{Leon88} for more details.) Sometimes (as is the case in \textsf{GUAVA}) this probabilistic algorithm is repeated several times and the most commonly
occurring value is taken. (This function actually has two optional arguments: \texttt{p} and \texttt{num}. The command \texttt{MinimumDistanceLeon(C,p,num)} allows a bit more flexibility for the user - see the GAP code in codeops.gi
for details.) }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(50,22,GF(2));|
  a  [50,22,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@MinimumDistanceLeon(C); time;|
  6
  211
  !gapprompt@gap>| !gapinput@MinimumDistance(C); time;|
  6
  1204
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MinimumWeight}}
\logpage{[ 4, 8, 5 ]}\nobreak
\hyperdef{L}{X84EDF67B86B4154C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimumWeight({\mdseries\slshape C})\index{MinimumWeight@\texttt{MinimumWeight}}
\label{MinimumWeight}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumWeight} returns the minimum Hamming weight of a linear code \mbox{\texttt{\mdseries\slshape C}}. At the moment, this function works for binary and ternary codes only. The \texttt{MinimumWeight} function relies on an external executable program which is written in C
language. As a consequence, the execution time of \texttt{MinimumWeight} function is faster than that of \texttt{MinimumDistance} (\ref{MinimumDistance}) function. 

 The \texttt{MinimumWeight} function implements Chen's \cite{Chen69} algorithm if \mbox{\texttt{\mdseries\slshape C}} is cyclic, and Zimmermann's \cite{Zimmermann96} algorithm if \mbox{\texttt{\mdseries\slshape C}} is a general linear code. This function has a built-in check on the
constraints of the minimum weight codewords. For example, for a
self-orthogonal code over GF(3), the minimum weight codewords have weight that
is divisible by 3, i.e. 0 mod 3 congruence. Similary, self-orthogonal codes
over GF(2) have codeword weights that are divisible by 4 and even codes over
GF(2) have codewords weights that are divisible by 2. By taking these
constraints into account, in many cases, the execution time may be
significantly reduced. Consider the minimum Hamming weight enumeration of the $[151,45]$ binary cyclic code (second example below). This cyclic code is
self-orthogonal, so the weight of all codewords is divisible by 4. Without
considering this constraint, the computation will finish at information weight $10$, rather than $9$. We can see that, this 0 mod 4 constraint on the codeword weights, has
allowed us to avoid enumeration of $b(45,10) = 3,190,187,286$ additional codewords, where $b(n,k)=n!/((n-k)!k!)$ is the binomial coefficient of integers $n$ and $k$. 

 Note that the C source code for this minimum weight computation has not yet
been optimised, especially the code for GF(3), and there are chances to
improve the speed of this function. Your contributions are most welcomed. 

 If you find any bugs on this function, please report it to
ctjhai@plymouth.ac.uk. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@# Extended ternary quadratic residue code of length 48|
  !gapprompt@gap>| !gapinput@n := 47;;|
  !gapprompt@gap>| !gapinput@x := Indeterminate(GF(3));;|
  !gapprompt@gap>| !gapinput@F := Factors(x^n-1);;|
  !gapprompt@gap>| !gapinput@v := List([1..n], i->Zero(GF(3)));;|
  !gapprompt@gap>| !gapinput@v := v + MutableCopyMat(VectorCodeword( Codeword(F[2]) ));;|
  !gapprompt@gap>| !gapinput@G := CirculantMatrix(24, v);;|
  !gapprompt@gap>| !gapinput@for i in [1..Size(G)] do; s:=Zero(GF(3));|
  !gapprompt@>| !gapinput@for j in [1..Size(G[i])] do; s:=s+G[i][j]; od; Append(G[i], [ s ]);|
  !gapprompt@>| !gapinput@od;;|
  !gapprompt@gap>| !gapinput@C := GeneratorMatCodeNC(G, GF(3));|
  a  [48,24,?] randomly generated code over GF(3)
  !gapprompt@gap>| !gapinput@MinimumWeight(C);|
  [48,24] linear code over GF(3) - minimum weight evaluation
  Known lower-bound: 1
  There are 2 generator matrices, ranks : 24 24 
  The weight of the minimum weight codeword satisfies 0 mod 3 congruence
  Enumerating codewords with information weight 1 (w=1)
      Found new minimum weight 15
  Number of matrices required for codeword enumeration 2
  Completed w= 1, 48 codewords enumerated, lower-bound 6, upper-bound 15
  Termination expected with information weight 6 at matrix 1
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 2 (w=2) using 2 matrices
  Completed w= 2, 1104 codewords enumerated, lower-bound 6, upper-bound 15
  Termination expected with information weight 6 at matrix 1
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 3 (w=3) using 2 matrices
  Completed w= 3, 16192 codewords enumerated, lower-bound 9, upper-bound 15
  Termination expected with information weight 6 at matrix 1
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 4 (w=4) using 2 matrices
  Completed w= 4, 170016 codewords enumerated, lower-bound 12, upper-bound 15
  Termination expected with information weight 6 at matrix 1
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 5 (w=5) using 2 matrices
  Completed w= 5, 1360128 codewords enumerated, lower-bound 12, upper-bound 15
  Termination expected with information weight 6 at matrix 1
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 6 (w=6) using 1 matrices
  Completed w= 6, 4307072 codewords enumerated, lower-bound 15, upper-bound 15
  -----------------------------------------------------------------------------
  Minimum weight: 15
  15
  !gapprompt@gap>| !gapinput@|
  
  !gapprompt@gap>| !gapinput@# Binary cyclic code [151,45,36]|
  !gapprompt@gap>| !gapinput@n := 151;;|
  !gapprompt@gap>| !gapinput@x := Indeterminate(GF(2));;|
  !gapprompt@gap>| !gapinput@F := Factors(x^n-1);;|
  !gapprompt@gap>| !gapinput@C := CheckPolCode(F[2]*F[3]*F[3]*F[4], n, GF(2));|
  a cyclic [151,45,1..50]31..75 code defined by check polynomial over GF(2)
  !gapprompt@gap>| !gapinput@MinimumWeight(C);|
  [151,45] cyclic code over GF(2) - minimum weight evaluation
  Known lower-bound: 1
  The weight of the minimum weight codeword satisfies 0 mod 4 congruence
  Enumerating codewords with information weight 1 (w=1)
      Found new minimum weight 56
      Found new minimum weight 44
  Number of matrices required for codeword enumeration 1
  Completed w= 1, 45 codewords enumerated, lower-bound 8, upper-bound 44
  Termination expected with information weight 11
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 2 (w=2) using 1 matrix
  Completed w= 2, 990 codewords enumerated, lower-bound 12, upper-bound 44
  Termination expected with information weight 11
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 3 (w=3) using 1 matrix
     Found new minimum weight 40
     Found new minimum weight 36
  Completed w= 3, 14190 codewords enumerated, lower-bound 16, upper-bound 36
  Termination expected with information weight 9
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 4 (w=4) using 1 matrix
  Completed w= 4, 148995 codewords enumerated, lower-bound 20, upper-bound 36
  Termination expected with information weight 9
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 5 (w=5) using 1 matrix
  Completed w= 5, 1221759 codewords enumerated, lower-bound 24, upper-bound 36
  Termination expected with information weight 9
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 6 (w=6) using 1 matrix
  Completed w= 6, 8145060 codewords enumerated, lower-bound 24, upper-bound 36
  Termination expected with information weight 9
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 7 (w=7) using 1 matrix
  Completed w= 7, 45379620 codewords enumerated, lower-bound 28, upper-bound 36
  Termination expected with information weight 9
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 8 (w=8) using 1 matrix
  Completed w= 8, 215553195 codewords enumerated, lower-bound 32, upper-bound 36
  Termination expected with information weight 9
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 9 (w=9) using 1 matrix
  Completed w= 9, 886163135 codewords enumerated, lower-bound 36, upper-bound 36
  -----------------------------------------------------------------------------
  Minimum weight: 36
  36
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DecreaseMinimumDistanceUpperBound}}
\logpage{[ 4, 8, 6 ]}\nobreak
\hyperdef{L}{X823B9A797EE42F6D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecreaseMinimumDistanceUpperBound({\mdseries\slshape C, t, m})\index{DecreaseMinimumDistanceUpperBound@\texttt{DecreaseMinimumDistanceUpperBound}}
\label{DecreaseMinimumDistanceUpperBound}
}\hfill{\scriptsize (function)}}\\


 \texttt{DecreaseMinimumDistanceUpperBound} is an implementation of the algorithm for the minimum distance of a linear
binary code \mbox{\texttt{\mdseries\slshape C}} by Leon \cite{Leon88}. This algorithm tries to find codewords with small minimum weights. The
parameter \mbox{\texttt{\mdseries\slshape t}} is at least $1$ and less than the dimension of \mbox{\texttt{\mdseries\slshape C}}. The best results are obtained if it is close to the dimension of the code.
The parameter \mbox{\texttt{\mdseries\slshape m}} gives the number of runs that the algorithm will perform. 

 The result returned is a record with two fields; the first, \texttt{mindist}, gives the lowest weight found, and \texttt{word} gives the corresponding codeword. (This was implemented before \texttt{MinimumDistanceLeon} but independently. The older manual had given the command incorrectly, so the
command was only found after reading all the \emph{*.gi} files in the \textsf{GUAVA} library. Though both \texttt{MinimumDistance} and \texttt{MinimumDistanceLeon} often run much faster than \texttt{DecreaseMinimumDistanceUpperBound}, \texttt{DecreaseMinimumDistanceUpperBound} appears to be more accurate than \texttt{MinimumDistanceLeon}.) }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(5,2,GF(2));|
  a  [5,2,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@DecreaseMinimumDistanceUpperBound(C,1,4);|
  rec( mindist := 3, word := [ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0 ] )
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  3
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(8,4,GF(2));|
  a  [8,4,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@DecreaseMinimumDistanceUpperBound(C,3,4);|
  rec( mindist := 2,
    word := [ Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0 ] )
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{MinimumDistanceRandom}}
\logpage{[ 4, 8, 7 ]}\nobreak
\hyperdef{L}{X7A679B0A7816B030}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimumDistanceRandom({\mdseries\slshape C, num, s})\index{MinimumDistanceRandom@\texttt{MinimumDistanceRandom}}
\label{MinimumDistanceRandom}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumDistanceRandom} returns an upper bound for the minimum distance $d_{random}$ of a linear binary code \mbox{\texttt{\mdseries\slshape C}}, using a probabilistic polynomial time algorithm. Briefly: Let \mbox{\texttt{\mdseries\slshape C}} be a linear code of dimension $k$ over $GF(q)$ as above. The algorithm has input parameters $num$ and $s$, where $s$ is an integer between $2$ and $n-1$, and $num$ is an integer greater than or equal to $1$. 
\begin{itemize}
\item  Find a generator matrix $G$ of $C$. 
\item  Randomly permute the columns of $G$, written $G_p$.. 
\item  
\[ G=(A, B) \]
 with $A$ a $k\times s$ matrix. If $A$ is the zero matrix then return `method fails'. 
\item  Search $A$ for at most $5$ rows that lead to codewords, in the code $C_A$ with generator matrix $A$, of minimum weight. 
\item  For these codewords, use the associated linear combination to compute the
weight of the whole word in \mbox{\texttt{\mdseries\slshape C}}. Return this weight and codeword. 
\end{itemize}
 This probabilistic algorithm is repeated \mbox{\texttt{\mdseries\slshape num}} times (with different random permutations of the rows of $G$ each time) and the weight and codeword of the lowest occurring weight is
taken. }

 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>A @gapinput|C:=RandomLinearCode(60,20,GF(2));A
  a  [60,20,?] randomly generated code over GF(2)
  @gapprompt|gap>A @gapinput|#mindist(C);time;A
  @gapprompt|gap>A @gapinput|#mindistleon(C,10,30);time; #doesn't work wellA
  @gapprompt|gap>A @gapinput|a:=MinimumDistanceRandom(C,10,30);time; # done 10 times -with fastest time!!A
  
   This is a probabilistic algorithm which may return the wrong answer.
  [ 12, [ 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 
          1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 ] ]
  130
  @gapprompt|gap>A @gapinput|a[2] in C;A
  true
  @gapprompt|gap>A @gapinput|b:=DecreaseMinimumDistanceUpperBound(C,10,1); time; #only done once!A
  rec( mindist := 12, word := [ 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 
        Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 
        0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 
        Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 
        0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), 
        0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 
        0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] )
  649
  @gapprompt|gap>A @gapinput|Codeword(b!.word) in C;A
  true
  @gapprompt|gap>A @gapinput|MinimumDistance(C);time;A
  12
  196
  @gapprompt|gap>A @gapinput|c:=MinimumDistanceLeon(C);time;A
  12
  66
  @gapprompt|gap>A @gapinput|C:=RandomLinearCode(30,10,GF(3));A
  a  [30,10,?] randomly generated code over GF(3)
  @gapprompt|gap>A @gapinput|a:=MinimumDistanceRandom(C,10,10);time;A
  
   This is a probabilistic algorithm which may return the wrong answer.
  [ 13, [ 0 0 0 1 0 0 0 0 0 0 1 0 2 2 1 1 0 2 2 0 1 0 2 1 0 0 0 1 0 2 ] ]
  229
  @gapprompt|gap>A @gapinput|a[2] in C;A
  true
  @gapprompt|gap>A @gapinput|MinimumDistance(C);time;A
  9
  45
  @gapprompt|gap>A @gapinput|c:=MinimumDistanceLeon(C);A
  Code must be binary. Quitting.
  0
  @gapprompt|gap>A @gapinput|a:=MinimumDistanceRandom(C,1,29);time;A
  
   This is a probabilistic algorithm which may return the wrong answer.
  [ 10, [ 0 0 1 0 2 0 2 0 1 0 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 2 2 2 0 ] ]
  53
\end{Verbatim}
  \index{$t(n,k)$} \index{covering code} 

\subsection{\textcolor{Chapter }{CoveringRadius}}
\logpage{[ 4, 8, 8 ]}\nobreak
\hyperdef{L}{X7A195E317D2AB7CE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoveringRadius({\mdseries\slshape C})\index{CoveringRadius@\texttt{CoveringRadius}}
\label{CoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{CoveringRadius} returns the \emph{covering radius} of a linear code \mbox{\texttt{\mdseries\slshape C}}. This is the smallest number $r$ with the property that each element $v$ of the ambient vector space of \mbox{\texttt{\mdseries\slshape C}} has at most a distance $r$ to the code \mbox{\texttt{\mdseries\slshape C}}. So for each vector $v$ there must be an element $c$ of \mbox{\texttt{\mdseries\slshape C}} with $d(v,c) \leq r$. The smallest covering radius of any $[n,k]$ binary linear code is denoted $t(n,k)$. A binary linear code with reasonable small covering radius is called a \emph{covering code}. 

 If \mbox{\texttt{\mdseries\slshape C}} is a perfect code (see \texttt{IsPerfectCode} (\ref{IsPerfectCode})), the covering radius is equal to $t$, the number of errors the code can correct, where $d = 2t+1$, with $d$ the minimum distance of \mbox{\texttt{\mdseries\slshape C}} (see \texttt{MinimumDistance} (\ref{MinimumDistance})). 

 If there exists a function called \texttt{SpecialCoveringRadius} in the `operations' field of the code, then this function will be called to
compute the covering radius of the code. At the moment, no code-specific
functions are implemented. 

 If the length of \texttt{BoundsCoveringRadius} (see \texttt{BoundsCoveringRadius} (\ref{BoundsCoveringRadius})), is 1, then the value in 
\begin{verbatim}  
  C.boundsCoveringRadius
\end{verbatim}
 is returned. Otherwise, the function 
\begin{verbatim}  
  C.operations.CoveringRadius
\end{verbatim}
 is executed, unless the redundancy of \mbox{\texttt{\mdseries\slshape C}} is too large. In the last case, a warning is issued. 

 The algorithm used to compute the covering radius is the following. First, \texttt{CosetLeadersMatFFE} is used to compute the list of coset leaders (which returns a codeword in each
coset of $GF(q)^n/C$ of minimum weight). Then \texttt{WeightVecFFE} is used to compute the weight of each of these coset leaders. The program
returns the maximum of these weights.  }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H := RandomLinearCode(10, 5, GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@CoveringRadius(H);|
  3
  !gapprompt@gap>| !gapinput@H := HammingCode(4, GF(2));; IsPerfectCode(H);|
  true
  !gapprompt@gap>| !gapinput@CoveringRadius(H);|
  1                       # Hamming codes have minimum distance 3
  !gapprompt@gap>| !gapinput@CoveringRadius(ReedSolomonCode(7,4));|
  3 
  !gapprompt@gap>| !gapinput@CoveringRadius( BCHCode( 17, 3, GF(2) ) );|
  3
  !gapprompt@gap>| !gapinput@CoveringRadius( HammingCode( 5, GF(2) ) );|
  1
  !gapprompt@gap>| !gapinput@C := ReedMullerCode( 1, 9 );;|
  !gapprompt@gap>| !gapinput@CoveringRadius( C );|
  CoveringRadius: warning, the covering radius of
  this code cannot be computed straightforward.
  Try to use IncreaseCoveringRadiusLowerBound( code ).
  (see the manual for more details).
  The covering radius of code lies in the interval:
  [ 240 .. 248 ]
\end{Verbatim}
  See also the \textsf{GUAVA} commands relating to bounds on the minimum distance in section \ref{Covering radius bounds on codes}. 

\subsection{\textcolor{Chapter }{SetCoveringRadius}}
\logpage{[ 4, 8, 9 ]}\nobreak
\hyperdef{L}{X81004B007EC5DF58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetCoveringRadius({\mdseries\slshape C, intlist})\index{SetCoveringRadius@\texttt{SetCoveringRadius}}
\label{SetCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{SetCoveringRadius} enables the user to set the covering radius herself, instead of letting \textsf{GUAVA} compute it. If \mbox{\texttt{\mdseries\slshape intlist}} is an integer, \textsf{GUAVA} will simply put it in the `boundsCoveringRadius' field. If it is a list of
integers, however, it will intersect this list with the `boundsCoveringRadius'
field, thus taking the best of both lists. If this would leave an empty list,
the field is set to \mbox{\texttt{\mdseries\slshape intlist}}. Because some other computations use the covering radius of the code, it is
important that the entered value is not wrong, otherwise new results may be
invalid. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := BCHCode( 17, 3, GF(2) );;|
  !gapprompt@gap>| !gapinput@BoundsCoveringRadius( C );|
  [ 3 .. 4 ]
  !gapprompt@gap>| !gapinput@SetCoveringRadius( C, [ 2 .. 3 ] );|
  !gapprompt@gap>| !gapinput@BoundsCoveringRadius( C );|
  [ [ 2 .. 3 ] ]
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Distributions }}\logpage{[ 4, 9, 0 ]}
\hyperdef{L}{X806384B4815EFF2E}{}
{
  \label{Distributions} 

\subsection{\textcolor{Chapter }{MinimumWeightWords}}
\logpage{[ 4, 9, 1 ]}\nobreak
\hyperdef{L}{X7AEE64467FB1E0B9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimumWeightWords({\mdseries\slshape C})\index{MinimumWeightWords@\texttt{MinimumWeightWords}}
\label{MinimumWeightWords}
}\hfill{\scriptsize (function)}}\\


 \texttt{MinimumWeightWords} returns the list of minimum weight codewords of \mbox{\texttt{\mdseries\slshape C}}. 

 This algorithm is written in GAP is slow, so is only suitable for small codes. 

 This does not call the very fast function \texttt{MinimumWeight} (see \texttt{MinimumWeight} (\ref{MinimumWeight})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=HammingCode(3,GF(2));|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@MinimumWeightWords(C);|
  [ [ 1 0 0 0 0 1 1 ], [ 0 1 0 1 0 1 0 ], [ 0 1 0 0 1 0 1 ], [ 1 0 0 1 1 0 0 ], [ 0 0 1 0 1 1 0 ],
    [ 0 0 1 1 0 0 1 ], [ 1 1 1 0 0 0 0 ] ]
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{WeightDistribution}}
\logpage{[ 4, 9, 2 ]}\nobreak
\hyperdef{L}{X8728BCC9842A6E5D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeightDistribution({\mdseries\slshape C})\index{WeightDistribution@\texttt{WeightDistribution}}
\label{WeightDistribution}
}\hfill{\scriptsize (function)}}\\


 \texttt{WeightDistribution} returns the weight distribution of \mbox{\texttt{\mdseries\slshape C}}, as a vector. The $i^{th}$ element of this vector contains the number of elements of \mbox{\texttt{\mdseries\slshape C}} with weight $i-1$. For linear codes, the weight distribution is equal to the inner distribution
(see \texttt{InnerDistribution} (\ref{InnerDistribution})). If $w$ is the weight distribution of a linear code \mbox{\texttt{\mdseries\slshape C}}, it must have the zero codeword, so $w[1] = 1$ (one word of weight 0). 

 Some codes, such as the Hamming codes, have precomputed weight distributions.
For others, the program WeightDistribution calls the GAP program \texttt{DistancesDistributionMatFFEVecFFE}, which is written in C. See also \texttt{CodeWeightEnumerator}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@WeightDistribution( ConferenceCode(9) );|
  [ 1, 0, 0, 0, 0, 18, 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@WeightDistribution( RepetitionCode( 7, GF(4) ) );|
  [ 1, 0, 0, 0, 0, 0, 0, 3 ]
  !gapprompt@gap>| !gapinput@WeightDistribution( WholeSpaceCode( 5, GF(2) ) );|
  [ 1, 5, 10, 10, 5, 1 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{InnerDistribution}}
\logpage{[ 4, 9, 3 ]}\nobreak
\hyperdef{L}{X871FD301820717A4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InnerDistribution({\mdseries\slshape C})\index{InnerDistribution@\texttt{InnerDistribution}}
\label{InnerDistribution}
}\hfill{\scriptsize (function)}}\\


 \texttt{InnerDistribution} returns the inner distribution of \mbox{\texttt{\mdseries\slshape C}}. The $i^{th}$ element of the vector contains the average number of elements of \mbox{\texttt{\mdseries\slshape C}} at distance $i-1$ to an element of \mbox{\texttt{\mdseries\slshape C}}. For linear codes, the inner distribution is equal to the weight distribution
(see \texttt{WeightDistribution} (\ref{WeightDistribution})). 

 Suppose $w$ is the inner distribution of \mbox{\texttt{\mdseries\slshape C}}. Then $w[1] = 1$, because each element of \mbox{\texttt{\mdseries\slshape C}} has exactly one element at distance zero (the element itself). The minimum
distance of \mbox{\texttt{\mdseries\slshape C}} is the smallest value $d > 0$ with $w[d+1] \neq 0$, because a distance between zero and $d$ never occurs. See \texttt{MinimumDistance} (\ref{MinimumDistance}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@InnerDistribution( ConferenceCode(9) );|
  [ 1, 0, 0, 0, 63/5, 9/5, 18/5, 0, 9/10, 1/10 ]
  !gapprompt@gap>| !gapinput@InnerDistribution( RepetitionCode( 7, GF(4) ) );|
  [ 1, 0, 0, 0, 0, 0, 0, 3 ] 
\end{Verbatim}
  \index{distance} 

\subsection{\textcolor{Chapter }{DistancesDistribution}}
\logpage{[ 4, 9, 4 ]}\nobreak
\hyperdef{L}{X87AD54F87C5EE77E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DistancesDistribution({\mdseries\slshape C, w})\index{DistancesDistribution@\texttt{DistancesDistribution}}
\label{DistancesDistribution}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistancesDistribution} returns the distribution of the distances of all elements of \mbox{\texttt{\mdseries\slshape C}} to a codeword \mbox{\texttt{\mdseries\slshape w}} in the same vector space. The $i^{th}$ element of the distance distribution is the number of codewords of \mbox{\texttt{\mdseries\slshape C}} that have distance $i-1$ to \mbox{\texttt{\mdseries\slshape w}}. The smallest value $d$ with $w[d+1] \neq 0$, is defined as the \emph{distance to} \mbox{\texttt{\mdseries\slshape C}} (see \texttt{MinimumDistance} (\ref{MinimumDistance})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H := HadamardCode(20);|
  a (20,40,10)6..8 Hadamard code of order 20 over GF(2)
  !gapprompt@gap>| !gapinput@c := Codeword("10110101101010010101", H);|
  [ 1 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 ]
  !gapprompt@gap>| !gapinput@DistancesDistribution(H, c);|
  [ 0, 0, 0, 0, 0, 1, 0, 7, 0, 12, 0, 12, 0, 7, 0, 1, 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@MinimumDistance(H, c);|
  5                           # distance to H 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{OuterDistribution}}
\logpage{[ 4, 9, 5 ]}\nobreak
\hyperdef{L}{X8495870687195324}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OuterDistribution({\mdseries\slshape C})\index{OuterDistribution@\texttt{OuterDistribution}}
\label{OuterDistribution}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{OuterDistribution} returns a list of length $q^n$, where $q$ is the size of the base field of \mbox{\texttt{\mdseries\slshape C}} and $n$ is the word length. The elements of the list consist of pairs, the first
coordinate being an element of $GF(q)^n$ (this is a codeword type) and the second coordinate being a distribution of
distances to the code (a list of integers). This table is \emph{very} large, and for $n > 20$ it will not fit in the memory of most computers. The function \texttt{DistancesDistribution} (see \texttt{DistancesDistribution} (\ref{DistancesDistribution})) can be used to calculate one entry of the list. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := RepetitionCode( 3, GF(2) );|
  a cyclic [3,1,3]1 repetition code over GF(2)
  !gapprompt@gap>| !gapinput@OD := OuterDistribution(C);|
  [ [ [ 0 0 0 ], [ 1, 0, 0, 1 ] ], [ [ 1 1 1 ], [ 1, 0, 0, 1 ] ],
    [ [ 0 0 1 ], [ 0, 1, 1, 0 ] ], [ [ 1 1 0 ], [ 0, 1, 1, 0 ] ],
    [ [ 1 0 0 ], [ 0, 1, 1, 0 ] ], [ [ 0 1 1 ], [ 0, 1, 1, 0 ] ],
    [ [ 0 1 0 ], [ 0, 1, 1, 0 ] ], [ [ 1 0 1 ], [ 0, 1, 1, 0 ] ] ]
  !gapprompt@gap>| !gapinput@WeightDistribution(C) = OD[1][2];|
  true
  !gapprompt@gap>| !gapinput@DistancesDistribution( C, Codeword("110") ) = OD[4][2];|
  true 
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Decoding Functions }}\logpage{[ 4, 10, 0 ]}
\hyperdef{L}{X7D9A39BF801948C8}{}
{
  \label{Decoding Functions} 

\subsection{\textcolor{Chapter }{Decode}}
\logpage{[ 4, 10, 1 ]}\nobreak
\hyperdef{L}{X7A42FF7D87FC34AC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Decode({\mdseries\slshape C, r})\index{Decode@\texttt{Decode}}
\label{Decode}
}\hfill{\scriptsize (function)}}\\


 \texttt{Decode} decodes \mbox{\texttt{\mdseries\slshape r}} (a 'received word') with respect to code \mbox{\texttt{\mdseries\slshape C}} and returns the `message word' (i.e., the information digits associated to the
codeword $c \in C$ closest to \mbox{\texttt{\mdseries\slshape r}}). Here \mbox{\texttt{\mdseries\slshape r}} can be a \textsf{GUAVA} codeword or a list of codewords. First, possible errors in \mbox{\texttt{\mdseries\slshape r}} are corrected, then the codeword is decoded to an \emph{information codeword} $m$ (and not an element of \mbox{\texttt{\mdseries\slshape C}}). If the code record has a field `specialDecoder', this special algorithm is
used to decode the vector. Hamming codes,  cyclic codes, and generalized Reed-Solomon have such a special algorithm. (The
algorithm used for BCH codes is the Sugiyama algorithm described, for example,
in section 5.4.3 of \cite{HP03}. A special decoder has also being written for the generalized Reed-Solomon
code using the interpolation algorithm. For cyclic codes, the error-trapping
algorithm is used.) If \mbox{\texttt{\mdseries\slshape C}} is linear and no special decoder field has been set then syndrome decoding is
used. Otherwise (when \mbox{\texttt{\mdseries\slshape C}} is non-linear), the nearest neighbor decoding algorithm is used (which is very
slow). 

 A special decoder can be created by defining a function 
\begin{verbatim}  
  C!.SpecialDecoder := function(C, r) ... end;
\end{verbatim}
 The function uses the arguments \mbox{\texttt{\mdseries\slshape C}} (the code record itself) and \mbox{\texttt{\mdseries\slshape r}} (a vector of the codeword type) to decode \mbox{\texttt{\mdseries\slshape r}} to an information vector. A normal decoder would take a codeword \mbox{\texttt{\mdseries\slshape r}} of the same word length and field as \mbox{\texttt{\mdseries\slshape C}}, and would return an information vector of length $k$, the dimension of \mbox{\texttt{\mdseries\slshape C}}. The user is not restricted to these normal demands though, and can for
instance define a decoder for non-linear codes. 

 Encoding is done by multiplying the information vector with the code (see \ref{Operations for Codes}). }

 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>A @gapinput|C := HammingCode(3);A
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  @gapprompt|gap>A @gapinput|c := "1010"*C;                    # encodingA
  [ 1 0 1 1 0 1 0 ]
  @gapprompt|gap>A @gapinput|Decode(C, c);                     # decodingA
  [ 1 0 1 0 ]
  @gapprompt|gap>A @gapinput|Decode(C, Codeword("0010101"));A
  [ 1 1 0 1 ]                            # one error corrected
  @gapprompt|gap>A @gapinput|C!.SpecialDecoder := function(C, c)A
  @gapprompt|>A @gapinput|return NullWord(Dimension(C));A
  @gapprompt|>A @gapinput|end;A
  function ( C, c ) ... end
  @gapprompt|gap>A @gapinput|Decode(C, c);A
  [ 0 0 0 0 ]           # new decoder always returns null word 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Decodeword}}
\logpage{[ 4, 10, 2 ]}\nobreak
\hyperdef{L}{X7D870C9387C47D9F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Decodeword({\mdseries\slshape C, r})\index{Decodeword@\texttt{Decodeword}}
\label{Decodeword}
}\hfill{\scriptsize (function)}}\\


 \texttt{Decodeword} decodes \mbox{\texttt{\mdseries\slshape r}} (a 'received word') with respect to code \mbox{\texttt{\mdseries\slshape C}} and returns the codeword $c \in C$ closest to \mbox{\texttt{\mdseries\slshape r}}. Here \mbox{\texttt{\mdseries\slshape r}} can be a \textsf{GUAVA} codeword or a list of codewords. If the code record has a field
`specialDecoder', this special algorithm is used to decode the vector. Hamming
codes, generalized Reed-Solomon codes, and BCH codes have such a special
algorithm. (The algorithm used for BCH codes is the Sugiyama algorithm
described, for example, in section 5.4.3 of \cite{HP03}. The algorithm used for generalized Reed-Solomon codes is the ``interpolation
algorithm'' described for example in chapter 5 of \cite{JH04}.) If \mbox{\texttt{\mdseries\slshape C}} is linear and no special decoder field has been set then syndrome decoding is
used. Otherwise, when \mbox{\texttt{\mdseries\slshape C}} is non-linear, the nearest neighbor algorithm has been implemented (which
should only be used for small-sized codes). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := HammingCode(3);|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@c := "1010"*C;                    # encoding|
  [ 1 0 1 1 0 1 0 ]
  !gapprompt@gap>| !gapinput@Decodeword(C, c);                     # decoding|
  [ 1 0 1 1 0 1 0 ]
  gap>
  !gapprompt@gap>| !gapinput@R:=PolynomialRing(GF(11),["t"]);|
  GF(11)[t]
  !gapprompt@gap>| !gapinput@P:=List([1,3,4,5,7],i->Z(11)^i);|
  [ Z(11), Z(11)^3, Z(11)^4, Z(11)^5, Z(11)^7 ]
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedSolomonCode(P,3,R);|
  a linear [5,3,1..3]2  generalized Reed-Solomon code over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  3
  !gapprompt@gap>| !gapinput@c:=Random(C);|
  [ 0 9 6 2 1 ]
  !gapprompt@gap>| !gapinput@v:=Codeword("09620");|
  [ 0 9 6 2 0 ]
  !gapprompt@gap>| !gapinput@GeneralizedReedSolomonDecoderGao(C,v);|
  [ 0 9 6 2 1 ]
  !gapprompt@gap>| !gapinput@Decodeword(C,v); # calls the special interpolation decoder|
  [ 0 9 6 2 1 ]
  !gapprompt@gap>| !gapinput@G:=GeneratorMat(C);|
  [ [ Z(11)^0, 0*Z(11), 0*Z(11), Z(11)^8, Z(11)^9 ],
    [ 0*Z(11), Z(11)^0, 0*Z(11), Z(11)^0, Z(11)^8 ],
    [ 0*Z(11), 0*Z(11), Z(11)^0, Z(11)^3, Z(11)^8 ] ]
  !gapprompt@gap>| !gapinput@C1:=GeneratorMatCode(G,GF(11));|
  a linear [5,3,1..3]2 code defined by generator matrix over GF(11)
  !gapprompt@gap>| !gapinput@Decodeword(C,v); # calls syndrome decoding|
  [ 0 9 6 2 1 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralizedReedSolomonDecoderGao}}
\logpage{[ 4, 10, 3 ]}\nobreak
\hyperdef{L}{X7D48DE2A84474C6A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralizedReedSolomonDecoderGao({\mdseries\slshape C, r})\index{GeneralizedReedSolomonDecoderGao@\texttt{GeneralizedReedSolomonDecoderGao}}
\label{GeneralizedReedSolomonDecoderGao}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedReedSolomonDecoderGao} decodes \mbox{\texttt{\mdseries\slshape r}} (a 'received word') to a codeword $c \in C$ in a generalized Reed-Solomon code \mbox{\texttt{\mdseries\slshape C}} (see \texttt{GeneralizedReedSolomonCode} (\ref{GeneralizedReedSolomonCode})), closest to \mbox{\texttt{\mdseries\slshape r}}. Here \mbox{\texttt{\mdseries\slshape r}} must be a \textsf{GUAVA} codeword. If the code record does not have name `generalized Reed-Solomon
code' then an error is returned. Otherwise, the Gao decoder \cite{Gao03} is used to compute $c$. 

 For long codes, this method is faster in practice than the interpolation
method used in \texttt{Decodeword}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R:=PolynomialRing(GF(11),["t"]);|
  GF(11)[t]
  !gapprompt@gap>| !gapinput@P:=List([1,3,4,5,7],i->Z(11)^i);|
  [ Z(11), Z(11)^3, Z(11)^4, Z(11)^5, Z(11)^7 ]
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedSolomonCode(P,3,R);|
  a linear [5,3,1..3]2  generalized Reed-Solomon code over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  3
  !gapprompt@gap>| !gapinput@c:=Random(C);|
  [ 0 9 6 2 1 ]
  !gapprompt@gap>| !gapinput@v:=Codeword("09620");|
  [ 0 9 6 2 0 ]
  !gapprompt@gap>| !gapinput@GeneralizedReedSolomonDecoderGao(C,v); |
  [ 0 9 6 2 1 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralizedReedSolomonListDecoder}}
\logpage{[ 4, 10, 4 ]}\nobreak
\hyperdef{L}{X7CFF98D483502053}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralizedReedSolomonListDecoder({\mdseries\slshape C, r, tau})\index{GeneralizedReedSolomonListDecoder@\texttt{GeneralizedReedSolomonListDecoder}}
\label{GeneralizedReedSolomonListDecoder}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedReedSolomonListDecoder} implements Sudans list-decoding algorithm (see section 12.1 of \cite{JH04}) for ``low rate'' Reed-Solomon codes. It returns the list of all codewords in
C which are a distance of at most \mbox{\texttt{\mdseries\slshape tau}} from \mbox{\texttt{\mdseries\slshape r}} (a 'received word'). \mbox{\texttt{\mdseries\slshape C}} must be a generalized Reed-Solomon code \mbox{\texttt{\mdseries\slshape C}} (see \texttt{GeneralizedReedSolomonCode} (\ref{GeneralizedReedSolomonCode})) and \mbox{\texttt{\mdseries\slshape r}} must be a \textsf{GUAVA} codeword. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(16);|
  GF(2^4)
  gap>
  !gapprompt@gap>| !gapinput@a:=PrimitiveRoot(F);; b:=a^7;; b^4+b^3+1; |
  0*Z(2)
  !gapprompt@gap>| !gapinput@Pts:=List([0..14],i->b^i);|
  [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6, Z(2^4)^13, Z(2^2), Z(2^4)^12, Z(2^4)^4,
    Z(2^4)^11, Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4)^9, Z(2^4), Z(2^4)^8 ]
  !gapprompt@gap>| !gapinput@x:=X(F);;|
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,[x]);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R1);;|
  !gapprompt@gap>| !gapinput@y:=X(F,vars);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,[x,y]);;|
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedSolomonCode(Pts,3,R1); |
  a linear [15,3,1..13]10..12  generalized Reed-Solomon code over GF(16)
  !gapprompt@gap>| !gapinput@MinimumDistance(C); ## 6 error correcting|
  13
  !gapprompt@gap>| !gapinput@z:=Zero(F);;|
  !gapprompt@gap>| !gapinput@r:=[z,z,z,z,z,z,z,z,b^6,b^2,b^5,b^14,b,b^7,b^11];; |
  !gapprompt@gap>| !gapinput@r:=Codeword(r);|
  [ 0 0 0 0 0 0 0 0 a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  !gapprompt@gap>| !gapinput@cs:=GeneralizedReedSolomonListDecoder(C,r,2); time;|
  [ [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ],
    [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] ]
  250
  !gapprompt@gap>| !gapinput@c1:=cs[1]; c1 in C;|
  [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  true
  !gapprompt@gap>| !gapinput@c2:=cs[2]; c2 in C;|
  [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]
  true
  !gapprompt@gap>| !gapinput@WeightCodeword(c1-r);|
  7
  !gapprompt@gap>| !gapinput@WeightCodeword(c2-r);|
  7
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{BitFlipDecoder}}
\logpage{[ 4, 10, 5 ]}\nobreak
\hyperdef{L}{X80E17FA27DCAB676}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BitFlipDecoder({\mdseries\slshape C, r})\index{BitFlipDecoder@\texttt{BitFlipDecoder}}
\label{BitFlipDecoder}
}\hfill{\scriptsize (function)}}\\


 The iterative decoding method \texttt{BitFlipDecoder} must only be applied to LDPC codes. For more information on LDPC codes, refer
to Section \ref{LDPC}. For these codes, \texttt{BitFlipDecoder} decodes very quickly. (Warning: it can give wildly wrong results for arbitrary
binary linear codes.) The bit flipping algorithm is described for example in
Chapter 13 of \cite{JH04}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=HammingCode(4,GF(2));|
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  !gapprompt@gap>| !gapinput@c:=Random(C);|
  [ 0 0 0 1 0 0 1 0 0 1 1 0 1 0 1 ]
  !gapprompt@gap>| !gapinput@v:=List(c);|
  [ 0*Z(2), 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2),
    Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]
  !gapprompt@gap>| !gapinput@v[1]:=Z(2)+v[1]; # flip 1st bit of c to create an error|
  Z(2)^0
  !gapprompt@gap>| !gapinput@v:=Codeword(v);|
  [ 1 0 0 1 0 0 1 0 0 1 1 0 1 0 1 ]
  !gapprompt@gap>| !gapinput@BitFlipDecoder(C,v);|
  [ 0 0 0 1 0 0 1 0 0 1 1 0 1 0 1 ]
  
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NearestNeighborGRSDecodewords}}
\logpage{[ 4, 10, 6 ]}\nobreak
\hyperdef{L}{X7B88DEB37F28404A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NearestNeighborGRSDecodewords({\mdseries\slshape C, v, dist})\index{NearestNeighborGRSDecodewords@\texttt{NearestNeighborGRSDecodewords}}
\label{NearestNeighborGRSDecodewords}
}\hfill{\scriptsize (function)}}\\


 \texttt{NearestNeighborGRSDecodewords} finds all generalized Reed-Solomon codewords within distance \mbox{\texttt{\mdseries\slshape dist}} from \mbox{\texttt{\mdseries\slshape v}} \emph{and} the associated polynomial, using ``brute force''. Input: \mbox{\texttt{\mdseries\slshape v}} is a received vector (a \textsf{GUAVA} codeword), \mbox{\texttt{\mdseries\slshape C}} is a GRS code, \mbox{\texttt{\mdseries\slshape dist}} {\textgreater} 0 is the distance from \mbox{\texttt{\mdseries\slshape v}} to search in \mbox{\texttt{\mdseries\slshape C}}. Output: a list of pairs $[c,f(x)]$, where $wt(c-v)\leq dist-1$ and $c = (f(x_1),...,f(x_n))$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(16);|
  GF(2^4)
  !gapprompt@gap>| !gapinput@a:=PrimitiveRoot(F);; b:=a^7; b^4+b^3+1;|
  Z(2^4)^7
  0*Z(2)
  !gapprompt@gap>| !gapinput@Pts:=List([0..14],i->b^i);|
  [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6, Z(2^4)^13, Z(2^2), Z(2^4)^12,
    Z(2^4)^4, Z(2^4)^11, Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4)^9, Z(2^4),
    Z(2^4)^8 ]
  !gapprompt@gap>| !gapinput@x:=X(F);;|
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,[x]);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R1);;|
  !gapprompt@gap>| !gapinput@y:=X(F,vars);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,[x,y]);;|
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedSolomonCode(Pts,3,R1);|
  a linear [15,3,1..13]10..12  generalized Reed-Solomon code over GF(16)
  !gapprompt@gap>| !gapinput@MinimumDistance(C); # 6 error correcting|
  13
  !gapprompt@gap>| !gapinput@z:=Zero(F);|
  0*Z(2)
  !gapprompt@gap>| !gapinput@r:=[z,z,z,z,z,z,z,z,b^6,b^2,b^5,b^14,b,b^7,b^11];; # 7 errors|
  !gapprompt@gap>| !gapinput@r:=Codeword(r);|
  [ 0 0 0 0 0 0 0 0 a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  !gapprompt@gap>| !gapinput@cs:=NearestNeighborGRSDecodewords(C,r,7);|
  [ [ [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ], 0*Z(2) ],
    [ [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ], x_1+Z(2)^0 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NearestNeighborDecodewords}}
\logpage{[ 4, 10, 7 ]}\nobreak
\hyperdef{L}{X825E35757D778787}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NearestNeighborDecodewords({\mdseries\slshape C, v, dist})\index{NearestNeighborDecodewords@\texttt{NearestNeighborDecodewords}}
\label{NearestNeighborDecodewords}
}\hfill{\scriptsize (function)}}\\


 \texttt{NearestNeighborDecodewords} finds all codewords in a linear code \mbox{\texttt{\mdseries\slshape C}} within distance \mbox{\texttt{\mdseries\slshape dist}} from \mbox{\texttt{\mdseries\slshape v}}, using ``brute force''. Input: \mbox{\texttt{\mdseries\slshape v}} is a received vector (a \textsf{GUAVA} codeword), \mbox{\texttt{\mdseries\slshape C}} is a linear code, \mbox{\texttt{\mdseries\slshape dist}} {\textgreater} 0 is the distance from \mbox{\texttt{\mdseries\slshape v}} to search in \mbox{\texttt{\mdseries\slshape C}}. Output: a list of $c \in C$, where $wt(c-v)\leq dist-1$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(16);|
  GF(2^4)
  !gapprompt@gap>| !gapinput@a:=PrimitiveRoot(F);; b:=a^7; b^4+b^3+1;|
  Z(2^4)^7
  0*Z(2)
  !gapprompt@gap>| !gapinput@Pts:=List([0..14],i->b^i);|
  [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6, Z(2^4)^13, Z(2^2), Z(2^4)^12,
    Z(2^4)^4, Z(2^4)^11, Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4)^9, Z(2^4),
    Z(2^4)^8 ]
  !gapprompt@gap>| !gapinput@x:=X(F);;|
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,[x]);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R1);;|
  !gapprompt@gap>| !gapinput@y:=X(F,vars);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,[x,y]);;|
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedSolomonCode(Pts,3,R1);|
  a linear [15,3,1..13]10..12  generalized Reed-Solomon code over GF(16)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  13
  !gapprompt@gap>| !gapinput@z:=Zero(F);|
  0*Z(2)
  !gapprompt@gap>| !gapinput@r:=[z,z,z,z,z,z,z,z,b^6,b^2,b^5,b^14,b,b^7,b^11];;|
  !gapprompt@gap>| !gapinput@r:=Codeword(r);|
  [ 0 0 0 0 0 0 0 0 a^12 a^14 a^5 a^8 a^7 a^4 a^2 ]
  !gapprompt@gap>| !gapinput@cs:=NearestNeighborDecodewords(C,r,7);|
  [ [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ], 
    [ 0 a^9 a^3 a^13 a^6 a^10 a^11 a a^12 a^14 a^5 a^8 a^7 a^4 a^2 ] ]
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{Syndrome}}
\logpage{[ 4, 10, 8 ]}\nobreak
\hyperdef{L}{X7D02E0FE8735D3E6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Syndrome({\mdseries\slshape C, v})\index{Syndrome@\texttt{Syndrome}}
\label{Syndrome}
}\hfill{\scriptsize (function)}}\\


 \texttt{Syndrome} returns the syndrome of word \mbox{\texttt{\mdseries\slshape v}} with respect to a linear code \mbox{\texttt{\mdseries\slshape C}}. \mbox{\texttt{\mdseries\slshape v}} is a codeword in the ambient vector space of \mbox{\texttt{\mdseries\slshape C}}. If \mbox{\texttt{\mdseries\slshape v}} is an element of \mbox{\texttt{\mdseries\slshape C}}, the syndrome is a zero vector. The syndrome can be used for looking up an
error vector in the syndrome table (see \texttt{SyndromeTable} (\ref{SyndromeTable})) that is needed to correct an error in $v$. 

 A syndrome is not defined for non-linear codes. \texttt{Syndrome} then returns an error. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := HammingCode(4);|
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  !gapprompt@gap>| !gapinput@v := CodewordNr( C, 7 );|
  [ 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 ]
  !gapprompt@gap>| !gapinput@Syndrome( C, v );|
  [ 0 0 0 0 ]
  !gapprompt@gap>| !gapinput@Syndrome( C, Codeword( "000000001100111" ) );|
  [ 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@Syndrome( C, Codeword( "000000000000001" ) );|
  [ 1 1 1 1 ]    # the same syndrome: both codewords are in the same
                 # coset of C 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{SyndromeTable}}
\logpage{[ 4, 10, 9 ]}\nobreak
\hyperdef{L}{X7B9E71987E4294A7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SyndromeTable({\mdseries\slshape C})\index{SyndromeTable@\texttt{SyndromeTable}}
\label{SyndromeTable}
}\hfill{\scriptsize (function)}}\\


 \texttt{SyndromeTable} returns a \emph{syndrome table} of a linear code \mbox{\texttt{\mdseries\slshape C}}, consisting of two columns. The first column consists of the error vectors
that correspond to the syndrome vectors in the second column. These vectors
both are of the codeword type. After calculating the syndrome of a word \mbox{\texttt{\mdseries\slshape v}} with \texttt{Syndrome} (see \texttt{Syndrome} (\ref{Syndrome})), the error vector needed to correct \mbox{\texttt{\mdseries\slshape v}} can be found in the syndrome table. Subtracting this vector from \mbox{\texttt{\mdseries\slshape v}} yields an element of \mbox{\texttt{\mdseries\slshape C}}. To make the search for the syndrome as fast as possible, the syndrome table
is sorted according to the syndrome vectors. }

 \index{syndrome table} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H := HammingCode(2);|
  a linear [3,1,3]1 Hamming (2,2) code over GF(2)
  !gapprompt@gap>| !gapinput@SyndromeTable(H);|
  [ [ [ 0 0 0 ], [ 0 0 ] ], [ [ 1 0 0 ], [ 0 1 ] ],
    [ [ 0 1 0 ], [ 1 0 ] ], [ [ 0 0 1 ], [ 1 1 ] ] ]
  !gapprompt@gap>| !gapinput@c := Codeword("101");|
  [ 1 0 1 ]
  !gapprompt@gap>| !gapinput@c in H;|
  false          # c is not an element of H
  !gapprompt@gap>| !gapinput@Syndrome(H,c);|
  [ 1 0 ]        # according to the syndrome table,
                 # the error vector [ 0 1 0 ] belongs to this syndrome
  !gapprompt@gap>| !gapinput@c - Codeword("010") in H;|
  true           # so the corrected codeword is
                 # [ 1 0 1 ] - [ 0 1 0 ] = [ 1 1 1 ],
                 # this is an element of H 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{StandardArray}}
\logpage{[ 4, 10, 10 ]}\nobreak
\hyperdef{L}{X8642D0BD789DA9B5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StandardArray({\mdseries\slshape C})\index{StandardArray@\texttt{StandardArray}}
\label{StandardArray}
}\hfill{\scriptsize (function)}}\\


 \texttt{StandardArray} returns the standard array of a code \mbox{\texttt{\mdseries\slshape C}}. This is a matrix with elements of the codeword type. It has $q^r$ rows and $q^k$ columns, where $q$ is the size of the base field of \mbox{\texttt{\mdseries\slshape C}}, $r=n-k$ is the redundancy of \mbox{\texttt{\mdseries\slshape C}}, and $k$ is the dimension of \mbox{\texttt{\mdseries\slshape C}}. The first row contains all the elements of \mbox{\texttt{\mdseries\slshape C}}. Each other row contains words that do not belong to the code, with in the
first column their syndrome vector (see \texttt{Syndrome} (\ref{Syndrome})). 

 A non-linear code does not have a standard array. \texttt{StandardArray} then returns an error. 

 Note that calculating a standard array can be very time- and memory-
consuming. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@StandardArray(RepetitionCode(3)); |
  [ [ [ 0 0 0 ], [ 1 1 1 ] ], [ [ 0 0 1 ], [ 1 1 0 ] ], 
    [ [ 0 1 0 ], [ 1 0 1 ] ], [ [ 1 0 0 ], [ 0 1 1 ] ] ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PermutationDecode}}
\logpage{[ 4, 10, 11 ]}\nobreak
\hyperdef{L}{X83231E717CCB0247}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PermutationDecode({\mdseries\slshape C, v})\index{PermutationDecode@\texttt{PermutationDecode}}
\label{PermutationDecode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutationDecode} performs permutation decoding when possible and returns original vector and
prints 'fail' when not possible. 

 This uses \texttt{AutomorphismGroup} in the binary case, and (the slower) \texttt{PermutationAutomorphismGroup} otherwise, to compute the permutation automorphism group $P$ of \mbox{\texttt{\mdseries\slshape C}}. The algorithm runs through the elements $p$ of $P$ checking if the weight of $H(p\cdot v)$ is less than $(d-1)/2$. If it is then the vector $p\cdot v$ is used to decode $v$: assuming \mbox{\texttt{\mdseries\slshape C}} is in standard form then $c=p^{-1}Em$ is the decoded word, where $m$ is the information digits part of $p\cdot v$. If no such $p$ exists then ``fail'' is returned. See, for example, section 10.2 of Huffman
and Pless \cite{HP03} for more details. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C0:=HammingCode(3,GF(2));|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@G0:=GeneratorMat(C0);;|
  !gapprompt@gap>| !gapinput@G := List(G0, ShallowCopy);;|
  !gapprompt@gap>| !gapinput@PutStandardForm(G);|
  ()
  !gapprompt@gap>| !gapinput@Display(G);|
   1 . . . . 1 1
   . 1 . . 1 . 1
   . . 1 . 1 1 .
   . . . 1 1 1 1
  !gapprompt@gap>| !gapinput@H0:=CheckMat(C0);;|
  !gapprompt@gap>| !gapinput@Display(H0);|
   . . . 1 1 1 1
   . 1 1 . . 1 1
   1 . 1 . 1 . 1
  !gapprompt@gap>| !gapinput@c0:=Random(C0);|
  [ 0 0 0 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@v01:=c0[1]+Z(2)^2;;|
  !gapprompt@gap>| !gapinput@v1:=List(c0, ShallowCopy);;|
  !gapprompt@gap>| !gapinput@v1[1]:=v01;;|
  !gapprompt@gap>| !gapinput@v1:=Codeword(v1);|
  [ 1 0 0 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@c1:=PermutationDecode(C0,v1);|
  [ 0 0 0 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@c1=c0;|
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{PermutationDecodeNC}}
\logpage{[ 4, 10, 12 ]}\nobreak
\hyperdef{L}{X85B692177E2A745D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PermutationDecodeNC({\mdseries\slshape C, v, P})\index{PermutationDecodeNC@\texttt{PermutationDecodeNC}}
\label{PermutationDecodeNC}
}\hfill{\scriptsize (function)}}\\


 Same as \texttt{PermutationDecode} except that one may enter the permutation automorphism group \mbox{\texttt{\mdseries\slshape P}} in as an argument, saving time. Here \mbox{\texttt{\mdseries\slshape P}} is a subgroup of the symmetric group on $n$ letters, where $n$ is the word length of \mbox{\texttt{\mdseries\slshape C}}. }

 }

 }

 
\chapter{\textcolor{Chapter }{Generating Codes}}\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X87EB64ED831CCE99}{}
{
  \label{Generating Codes} In this chapter we describe functions for generating codes. 

 Section \ref{Generating Unrestricted Codes} describes functions for generating unrestricted codes. 

 Section \ref{Generating Linear Codes} describes functions for generating linear codes. 

 Section \ref{Gabidulin Codes} describes functions for constructing certain covering codes, such as the
Gabidulin codes. 

 Section \ref{Golay Codes} describes functions for constructing the Golay codes. 

 Section \ref{Generating Cyclic Codes} describes functions for generating cyclic codes. 

 Section \ref{Evaluation Codes} describes functions for generating codes as the image of an evaluation map
applied to a space of functions. For example, generalized Reed-Solomon codes
and toric codes are described there. 

 Section \ref{Algebraic geometric codes} describes functions for generating algebraic geometry codes. 

 Section \ref{LDPC} describes functions for constructing low-density parity-check (LDPC) codes. 
\section{\textcolor{Chapter }{ Generating Unrestricted Codes }}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X86A92CB184CBD3C7}{}
{
  \label{Generating Unrestricted Codes} In this section we start with functions that creating code from user defined
matrices or special matrices (see \texttt{ElementsCode} (\ref{ElementsCode}), \texttt{HadamardCode} (\ref{HadamardCode}), \texttt{ConferenceCode} (\ref{ConferenceCode}) and \texttt{MOLSCode} (\ref{MOLSCode})). These codes are unrestricted codes; they may later be discovered to be
linear or cyclic. 

 The next functions generate random codes (see \texttt{RandomCode} (\ref{RandomCode})) and the Nordstrom-Robinson code (see \texttt{NordstromRobinsonCode} (\ref{NordstromRobinsonCode})), respectively. 

 Finally, we describe two functions for generating Greedy codes. These are
codes that contructed by gathering codewords from a space (see \texttt{GreedyCode} (\ref{GreedyCode}) and \texttt{LexiCode} (\ref{LexiCode})). 

\subsection{\textcolor{Chapter }{ElementsCode}}
\logpage{[ 5, 1, 1 ]}\nobreak
\hyperdef{L}{X81AACBDD86E89D7D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ElementsCode({\mdseries\slshape L[, name], F})\index{ElementsCode@\texttt{ElementsCode}}
\label{ElementsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ElementsCode} creates an unrestricted code of the list of elements \mbox{\texttt{\mdseries\slshape L}}, in the field \mbox{\texttt{\mdseries\slshape F}}. \mbox{\texttt{\mdseries\slshape L}} must be a list of vectors, strings, polynomials or codewords. \mbox{\texttt{\mdseries\slshape name}} can contain a short description of the code. 

 If \mbox{\texttt{\mdseries\slshape L}} contains a codeword more than once, it is removed from the list and a GAP set
is returned. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := Z(3)^0 * [ [1, 0, 1, 1], [2, 2, 0, 0], [0, 1, 2, 2] ];;|
  !gapprompt@gap>| !gapinput@C := ElementsCode( M, "example code", GF(3) );|
  a (4,3,1..4)2 example code over GF(3)
  !gapprompt@gap>| !gapinput@MinimumDistance( C );|
  4
  !gapprompt@gap>| !gapinput@AsSSortedList( C );|
  [ [ 0 1 2 2 ], [ 1 0 1 1 ], [ 2 2 0 0 ] ]
\end{Verbatim}
  \index{code, Hadamard} 

\subsection{\textcolor{Chapter }{HadamardCode}}
\logpage{[ 5, 1, 2 ]}\nobreak
\hyperdef{L}{X86755AAC83A0AF4B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HadamardCode({\mdseries\slshape H[, t]})\index{HadamardCode@\texttt{HadamardCode}}
\label{HadamardCode}
}\hfill{\scriptsize (function)}}\\


 The four forms this command can take are \texttt{HadamardCode(H,t)}, \texttt{HadamardCode(H)}, \texttt{HadamardCode(n,t)}, and \texttt{HadamardCode(n)}. 

 In the case when the arguments \mbox{\texttt{\mdseries\slshape H}} and \mbox{\texttt{\mdseries\slshape t}} are both given, \texttt{HadamardCode} returns a Hadamard code of the $t^{th}$ kind from the Hadamard matrix \mbox{\texttt{\mdseries\slshape H}} In case only \mbox{\texttt{\mdseries\slshape H}} is given, $t = 3$ is used. 

 By definition, a Hadamard matrix is a square matrix \mbox{\texttt{\mdseries\slshape H}} with $H\cdot H^T = -n\cdot I_n$, where $n$ is the size of \mbox{\texttt{\mdseries\slshape H}}. The entries of \mbox{\texttt{\mdseries\slshape H}} are either 1 or -1. \index{Hadamard matrix} 

 The matrix \mbox{\texttt{\mdseries\slshape H}} is first transformed into a binary matrix $A_n$ by replacing the $1$'s by $0$'s and the $-1$'s by $1$s). 

 The Hadamard matrix of the \emph{first kind} ($t=1$) is created by using the rows of $A_n$ as elements, after deleting the first column. This is a $(n-1, n, n/2)$ code. We use this code for creating the Hadamard code of the \emph{second kind} ($t=2$), by adding all the complements of the already existing codewords. This
results in a $(n-1, 2n, n/2 -1)$ code. The \emph{third kind} ($t=3$) is created by using the rows of $A_n$ (without cutting a column) and their complements as elements. This way, we
have an $(n, 2n, n/2)$-code. The returned code is generally an unrestricted code, but for $n = 2^r$, the code is linear. 

 The command \texttt{HadamardCode(n,t)} returns a Hadamard code with parameter \mbox{\texttt{\mdseries\slshape n}} of the $t^{th}$ kind. For the command \texttt{HadamardCode(n)}, $t=3$ is used. 

 When called in these forms, \texttt{HadamardCode} first creates a Hadamard matrix (see \texttt{HadamardMat} (\ref{HadamardMat})), of size \mbox{\texttt{\mdseries\slshape n}} and then follows the same procedure as described above. Therefore the same
restrictions with respect to \mbox{\texttt{\mdseries\slshape n}} as for Hadamard matrices hold. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H4 := [[1,1,1,1],[1,-1,1,-1],[1,1,-1,-1],[1,-1,-1,1]];;|
  !gapprompt@gap>| !gapinput@HadamardCode( H4, 1 );|
  a (3,4,2)1 Hadamard code of order 4 over GF(2)
  !gapprompt@gap>| !gapinput@HadamardCode( H4, 2 );|
  a (3,8,1)0 Hadamard code of order 4 over GF(2)
  !gapprompt@gap>| !gapinput@HadamardCode( H4 );|
  a (4,8,2)1 Hadamard code of order 4 over GF(2) 
  !gapprompt@gap>| !gapinput@H4 := [[1,1,1,1],[1,-1,1,-1],[1,1,-1,-1],[1,-1,-1,1]];;|
  !gapprompt@gap>| !gapinput@C := HadamardCode( 4 );|
  a (4,8,2)1 Hadamard code of order 4 over GF(2)
  !gapprompt@gap>| !gapinput@C = HadamardCode( H4 );|
  true 
\end{Verbatim}
  \index{code, conference} 

\subsection{\textcolor{Chapter }{ConferenceCode}}
\logpage{[ 5, 1, 3 ]}\nobreak
\hyperdef{L}{X8122BA417F705997}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConferenceCode({\mdseries\slshape H})\index{ConferenceCode@\texttt{ConferenceCode}}
\label{ConferenceCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ConferenceCode} returns a code of length $n-1$ constructed from a symmetric 'conference matrix' \mbox{\texttt{\mdseries\slshape H}}. A \emph{conference matrix} \mbox{\texttt{\mdseries\slshape H}} is a symmetric matrix of order $n$, which satisfies $H\cdot H^T = ((n-1)\cdot I$, with $n \equiv 2 \pmod 4$. The rows of $\frac{1}{2}(H+I+J)$, $\frac{1}{2}(-H+I+J)$, plus the zero and all-ones vectors form the elements of a binary non-linear $(n-1, 2n, (n-2)/2)$ code. \index{conference matrix} 

 \textsf{GUAVA} constructs a symmetric conference matrix of order $n+1$ ($n\equiv 1 \pmod 4$) and uses the rows of that matrix, plus the zero and all-ones vectors, to
construct a binary non-linear $(n, 2(n+1), (n-1)/2)$-code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H6 := [[0,1,1,1,1,1],[1,0,1,-1,-1,1],[1,1,0,1,-1,-1],|
  !gapprompt@>| !gapinput@[1,-1,1,0,1,-1],[1,-1,-1,1,0,1],[1,1,-1,-1,1,0]];;|
  !gapprompt@gap>| !gapinput@C1 := ConferenceCode( H6 );|
  a (5,12,2)1..4 conference code over GF(2)
  !gapprompt@gap>| !gapinput@IsLinearCode( C1 );|
  false 
  !gapprompt@gap>| !gapinput@C2 := ConferenceCode( 5 );|
  a (5,12,2)1..4 conference code over GF(2)
  !gapprompt@gap>| !gapinput@AsSSortedList( C2 );|
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 1 1 ], [ 0 1 1 0 1 ], [ 0 1 1 1 0 ], 
    [ 1 0 0 1 1 ], [ 1 0 1 0 1 ], [ 1 0 1 1 0 ], [ 1 1 0 0 1 ], [ 1 1 0 1 0 ], 
    [ 1 1 1 0 0 ], [ 1 1 1 1 1 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MOLSCode}}
\logpage{[ 5, 1, 4 ]}\nobreak
\hyperdef{L}{X81B7EE4279398F67}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MOLSCode({\mdseries\slshape [n, ]q})\index{MOLSCode@\texttt{MOLSCode}}
\label{MOLSCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{MOLSCode} returns an $(n, q^2, n-1)$ code over $GF(q)$. The code is created from $n-2$ 'Mutually Orthogonal Latin Squares' (MOLS) of size $q \times q$. The default for \mbox{\texttt{\mdseries\slshape n}} is $4$. \textsf{GUAVA} can construct a MOLS code for $n-2 \leq q$. Here \mbox{\texttt{\mdseries\slshape q}} must be a prime power, $q > 2$. If there are no $n-2$ MOLS, an error is signalled. 

 Since each of the $n-2$ MOLS is a $q\times q$ matrix, we can create a code of size $q^2$ by listing in each code element the entries that are in the same position in
each of the MOLS. We precede each of these lists with the two coordinates that
specify this position, making the word length become $n$. 

 The MOLS codes are MDS codes (see \texttt{IsMDSCode} (\ref{IsMDSCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := MOLSCode( 6, 5 );|
  a (6,25,5)3..4 code generated by 4 MOLS of order 5 over GF(5)
  !gapprompt@gap>| !gapinput@mols := List( [1 .. WordLength(C1) - 2 ], function( nr )|
  !gapprompt@>| !gapinput@      local ls, el;|
  !gapprompt@>| !gapinput@      ls := NullMat( Size(LeftActingDomain(C1)), Size(LeftActingDomain(C1)) );|
  !gapprompt@>| !gapinput@      for el in VectorCodeword( AsSSortedList( C1 ) ) do|
  !gapprompt@>| !gapinput@         ls[IntFFE(el[1])+1][IntFFE(el[2])+1] := el[nr + 2];|
  !gapprompt@>| !gapinput@      od;|
  !gapprompt@>| !gapinput@      return ls;|
  !gapprompt@>| !gapinput@   end );;|
  !gapprompt@gap>| !gapinput@AreMOLS( mols );|
  true
  !gapprompt@gap>| !gapinput@C2 := MOLSCode( 11 );|
  a (4,121,3)2 code generated by 2 MOLS of order 11 over GF(11) 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RandomCode}}
\logpage{[ 5, 1, 5 ]}\nobreak
\hyperdef{L}{X7D87DD6380B2CE69}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RandomCode({\mdseries\slshape n, M, F})\index{RandomCode@\texttt{RandomCode}}
\label{RandomCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RandomCode} returns a random unrestricted code of size \mbox{\texttt{\mdseries\slshape M}} with word length \mbox{\texttt{\mdseries\slshape n}} over \mbox{\texttt{\mdseries\slshape F}}. \mbox{\texttt{\mdseries\slshape M}} must be less than or equal to the number of elements in the space $GF(q)^n$. 

 The function \texttt{RandomLinearCode} returns a random linear code (see \texttt{RandomLinearCode} (\ref{RandomLinearCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := RandomCode( 6, 10, GF(8) );|
  a (6,10,1..6)4..6 random unrestricted code over GF(8)
  !gapprompt@gap>| !gapinput@MinimumDistance(C1);|
  3
  !gapprompt@gap>| !gapinput@C2 := RandomCode( 6, 10, GF(8) );|
  a (6,10,1..6)4..6 random unrestricted code over GF(8)
  !gapprompt@gap>| !gapinput@C1 = C2;|
  false 
\end{Verbatim}
 \index{code, Nordstrom-Robinson} 

\subsection{\textcolor{Chapter }{NordstromRobinsonCode}}
\logpage{[ 5, 1, 6 ]}\nobreak
\hyperdef{L}{X816353397F25B62E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NordstromRobinsonCode({\mdseries\slshape })\index{NordstromRobinsonCode@\texttt{NordstromRobinsonCode}}
\label{NordstromRobinsonCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{NordstromRobinsonCode} returns a Nordstrom-Robinson code, the best code with word length $n=16$ and minimum distance $d=6$ over $GF(2)$. This is a non-linear $(16, 256, 6)$ code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := NordstromRobinsonCode();|
  a (16,256,6)4 Nordstrom-Robinson code over GF(2)
  !gapprompt@gap>| !gapinput@OptimalityCode( C );|
  0 
\end{Verbatim}
 \index{code, greedy} 

\subsection{\textcolor{Chapter }{GreedyCode}}
\logpage{[ 5, 1, 7 ]}\nobreak
\hyperdef{L}{X7880D34485C60BAF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GreedyCode({\mdseries\slshape L, d, F})\index{GreedyCode@\texttt{GreedyCode}}
\label{GreedyCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GreedyCode} returns a Greedy code with design distance \mbox{\texttt{\mdseries\slshape d}} over the finite field \mbox{\texttt{\mdseries\slshape F}}. The code is constructed using the greedy algorithm on the list of vectors \mbox{\texttt{\mdseries\slshape L}}. (The greedy algorithm checks each vector in \mbox{\texttt{\mdseries\slshape L}} and adds it to the code if its distance to the current code is greater than or
equal to \mbox{\texttt{\mdseries\slshape d}}. It is obvious that the resulting code has a minimum distance of at least \mbox{\texttt{\mdseries\slshape d}}. 

 Greedy codes are often linear codes. 

 The function \texttt{LexiCode} creates a greedy code from a basis instead of an enumerated list (see \texttt{LexiCode} (\ref{LexiCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := GreedyCode( Tuples( AsSSortedList( GF(2) ), 5 ), 3, GF(2) );|
  a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
  !gapprompt@gap>| !gapinput@C2 := GreedyCode( Permuted( Tuples( AsSSortedList( GF(2) ), 5 ),|
  !gapprompt@>| !gapinput@                        (1,4) ), 3, GF(2) );|
  a (5,4,3..5)2 Greedy code, user defined basis over GF(2)
  !gapprompt@gap>| !gapinput@C1 = C2;|
  false 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{LexiCode}}
\logpage{[ 5, 1, 8 ]}\nobreak
\hyperdef{L}{X7C1B374583AFB923}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LexiCode({\mdseries\slshape n, d, F})\index{LexiCode@\texttt{LexiCode}}
\label{LexiCode}
}\hfill{\scriptsize (function)}}\\


 In this format, \texttt{Lexicode} returns a lexicode with word length \mbox{\texttt{\mdseries\slshape n}}, design distance \mbox{\texttt{\mdseries\slshape d}} over \mbox{\texttt{\mdseries\slshape F}}. The code is constructed using the greedy algorithm on the lexicographically
ordered list of all vectors of length \mbox{\texttt{\mdseries\slshape n}} over \mbox{\texttt{\mdseries\slshape F}}. Every time a vector is found that has a distance to the current code of at
least \mbox{\texttt{\mdseries\slshape d}}, it is added to the code. This results, obviously, in a code with minimum
distance greater than or equal to \mbox{\texttt{\mdseries\slshape d}}. 

 Another syntax which one can use is \texttt{LexiCode( B, d, F )}. When called in this format, \texttt{LexiCode} uses the basis \mbox{\texttt{\mdseries\slshape B}} instead of the standard basis. \mbox{\texttt{\mdseries\slshape B}} is a matrix of vectors over \mbox{\texttt{\mdseries\slshape F}}. The code is constructed using the greedy algorithm on the list of vectors
spanned by \mbox{\texttt{\mdseries\slshape B}}, ordered lexicographically with respect to \mbox{\texttt{\mdseries\slshape B}}. 

 Note that binary lexicodes are always linear. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := LexiCode( 4, 3, GF(5) );|
  a (4,17,3..4)2..4 lexicode over GF(5) 
  !gapprompt@gap>| !gapinput@B := [ [Z(2)^0, 0*Z(2), 0*Z(2)], [Z(2)^0, Z(2)^0, 0*Z(2)] ];;|
  !gapprompt@gap>| !gapinput@C := LexiCode( B, 2, GF(2) );|
  a linear [3,1,2]1..2 lexicode over GF(2) 
\end{Verbatim}
 The function \texttt{GreedyCode} creates a greedy code that is not restricted to a lexicographical order (see \texttt{GreedyCode} (\ref{GreedyCode})). }

 
\section{\textcolor{Chapter }{ Generating Linear Codes }}\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7A11F29F7BBF45BB}{}
{
  \label{Generating Linear Codes} In this section we describe functions for constructing linear codes. A linear
code always has a generator or check matrix. 

 The first two functions generate linear codes from the generator matrix (\texttt{GeneratorMatCode} (\ref{GeneratorMatCode})) or check matrix (\texttt{CheckMatCode} (\ref{CheckMatCode})). All linear codes can be constructed with these functions. 

 The next functions we describe generate some well-known codes, like Hamming
codes (\texttt{HammingCode} (\ref{HammingCode})), Reed-Muller codes (\texttt{ReedMullerCode} (\ref{ReedMullerCode})) and the extended Golay codes (\texttt{ExtendedBinaryGolayCode} (\ref{ExtendedBinaryGolayCode}) and \texttt{ExtendedTernaryGolayCode} (\ref{ExtendedTernaryGolayCode})). 

 A large and powerful family of codes are alternant codes. They are obtained by
a small modification of the parity check matrix of a BCH code (see \texttt{AlternantCode} (\ref{AlternantCode}), \texttt{GoppaCode} (\ref{GoppaCode}), \texttt{GeneralizedSrivastavaCode} (\ref{GeneralizedSrivastavaCode}) and \texttt{SrivastavaCode} (\ref{SrivastavaCode})). 

 Finally, we describe a function for generating random linear codes (see \texttt{RandomLinearCode} (\ref{RandomLinearCode})). 

 

\subsection{\textcolor{Chapter }{GeneratorMatCode}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X83F400A681CFC0D6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneratorMatCode({\mdseries\slshape G[, name], F})\index{GeneratorMatCode@\texttt{GeneratorMatCode}}
\label{GeneratorMatCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorMatCode} returns a linear code with generator matrix \mbox{\texttt{\mdseries\slshape G}}. \mbox{\texttt{\mdseries\slshape G}} must be a matrix over finite field \mbox{\texttt{\mdseries\slshape F}}. \mbox{\texttt{\mdseries\slshape name}} can contain a short description of the code. The generator matrix is the basis
of the elements of the code. The resulting code has word length $n$, dimension $k$ if \mbox{\texttt{\mdseries\slshape G}} is a $k \times n$-matrix. If $GF(q)$ is the field of the code, the size of the code will be $q^k$. 

 If the generator matrix does not have full row rank, the linearly dependent
rows are removed. This is done by the GAP function \texttt{BaseMat} and results in an equal code. The generator matrix can be retrieved with the
function \texttt{GeneratorMat} (see \texttt{GeneratorMat} (\ref{GeneratorMat})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;|
  !gapprompt@gap>| !gapinput@C1 := GeneratorMatCode( G, GF(3) );|
  a linear [5,3,1..2]1..2 code defined by generator matrix over GF(3)
  !gapprompt@gap>| !gapinput@C2 := GeneratorMatCode( IdentityMat( 5, GF(2) ), GF(2) );|
  a linear [5,5,1]0 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@GeneratorMatCode( List( AsSSortedList( NordstromRobinsonCode() ),|
  !gapprompt@>| !gapinput@x -> VectorCodeword( x ) ), GF( 2 ) );|
  a linear [16,11,1..4]2 code defined by generator matrix over GF(2)
  # This is the smallest linear code that contains the N-R code 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckMatCodeMutable}}
\logpage{[ 5, 2, 2 ]}\nobreak
\hyperdef{L}{X7CDDDFE47A10A008}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CheckMatCodeMutable({\mdseries\slshape H[, name], F})\index{CheckMatCodeMutable@\texttt{CheckMatCodeMutable}}
\label{CheckMatCodeMutable}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckMatCodeMutable} is the same as \texttt{CheckMatCode} except that the check matrix and generator matrix are mutable. }

 

\subsection{\textcolor{Chapter }{CheckMatCode}}
\logpage{[ 5, 2, 3 ]}\nobreak
\hyperdef{L}{X848D3F7B805DEB66}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CheckMatCode({\mdseries\slshape H[, name], F})\index{CheckMatCode@\texttt{CheckMatCode}}
\label{CheckMatCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckMatCode} returns a linear code with check matrix \mbox{\texttt{\mdseries\slshape H}}. \mbox{\texttt{\mdseries\slshape H}} must be a matrix over Galois field \mbox{\texttt{\mdseries\slshape F}}. \mbox{\texttt{\mdseries\slshape [name.}} can contain a short description of the code. The parity check matrix is the
transposed of the nullmatrix of the generator matrix of the code. Therefore, $c\cdot H^T = 0$ where $c$ is an element of the code. If \mbox{\texttt{\mdseries\slshape H}} is a $r\times n$-matrix, the code has word length $n$, redundancy $r$ and dimension $n-r$. 

 If the check matrix does not have full row rank, the linearly dependent rows
are removed. This is done by the GAP function \texttt{BaseMat}. and results in an equal code. The check matrix can be retrieved with the
function \texttt{CheckMat} (see \texttt{CheckMat} (\ref{CheckMat})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := Z(3)^0 * [[1,0,1,2,0],[0,1,2,1,1],[0,0,1,2,1]];;|
  !gapprompt@gap>| !gapinput@C1 := CheckMatCode( G, GF(3) );|
  a linear [5,2,1..2]2..3 code defined by check matrix over GF(3)
  !gapprompt@gap>| !gapinput@CheckMat(C1);|
  [ [ Z(3)^0, 0*Z(3), Z(3)^0, Z(3), 0*Z(3) ],
    [ 0*Z(3), Z(3)^0, Z(3), Z(3)^0, Z(3)^0 ],
    [ 0*Z(3), 0*Z(3), Z(3)^0, Z(3), Z(3)^0 ] ]
  !gapprompt@gap>| !gapinput@C2 := CheckMatCode( IdentityMat( 5, GF(2) ), GF(2) );|
  a cyclic [5,0,5]5 code defined by check matrix over GF(2)
\end{Verbatim}
  \index{code, Hamming} 

\subsection{\textcolor{Chapter }{HammingCode}}
\logpage{[ 5, 2, 4 ]}\nobreak
\hyperdef{L}{X7DECB0A57C798583}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HammingCode({\mdseries\slshape r, F})\index{HammingCode@\texttt{HammingCode}}
\label{HammingCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{HammingCode} returns a Hamming code with redundancy \mbox{\texttt{\mdseries\slshape r}} over \mbox{\texttt{\mdseries\slshape F}}. A Hamming code is a single-error-correcting code. The parity check matrix of
a Hamming code has all nonzero vectors of length \mbox{\texttt{\mdseries\slshape r}} in its columns, except for a multiplication factor. The decoding algorithm of
the Hamming code (see \texttt{Decode} (\ref{Decode})) makes use of this property. 

 If $q$ is the size of its field \mbox{\texttt{\mdseries\slshape F}}, the returned Hamming code is a linear $[(q^r-1)/(q-1), (q^r-1)/(q-1) - r, 3]$ code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := HammingCode( 4, GF(2) );|
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  !gapprompt@gap>| !gapinput@C2 := HammingCode( 3, GF(9) );|
  a linear [91,88,3]1 Hamming (3,9) code over GF(9) 
\end{Verbatim}
  \index{code, Reed-Muller} 

\subsection{\textcolor{Chapter }{ReedMullerCode}}
\logpage{[ 5, 2, 5 ]}\nobreak
\hyperdef{L}{X801C88D578DA6ACA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ReedMullerCode({\mdseries\slshape r, k})\index{ReedMullerCode@\texttt{ReedMullerCode}}
\label{ReedMullerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ReedMullerCode} returns a binary 'Reed-Muller code' \mbox{\texttt{\mdseries\slshape R(r, k)}} with dimension \mbox{\texttt{\mdseries\slshape k}} and order \mbox{\texttt{\mdseries\slshape r}}. This is a code with length $2^k$ and minimum distance $2^{k-r}$ (see for example, section 1.10 in \cite{HP03}). By definition, the $r^{th}$ order binary Reed-Muller code of length $n=2^m$, for $0 \leq r \leq m$, is the set of all vectors $f$, where $f$ is a Boolean function which is a polynomial of degree at most $r$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ReedMullerCode( 1, 3 );|
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 
\end{Verbatim}
  See \texttt{GeneralizedReedMullerCode} (\ref{GeneralizedReedMullerCode}) for a more general construction. \index{code, alternant} 

\subsection{\textcolor{Chapter }{AlternantCode}}
\logpage{[ 5, 2, 6 ]}\nobreak
\hyperdef{L}{X851592C7811D3D2A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AlternantCode({\mdseries\slshape r, Y[, alpha], F})\index{AlternantCode@\texttt{AlternantCode}}
\label{AlternantCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AlternantCode} returns an 'alternant code', with parameters \mbox{\texttt{\mdseries\slshape r}}, \mbox{\texttt{\mdseries\slshape Y}} and \mbox{\texttt{\mdseries\slshape alpha}} (optional). \mbox{\texttt{\mdseries\slshape F}} denotes the (finite) base field. Here, \mbox{\texttt{\mdseries\slshape r}} is the design redundancy of the code. \mbox{\texttt{\mdseries\slshape Y}} and \mbox{\texttt{\mdseries\slshape alpha}} are both vectors of length \mbox{\texttt{\mdseries\slshape n}} from which the parity check matrix is constructed. The check matrix has the
form $H=([a_i^j y_i])$, where $0 \leq j\leq r-1$, $1 \leq i\leq n$, and where $[...]$ is as in \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat})). If no \mbox{\texttt{\mdseries\slshape alpha}} is specified, the vector $[1, a, a^2, .., a^{n-1}]$ is used, where $a$ is a primitive element of a Galois field \mbox{\texttt{\mdseries\slshape F}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Y := [ 1, 1, 1, 1, 1, 1, 1];; a := PrimitiveUnityRoot( 2, 7 );;|
  !gapprompt@gap>| !gapinput@alpha := List( [0..6], i -> a^i );;|
  !gapprompt@gap>| !gapinput@C := AlternantCode( 2, Y, alpha, GF(8) );|
  a linear [7,3,3..4]3..4 alternant code over GF(8) 
\end{Verbatim}
  \index{code, Goppa (classical)} 

\subsection{\textcolor{Chapter }{GoppaCode}}
\logpage{[ 5, 2, 7 ]}\nobreak
\hyperdef{L}{X7EE808BB7D1E487A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoppaCode({\mdseries\slshape G, L})\index{GoppaCode@\texttt{GoppaCode}}
\label{GoppaCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GoppaCode} returns a Goppa code \mbox{\texttt{\mdseries\slshape C}} from Goppa polynomial \mbox{\texttt{\mdseries\slshape g}}, having coefficients in a Galois Field $GF(q)$. \mbox{\texttt{\mdseries\slshape L}} must be a list of elements in $GF(q)$, that are not roots of \mbox{\texttt{\mdseries\slshape g}}. The word length of the code is equal to the length of \mbox{\texttt{\mdseries\slshape L}}. The parity check matrix has the form $H=([a_i^j / G(a_i)])_{0 \leq j \leq deg(g)-1,\ a_i \in L}$, where $a_i\in L$ and $[...]$ is as in \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat}), so $H$ has entries in $GF(q)$, $q=p^m$. It is known that $d(C)\geq deg(g)+1$, with a better bound in the binary case provided $g$ has no multiple roots. See Huffman and Pless \cite{HP03} section 13.2.2, and MacWilliams and Sloane \cite{MS83} section 12.3, for more details. 

 One can also call \texttt{GoppaCode} using the syntax \texttt{GoppaCode(g,n)}. When called with parameter \mbox{\texttt{\mdseries\slshape n}}, \textsf{GUAVA} constructs a list $L$ of length \mbox{\texttt{\mdseries\slshape n}}, such that no element of \mbox{\texttt{\mdseries\slshape L}} is a root of \mbox{\texttt{\mdseries\slshape g}}. 

 This is a special case of an alternant code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:=Indeterminate(GF(8),"x");|
  x
  !gapprompt@gap>| !gapinput@L:=Elements(GF(8));|
  [ 0*Z(2), Z(2)^0, Z(2^3), Z(2^3)^2, Z(2^3)^3, Z(2^3)^4, Z(2^3)^5, Z(2^3)^6 ]
  !gapprompt@gap>| !gapinput@g:=x^2+x+1;|
  x^2+x+Z(2)^0
  !gapprompt@gap>| !gapinput@C:=GoppaCode(g,L);|
  a linear [8,2,5]3 Goppa code over GF(2)
  !gapprompt@gap>| !gapinput@xx := Indeterminate( GF(2), "xx" );; |
  !gapprompt@gap>| !gapinput@gg := xx^2 + xx + 1;; L := AsSSortedList( GF(8) );;|
  !gapprompt@gap>| !gapinput@C1 := GoppaCode( gg, L );|
  a linear [8,2,5]3 Goppa code over GF(2) 
  !gapprompt@gap>| !gapinput@y := Indeterminate( GF(2), "y" );; |
  !gapprompt@gap>| !gapinput@h := y^2 + y + 1;;|
  !gapprompt@gap>| !gapinput@C2 := GoppaCode( h, 8 );|
  a linear [8,2,5]3 Goppa code over GF(2) 
  !gapprompt@gap>| !gapinput@C1=C2;|
  true
  !gapprompt@gap>| !gapinput@C=C1;|
  true
\end{Verbatim}
  \index{code, Srivastava} 

\subsection{\textcolor{Chapter }{GeneralizedSrivastavaCode}}
\logpage{[ 5, 2, 8 ]}\nobreak
\hyperdef{L}{X7F9C0A727EE075B7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralizedSrivastavaCode({\mdseries\slshape a, w, z[, t], F})\index{GeneralizedSrivastavaCode@\texttt{GeneralizedSrivastavaCode}}
\label{GeneralizedSrivastavaCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedSrivastavaCode} returns a generalized Srivastava code with parameters \mbox{\texttt{\mdseries\slshape a}}, \mbox{\texttt{\mdseries\slshape w}}, \mbox{\texttt{\mdseries\slshape z}}, \mbox{\texttt{\mdseries\slshape t}}. $a =\{ a_1, ..., a_n\}$ and $w =\{ w_1, ..., w_s\}$ are lists of $n+s$ distinct elements of $F=GF(q^m)$, $z$ is a list of length $n$ of nonzero elements of $GF(q^m)$. The parameter \mbox{\texttt{\mdseries\slshape t}} determines the designed distance: $d \geq st + 1$. The check matrix of this code is the form 
\[ H=([\frac{z_i}{(a_i - w_j)^k}]), \]
 $1\leq k\leq t$, where $[...]$ is as in \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat}). We use this definition of $H$ to define the code. The default for \mbox{\texttt{\mdseries\slshape t}} is 1. The original Srivastava codes (see \texttt{SrivastavaCode} (\ref{SrivastavaCode})) are a special case $t=1$, $z_i=a_i^\mu$, for some $\mu$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := Filtered( AsSSortedList( GF(2^6) ), e -> e in GF(2^3) );;|
  !gapprompt@gap>| !gapinput@w := [ Z(2^6) ];; z := List( [1..8], e -> 1 );;|
  !gapprompt@gap>| !gapinput@C := GeneralizedSrivastavaCode( a, w, z, 1, GF(64) );|
  a linear [8,2,2..5]3..4 generalized Srivastava code over GF(2) 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{SrivastavaCode}}
\logpage{[ 5, 2, 9 ]}\nobreak
\hyperdef{L}{X7A38EB3178961F3E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SrivastavaCode({\mdseries\slshape a, w[, mu], F})\index{SrivastavaCode@\texttt{SrivastavaCode}}
\label{SrivastavaCode}
}\hfill{\scriptsize (function)}}\\


 $SrivastavaCode$ returns a Srivastava code with parameters \mbox{\texttt{\mdseries\slshape a}}, \mbox{\texttt{\mdseries\slshape w}} (and optionally \mbox{\texttt{\mdseries\slshape mu}}). $a =\{ a_1, ..., a_n\}$ and $w =\{ w_1, ..., w_s\}$ are lists of $n+s$ distinct elements of $F=GF(q^m)$. The default for \mbox{\texttt{\mdseries\slshape mu}} is 1. The Srivastava code is a generalized Srivastava code, in which $z_i = a_i^{mu}$ for some \mbox{\texttt{\mdseries\slshape mu}} and $t=1$. 

 J. N. Srivastava introduced this code in 1967, though his work was not
published. See Helgert \cite{He72} for more details on the properties of this code. Related reference: G.
Roelofsen, \textsc{On Goppa and Generalized Srivastava Codes} PhD thesis, Dept. Math. and Comp. Sci., Eindhoven Univ. of Technology, the
Netherlands, 1982.  }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := AsSSortedList( GF(11) ){[2..8]};;|
  !gapprompt@gap>| !gapinput@w := AsSSortedList( GF(11) ){[9..10]};;|
  !gapprompt@gap>| !gapinput@C := SrivastavaCode( a, w, 2, GF(11) );|
  a linear [7,5,3]2 Srivastava code over GF(11)
  !gapprompt@gap>| !gapinput@IsMDSCode( C );|
  true    # Always true if F is a prime field 
\end{Verbatim}
  \index{code, Cordaro-Wagner} 

\subsection{\textcolor{Chapter }{CordaroWagnerCode}}
\logpage{[ 5, 2, 10 ]}\nobreak
\hyperdef{L}{X87F7CB8B7A8BE624}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CordaroWagnerCode({\mdseries\slshape n})\index{CordaroWagnerCode@\texttt{CordaroWagnerCode}}
\label{CordaroWagnerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CordaroWagnerCode} returns a binary Cordaro-Wagner code. This is a code of length \mbox{\texttt{\mdseries\slshape n}} and dimension $2$ having the best possible minimum distance $d$. This code is just a little bit less trivial than \texttt{RepetitionCode} (see \texttt{RepetitionCode} (\ref{RepetitionCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CordaroWagnerCode( 11 );|
  a linear [11,2,7]5 Cordaro-Wagner code over GF(2)
  !gapprompt@gap>| !gapinput@AsSSortedList(C);                 |
  [ [ 0 0 0 0 0 0 0 0 0 0 0 ], [ 0 0 0 0 1 1 1 1 1 1 1 ], 
    [ 1 1 1 1 0 0 0 1 1 1 1 ], [ 1 1 1 1 1 1 1 0 0 0 0 ] ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{FerreroDesignCode}}
\logpage{[ 5, 2, 11 ]}\nobreak
\hyperdef{L}{X865534267C8E902A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FerreroDesignCode({\mdseries\slshape P, m})\index{FerreroDesignCode@\texttt{FerreroDesignCode}}
\label{FerreroDesignCode}
}\hfill{\scriptsize (function)}}\\


 \emph{Requires the GAP package SONATA} 

 A group $K$ together with a group of automorphism $H$ of $K$ such that the semidirect product $KH$ is a Frobenius group with complement $H$ is called a Ferrero pair $(K, H)$ in SONATA. Take a Frobenius $(G,+)$ group with kernel $K$ and complement $H$. Consider the design $D$ with point set $K$ and block set $\{ a^H + b\ |\ a, b \in K, a \not= 0 \}$. Here $a^H$ denotes the orbit of a under conjugation by elements of $H$. Every planar near-ring design of type "*" can be obtained in this way from
groups. These designs (from a Frobenius kernel of order $v$ and a Frobenius complement of order $k$) have $v(v-1)/k$ distinct blocks and they are all of size $k$. Moreover each of the $v$ points occurs in exactly $v-1$ distinct blocks. Hence the rows and the columns of the incidence matrix $M$ of the design are always of constant weight. 

 \texttt{FerreroDesignCode} constructs binary linear code arising from the incdence matrix of a design
associated to a "Ferrero pair" arising from a fixed-point-free (fpf)
automorphism groups and Frobenius group. 

 INPUT: $P$ is a list of prime powers describing an abelian group $G$. $m > 0$ is an integer such that $G$ admits a cyclic fpf automorphism group of size $m$. This means that for all $q = p^k \in P$, OrderMod($p$, $m$) must divide $q$ (see the SONATA documentation for \texttt{FpfAutomorphismGroupsCyclic}). 

 OUTPUT: The binary linear code whose generator matrix is the incidence matrix
of a design associated to a "Ferrero pair" arising from the fixed-point-free
(fpf) automorphism group of $G$. The pair $(H,K)$ is called a Ferraro pair and the semidirect product $KH$ is a Frobenius group with complement $H$. 

 AUTHORS: Peter Mayr and David Joyner }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G:=AbelianGroup([5,5] );|
   [ pc group of size 25 with 2 generators ]
  !gapprompt@gap>| !gapinput@FpfAutomorphismGroupsMaxSize( G );|
  [ 24, 2 ]
  !gapprompt@gap>| !gapinput@L:=FpfAutomorphismGroupsCyclic( [5,5], 3 );|
  [ [ [ f1, f2 ] -> [ f1*f2^2, f1*f2^3 ] ],
    [ pc group of size 25 with 2 generators ] ]
  !gapprompt@gap>| !gapinput@D := DesignFromFerreroPair( L[2], Group(L[1][1]), "*" );|
   [ a 2 - ( 25, 3, 2 ) nearring generated design ]
  !gapprompt@gap>| !gapinput@M:=IncidenceMat( D );; Length(M); Length(TransposedMat(M));|
  25
  200
  !gapprompt@gap>| !gapinput@C1:=GeneratorMatCode(M*Z(2),GF(2));|
  a linear [200,25,1..24]62..100 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@MinimumDistance(C1);|
  24
  !gapprompt@gap>| !gapinput@C2:=FerreroDesignCode( [5,5],3);|
  a linear [200,25,1..24]62..100 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@C1=C2;|
  true
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RandomLinearCode}}
\logpage{[ 5, 2, 12 ]}\nobreak
\hyperdef{L}{X7BCA10CE8660357F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RandomLinearCode({\mdseries\slshape n, k, F})\index{RandomLinearCode@\texttt{RandomLinearCode}}
\label{RandomLinearCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RandomLinearCode} returns a random linear code with word length \mbox{\texttt{\mdseries\slshape n}}, dimension \mbox{\texttt{\mdseries\slshape k}} over field \mbox{\texttt{\mdseries\slshape F}}. The method used is to first construct a $k\times n$ matrix of the block form $(I,A)$, where $I$ is a $k\times k$ identity matrix and $A$ is a $k\times (n-k)$ matrix constructed using \texttt{Random(F)} repeatedly. Then the columns are permuted using a randomly selected element of \texttt{SymmetricGroup(n)}. 

 To create a random unrestricted code, use \texttt{RandomCode} (see \texttt{RandomCode} (\ref{RandomCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := RandomLinearCode( 15, 4, GF(3) );|
  a  [15,4,?] randomly generated code over GF(3)
  !gapprompt@gap>| !gapinput@Display(C);|
  a linear [15,4,1..6]6..10 random linear code over GF(3)
\end{Verbatim}
  The method \textsf{GUAVA} chooses to output the result of a \texttt{RandomLinearCode} command is different than other codes. For example, the bounds on the minimum
distance is not displayed. Howeer, you can use the \texttt{Display} command to print this information. This new display method was added in
version 1.9 to speed up the command (if $n$ is about 80 and $k$ about 40, for example, the time it took to look up and/or calculate the bounds
on the minimum distance was too long). 

\subsection{\textcolor{Chapter }{OptimalityCode}}
\logpage{[ 5, 2, 13 ]}\nobreak
\hyperdef{L}{X839CFE4C7A567D4D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OptimalityCode({\mdseries\slshape C})\index{OptimalityCode@\texttt{OptimalityCode}}
\label{OptimalityCode}
}\hfill{\scriptsize (function)}}\\


  \texttt{OptimalityCode} returns the difference between the smallest known upper bound and the actual
size of the code. Note that the value of the function \texttt{UpperBound} is not always equal to the actual upper bound $A(n,d)$ thus the result may not be equal to $0$ even if the code is optimal! 

 \texttt{OptimalityLinearCode} is similar but applies only to linear codes. }

 

\subsection{\textcolor{Chapter }{BestKnownLinearCode}}
\logpage{[ 5, 2, 14 ]}\nobreak
\hyperdef{L}{X871508567CB34D96}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BestKnownLinearCode({\mdseries\slshape n, k, F})\index{BestKnownLinearCode@\texttt{BestKnownLinearCode}}
\label{BestKnownLinearCode}
}\hfill{\scriptsize (function)}}\\


  \texttt{BestKnownLinearCode} returns the best known (as of 11 May 2006) linear code of length \mbox{\texttt{\mdseries\slshape n}}, dimension \mbox{\texttt{\mdseries\slshape k}} over field \mbox{\texttt{\mdseries\slshape F}}. The function uses the tables described in section \texttt{BoundsMinimumDistance} (\ref{BoundsMinimumDistance}) to construct this code. 

 This command can also be called using the syntax \texttt{BestKnownLinearCode( rec )}, where \mbox{\texttt{\mdseries\slshape rec}} must be a record containing the fields `lowerBound', `upperBound' and
`construction'. It uses the information in this field to construct a code.
This form is meant to be used together with the function \texttt{BoundsMinimumDistance} (see \texttt{BoundsMinimumDistance} (\ref{BoundsMinimumDistance})), if the bounds are already calculated. }

 
\begin{Verbatim}[commandchars=!|J,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>J !gapinput|C1 := BestKnownLinearCode( 23, 12, GF(2) );J
  a linear [23,12,7]3 punctured code
  !gapprompt|gap>J !gapinput|C1 = BinaryGolayCode();J
  false     # it's constructed differently
  !gapprompt|gap>J !gapinput|C1 := BestKnownLinearCode( 23, 12, GF(2) );J
  a linear [23,12,7]3 punctured code
  !gapprompt|gap>J !gapinput|G1 := MutableCopyMat(GeneratorMat(C1));;J
  !gapprompt|gap>J !gapinput|PutStandardForm(G1);J
  ()
  !gapprompt|gap>J !gapinput|Display(G1);J
   1 . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1
   . 1 . . . . . . . . . . 1 1 1 1 1 . . 1 . . .
   . . 1 . . . . . . . . . 1 1 . 1 . . 1 . 1 . 1
   . . . 1 . . . . . . . . 1 1 . . . 1 1 1 . 1 .
   . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 . 1
   . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 1
   . . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1
   . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 . .
   . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 .
   . . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 .
   . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1 1
   . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1
  !gapprompt|gap>J !gapinput|C2 := BinaryGolayCode();J
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  !gapprompt|gap>J !gapinput|G2 := MutableCopyMat(GeneratorMat(C2));;J
  !gapprompt|gap>J !gapinput|PutStandardForm(G2);J
  ()
  !gapprompt|gap>J !gapinput|Display(G2);J
   1 . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1
   . 1 . . . . . . . . . . 1 1 1 1 1 . . 1 . . 1
   . . 1 . . . . . . . . . 1 1 . 1 . . 1 . 1 . 1
   . . . 1 . . . . . . . . 1 1 . . . 1 1 1 . 1 1
   . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 . .
   . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 .
   . . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1
   . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 . .
   . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 .
   . . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1
   . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1 .
   . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1
  ## Despite their generator matrices are different, they are equivalent codes, see below.
  !gapprompt|gap>J !gapinput|IsEquivalent(C1,C2);J
  true
  !gapprompt|gap>J !gapinput|CodeIsomorphism(C1,C2);J
  (4,14,6,12,5)(7,17,18,11,19)(8,22,13,21,16)(10,23,15,20)
  !gapprompt|gap>J !gapinput|Display( BestKnownLinearCode( 81, 77, GF(4) ) );J
  a linear [81,77,3]2..3 shortened code of
  a linear [85,81,3]1 Hamming (4,4) code over GF(4)
  !gapprompt|gap>J !gapinput|C:=BestKnownLinearCode(174,72);J
  a linear [174,72,31..36]26..87 code defined by generator matrix over GF(2)
  !gapprompt|gap>J !gapinput|bounds := BoundsMinimumDistance( 81, 77, GF(4) );J
  rec( n := 81, k := 77, q := 4, 
    references := rec( Ham := [ "%T this reference is unknown, for more info", 
            "%T contact A.E. Brouwer (aeb@cwi.nl)" ], 
        cap := [ "%T this reference is unknown, for more info", 
            "%T contact A.E. Brouwer (aeb@cwi.nl)" ] ), 
    construction := [ (Operation "ShortenedCode"), 
        [ [ (Operation "HammingCode"), [ 4, 4 ] ], [ 1, 2, 3, 4 ] ] ], 
    lowerBound := 3, 
    lowerBoundExplanation := [ "Lb(81,77)=3, by shortening of:", 
        "Lb(85,81)=3, reference: Ham" ], upperBound := 3, 
    upperBoundExplanation := [ "Ub(81,77)=3, by considering shortening to:", 
        "Ub(18,14)=3, reference: cap" ] )
  !gapprompt|gap>J !gapinput|C := BestKnownLinearCode( bounds );J
  a linear [81,77,3]2..3 shortened code
  !gapprompt|gap>J !gapinput|C = BestKnownLinearCode(81, 77, GF(4) );J
  true
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Gabidulin Codes }}\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X858721967BE44000}{}
{
  \label{Gabidulin Codes}  These five binary, linear codes are derived from an article by Gabidulin,
Davydov and Tombak \cite{GDT91}. All these codes are defined by check matrices. Exact definitions can be
found in the article. The Gabidulin code, the enlarged Gabidulin code, the
Davydov code, the Tombak code, and the enlarged Tombak code, correspond with
theorem 1, 2, 3, 4, and 5, respectively in the article. 

 Like the Hamming codes, these codes have fixed minimum distance and covering
radius, but can be arbitrarily long. \index{code, Gabidulin} 

\subsection{\textcolor{Chapter }{GabidulinCode}}
\logpage{[ 5, 3, 1 ]}\nobreak
\hyperdef{L}{X79BE5D497CB2E59E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GabidulinCode({\mdseries\slshape m, w1, w2})\index{GabidulinCode@\texttt{GabidulinCode}}
\label{GabidulinCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GabidulinCode} yields a code of length $5$ . $2^{m-2}-1$, redundancy $2m-1$, minimum distance $3$ and covering radius $2$. \mbox{\texttt{\mdseries\slshape w1}} and \mbox{\texttt{\mdseries\slshape w2}} should be elements of $GF(2^{m-2})$. }

 

\subsection{\textcolor{Chapter }{EnlargedGabidulinCode}}
\logpage{[ 5, 3, 2 ]}\nobreak
\hyperdef{L}{X873950F67D4A9184}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EnlargedGabidulinCode({\mdseries\slshape m, w1, w2, e})\index{EnlargedGabidulinCode@\texttt{EnlargedGabidulinCode}}
\label{EnlargedGabidulinCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{EnlargedGabidulinCode} yields a code of length $7$. $2^{m-2}-2$, redundancy $2m$, minimum distance $3$ and covering radius $2$. \mbox{\texttt{\mdseries\slshape w1}} and \mbox{\texttt{\mdseries\slshape w2}} are elements of $GF(2^{m-2})$. \mbox{\texttt{\mdseries\slshape e}} is an element of $GF(2^m)$.  }

 \index{code, Davydov} 

\subsection{\textcolor{Chapter }{DavydovCode}}
\logpage{[ 5, 3, 3 ]}\nobreak
\hyperdef{L}{X7F5BE77B7F343182}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DavydovCode({\mdseries\slshape r, v, ei, ej})\index{DavydovCode@\texttt{DavydovCode}}
\label{DavydovCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DavydovCode} yields a code of length $2^v + 2^{r-v} - 3$, redundancy \mbox{\texttt{\mdseries\slshape r}}, minimum distance $4$ and covering radius $2$. \mbox{\texttt{\mdseries\slshape v}} is an integer between $2$ and $r-2$. \mbox{\texttt{\mdseries\slshape ei}} and \mbox{\texttt{\mdseries\slshape ej}} are elements of $GF(2^v)$ and $GF(2^{r-v})$, respectively. }

 \index{code, Tombak} 

\subsection{\textcolor{Chapter }{TombakCode}}
\logpage{[ 5, 3, 4 ]}\nobreak
\hyperdef{L}{X845B4DBE83288D2D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TombakCode({\mdseries\slshape m, e, beta, gamma, w1, w2})\index{TombakCode@\texttt{TombakCode}}
\label{TombakCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{TombakCode} yields a code of length $15 \cdot 2^{m-3} - 3$, redundancy $2m$, minimum distance $4$ and covering radius $2$. \mbox{\texttt{\mdseries\slshape e}} is an element of $GF(2^m)$. \mbox{\texttt{\mdseries\slshape beta}} and \mbox{\texttt{\mdseries\slshape gamma}} are elements of $GF(2^{m-1})$. \mbox{\texttt{\mdseries\slshape w1}} and \mbox{\texttt{\mdseries\slshape w2}} are elements of $GF(2^{m-3})$. }

 

\subsection{\textcolor{Chapter }{EnlargedTombakCode}}
\logpage{[ 5, 3, 5 ]}\nobreak
\hyperdef{L}{X7D6583347C0D4292}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EnlargedTombakCode({\mdseries\slshape m, e, beta, gamma, w1, w2, u})\index{EnlargedTombakCode@\texttt{EnlargedTombakCode}}
\label{EnlargedTombakCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{EnlargedTombakCode} yields a code of length $23 \cdot 2^{m-4} - 3$, redundancy $2m-1$, minimum distance $4$ and covering radius $2$. The parameters \mbox{\texttt{\mdseries\slshape m}}, \mbox{\texttt{\mdseries\slshape e}}, \mbox{\texttt{\mdseries\slshape beta}}, \mbox{\texttt{\mdseries\slshape gamma}}, \mbox{\texttt{\mdseries\slshape w1}} and \mbox{\texttt{\mdseries\slshape w2}} are defined as in \texttt{TombakCode}. \mbox{\texttt{\mdseries\slshape u}} is an element of $GF(2^{m-1})$.  }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GabidulinCode( 4, Z(4)^0, Z(4)^1 );|
  a linear [19,12,3]2 Gabidulin code (m=4) over GF(2)
  !gapprompt@gap>| !gapinput@EnlargedGabidulinCode( 4, Z(4)^0, Z(4)^1, Z(16)^11 );|
  a linear [26,18,3]2 enlarged Gabidulin code (m=4) over GF(2)
  !gapprompt@gap>| !gapinput@DavydovCode( 6, 3, Z(8)^1, Z(8)^5 );|
  a linear [13,7,4]2 Davydov code (r=6, v=3) over GF(2)
  !gapprompt@gap>| !gapinput@TombakCode( 5, Z(32)^6, Z(16)^14, Z(16)^10, Z(4)^0, Z(4)^1 );|
  a linear [57,47,4]2 Tombak code (m=5) over GF(2)
  !gapprompt@gap>| !gapinput@EnlargedTombakCode( 6, Z(32)^6, Z(16)^14, Z(16)^10,|
  !gapprompt@>| !gapinput@Z(4)^0, Z(4)^0, Z(32)^23 );|
  a linear [89,78,4]2 enlarged Tombak code (m=6) over GF(2)
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Golay Codes }}\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X81F6E4A785F368B0}{}
{
  \label{Golay Codes} `` The Golay code is probably the most important of all codes for both practical
and theoretical reasons. '' (\cite{MS83}, pg. 64). Though born in Switzerland, M. J. E. Golay (1902-1989) worked for
the US Army Labs for most of his career. For more information on his life, see
his obit in the June 1990 IEEE Information Society Newsletter. \index{code, Golay (binary)} 

\subsection{\textcolor{Chapter }{BinaryGolayCode}}
\logpage{[ 5, 4, 1 ]}\nobreak
\hyperdef{L}{X80ED89C079CD0D09}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BinaryGolayCode({\mdseries\slshape })\index{BinaryGolayCode@\texttt{BinaryGolayCode}}
\label{BinaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{BinaryGolayCode} returns a binary Golay code. This is a perfect $[23,12,7]$ code. It is also cyclic, and has generator polynomial $g(x)=1+x^2+x^4+x^5+x^6+x^{10}+x^{11}$. Extending it results in an extended Golay code (see \texttt{ExtendedBinaryGolayCode} (\ref{ExtendedBinaryGolayCode})). There's also the ternary Golay code (see \texttt{TernaryGolayCode} (\ref{TernaryGolayCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=BinaryGolayCode();|
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  !gapprompt@gap>| !gapinput@ExtendedBinaryGolayCode() = ExtendedCode(BinaryGolayCode());|
  true
  !gapprompt@gap>| !gapinput@IsPerfectCode(C);|
  true 
  !gapprompt@gap>| !gapinput@IsCyclicCode(C);|
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExtendedBinaryGolayCode}}
\logpage{[ 5, 4, 2 ]}\nobreak
\hyperdef{L}{X84520C7983538806}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtendedBinaryGolayCode({\mdseries\slshape })\index{ExtendedBinaryGolayCode@\texttt{ExtendedBinaryGolayCode}}
\label{ExtendedBinaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExtendedBinaryGolayCode} returns an extended binary Golay code. This is a $[24,12,8]$ code. Puncturing in the last position results in a perfect binary Golay code
(see \texttt{BinaryGolayCode} (\ref{BinaryGolayCode})). The code is self-dual. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ExtendedBinaryGolayCode();|
  a linear [24,12,8]4 extended binary Golay code over GF(2)
  !gapprompt@gap>| !gapinput@IsSelfDualCode(C);|
  true
  !gapprompt@gap>| !gapinput@P := PuncturedCode(C);|
  a linear [23,12,7]3 punctured code
  !gapprompt@gap>| !gapinput@P = BinaryGolayCode();|
  true 
  !gapprompt@gap>| !gapinput@IsCyclicCode(C);|
  false
  
\end{Verbatim}
  \index{code, Golay (ternary)} 

\subsection{\textcolor{Chapter }{TernaryGolayCode}}
\logpage{[ 5, 4, 3 ]}\nobreak
\hyperdef{L}{X7E0CCCD7866ADB94}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TernaryGolayCode({\mdseries\slshape })\index{TernaryGolayCode@\texttt{TernaryGolayCode}}
\label{TernaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{TernaryGolayCode} returns a ternary Golay code. This is a perfect $[11,6,5]$ code. It is also cyclic, and has generator polynomial $g(x)=2+x^2+2x^3+x^4+x^5$. Extending it results in an extended Golay code (see \texttt{ExtendedTernaryGolayCode} (\ref{ExtendedTernaryGolayCode})). There's also the binary Golay code (see \texttt{BinaryGolayCode} (\ref{BinaryGolayCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=TernaryGolayCode();|
  a cyclic [11,6,5]2 ternary Golay code over GF(3)
  !gapprompt@gap>| !gapinput@ExtendedTernaryGolayCode() = ExtendedCode(TernaryGolayCode());|
  true 
  !gapprompt@gap>| !gapinput@IsCyclicCode(C);|
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExtendedTernaryGolayCode}}
\logpage{[ 5, 4, 4 ]}\nobreak
\hyperdef{L}{X81088A66816BCAE4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtendedTernaryGolayCode({\mdseries\slshape })\index{ExtendedTernaryGolayCode@\texttt{ExtendedTernaryGolayCode}}
\label{ExtendedTernaryGolayCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExtendedTernaryGolayCode} returns an extended ternary Golay code. This is a $[12,6,6]$ code. Puncturing this code results in a perfect ternary Golay code (see \texttt{TernaryGolayCode} (\ref{TernaryGolayCode})). The code is self-dual. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ExtendedTernaryGolayCode();|
  a linear [12,6,6]3 extended ternary Golay code over GF(3)
  !gapprompt@gap>| !gapinput@IsSelfDualCode(C);|
  true
  !gapprompt@gap>| !gapinput@P := PuncturedCode(C);|
  a linear [11,6,5]2 punctured code
  !gapprompt@gap>| !gapinput@P = TernaryGolayCode();|
  true 
  !gapprompt@gap>| !gapinput@IsCyclicCode(C);|
  false
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Generating Cyclic Codes }}\logpage{[ 5, 5, 0 ]}
\hyperdef{L}{X8366CC3685F0BC85}{}
{
  \label{Generating Cyclic Codes} The elements of a cyclic code $C$ are all multiples of a ('generator') polynomial $g(x)$, where calculations are carried out modulo $x^n-1$. Therefore, as polynomials in $x$, the elements always have degree less than $n$. A cyclic code is an ideal in the ring $F[x]/(x^n-1)$ of polynomials modulo $x^n - 1$. The unique monic polynomial of least degree that generates $C$ is called the \emph{generator polynomial} of $C$. It is a divisor of the polynomial $x^n-1$. \index{generator polynomial} \index{check polynomial} 

 The \emph{check polynomial} is the polynomial $h(x)$ with $g(x)h(x)=x^n-1$. Therefore it is also a divisor of $x^n-1$. The check polynomial has the property that 
\[ c(x)h(x) \equiv 0 \pmod{x^n-1}, \]
 for every codeword $c(x)\in C$. 

 The first two functions described below generate cyclic codes from a given
generator or check polynomial. All cyclic codes can be constructed using these
functions. 

 Two of the Golay codes already described are cyclic (see \texttt{BinaryGolayCode} (\ref{BinaryGolayCode}) and \texttt{TernaryGolayCode} (\ref{TernaryGolayCode})). For example, the \textsf{GUAVA} record for a binary Golay code contains the generator polynomial: 
\begin{Verbatim}[commandchars=@|E,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>E @gapinput|C := BinaryGolayCode();E
  a cyclic [23,12,7]3 binary Golay code over GF(2)
  @gapprompt|gap>E @gapinput|NamesOfComponents(C);E
  [ "LeftActingDomain", "GeneratorsOfLeftOperatorAdditiveGroup", "WordLength",
    "GeneratorMat", "GeneratorPol", "Dimension", "Redundancy", "Size", "name",
    "lowerBoundMinimumDistance", "upperBoundMinimumDistance", "WeightDistribution",
    "boundsCoveringRadius", "MinimumWeightOfGenerators", 
    "UpperBoundOptimalMinimumDistance" ]
  @gapprompt|gap>E @gapinput|C!.GeneratorPol;E
  x_1^11+x_1^10+x_1^6+x_1^5+x_1^4+x_1^2+Z(2)^0
\end{Verbatim}
  Then functions that generate cyclic codes from a prescribed set of roots of
the generator polynomial are described, including the BCH codes (see \texttt{RootsCode} (\ref{RootsCode}), \texttt{BCHCode} (\ref{BCHCode}), \texttt{ReedSolomonCode} (\ref{ReedSolomonCode}) and \texttt{QRCode} (\ref{QRCode})). 

 Finally we describe the trivial codes (see \texttt{WholeSpaceCode} (\ref{WholeSpaceCode}), \texttt{NullCode} (\ref{NullCode}), \texttt{RepetitionCode} (\ref{RepetitionCode})), and the command \texttt{CyclicCodes} which lists all cyclic codes (\texttt{CyclicCodes} (\ref{CyclicCodes})). 

\subsection{\textcolor{Chapter }{GeneratorPolCode}}
\logpage{[ 5, 5, 1 ]}\nobreak
\hyperdef{L}{X853D34A5796CEB73}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneratorPolCode({\mdseries\slshape g, n[, name], F})\index{GeneratorPolCode@\texttt{GeneratorPolCode}}
\label{GeneratorPolCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneratorPolCode} creates a cyclic code with a generator polynomial \mbox{\texttt{\mdseries\slshape g}}, word length \mbox{\texttt{\mdseries\slshape n}}, over \mbox{\texttt{\mdseries\slshape F}}. \mbox{\texttt{\mdseries\slshape name}} can contain a short description of the code. 

 If \mbox{\texttt{\mdseries\slshape g}} is not a divisor of $x^n-1$, it cannot be a generator polynomial. In that case, a code is created with
generator polynomial $gcd( g, x^n-1 )$, i.e. the greatest common divisor of \mbox{\texttt{\mdseries\slshape g}} and $x^n-1$. This is a valid generator polynomial that generates the ideal $(g)$. See \texttt{Generating Cyclic Codes} (\ref{Generating Cyclic Codes}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:= Indeterminate( GF(2) );; P:= x^2+1;|
  Z(2)^0+x^2
  !gapprompt@gap>| !gapinput@C1 := GeneratorPolCode(P, 7, GF(2));|
  a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
  !gapprompt@gap>| !gapinput@GeneratorPol( C1 );|
  Z(2)^0+x
  !gapprompt@gap>| !gapinput@C2 := GeneratorPolCode( x+1, 7, GF(2)); |
  a cyclic [7,6,1..2]1 code defined by generator polynomial over GF(2)
  !gapprompt@gap>| !gapinput@GeneratorPol( C2 );|
  Z(2)^0+x
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CheckPolCode}}
\logpage{[ 5, 5, 2 ]}\nobreak
\hyperdef{L}{X82440B78845F7F6E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CheckPolCode({\mdseries\slshape h, n[, name], F})\index{CheckPolCode@\texttt{CheckPolCode}}
\label{CheckPolCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CheckPolCode} creates a cyclic code with a check polynomial \mbox{\texttt{\mdseries\slshape h}}, word length \mbox{\texttt{\mdseries\slshape n}}, over \mbox{\texttt{\mdseries\slshape F}}. \mbox{\texttt{\mdseries\slshape name}} can contain a short description of the code (as a string). 

 If \mbox{\texttt{\mdseries\slshape h}} is not a divisor of $x^n-1$, it cannot be a check polynomial. In that case, a code is created with check
polynomial $gcd( h, x^n-1 )$, i.e. the greatest common divisor of \mbox{\texttt{\mdseries\slshape h}} and $x^n-1$. This is a valid check polynomial that yields the same elements as the ideal $(h)$. See \ref{Generating Cyclic Codes}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ x:= Indeterminate( GF(3) );; P:= x^2+2;|
  -Z(3)^0+x_1^2
  !gapprompt@gap>| !gapinput@H := CheckPolCode(P, 7, GF(3));|
  a cyclic [7,1,7]4 code defined by check polynomial over GF(3)
  !gapprompt@gap>| !gapinput@CheckPol(H);|
  -Z(3)^0+x_1
  !gapprompt@gap>| !gapinput@Gcd(P, X(GF(3))^7-1);|
  -Z(3)^0+x_1
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RootsCode}}
\logpage{[ 5, 5, 3 ]}\nobreak
\hyperdef{L}{X818F0E6583E01D4B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RootsCode({\mdseries\slshape n, list})\index{RootsCode@\texttt{RootsCode}}
\label{RootsCode}
}\hfill{\scriptsize (function)}}\\


 This is the generalization of the BCH, Reed-Solomon and quadratic residue
codes (see \texttt{BCHCode} (\ref{BCHCode}), \texttt{ReedSolomonCode} (\ref{ReedSolomonCode}) and \texttt{QRCode} (\ref{QRCode})). The user can give a length of the code \mbox{\texttt{\mdseries\slshape n}} and a prescribed set of zeros. The argument \mbox{\texttt{\mdseries\slshape list}} must be a valid list of $n^{th}$ roots of unity in a splitting field $GF(q^m)$. The resulting code will be over the field $GF(q)$. The function will return the largest possible cyclic code for which the list \mbox{\texttt{\mdseries\slshape list}} is a subset of the roots of the code. From this list, \textsf{GUAVA} calculates the entire set of roots. 

 This command can also be called with the syntax \texttt{RootsCode( n, list, q )}. In this second form, the second argument is a list of integers, ranging from $0$ to $n-1$. The resulting code will be over a field $GF(q)$. \textsf{GUAVA} calculates a primitive $n^{th}$ root of unity, $\alpha$, in the extension field of $GF(q)$. It uses the set of the powers of $\alpha$ in the list as a prescribed set of zeros. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := PrimitiveUnityRoot( 3, 14 );|
  Z(3^6)^52
  !gapprompt@gap>| !gapinput@C1 := RootsCode( 14, [ a^0, a, a^3 ] );|
  a cyclic [14,7,3..6]3..7 code defined by roots over GF(3)
  !gapprompt@gap>| !gapinput@MinimumDistance( C1 );|
  4
  !gapprompt@gap>| !gapinput@b := PrimitiveUnityRoot( 2, 15 );|
  Z(2^4)
  !gapprompt@gap>| !gapinput@C2 := RootsCode( 15, [ b, b^2, b^3, b^4 ] );|
  a cyclic [15,7,5]3..5 code defined by roots over GF(2)
  !gapprompt@gap>| !gapinput@C2 = BCHCode( 15, 5, GF(2) );|
  true 
  !gapprompt@gap>| !gapinput@C3 := RootsCode( 4, [ 1, 2 ], 5 );|
  a cyclic [4,2,2..3]2 code defined by roots over GF(5)
  !gapprompt@gap>| !gapinput@RootsOfCode( C3 );|
  [ Z(5), Z(5)^2 ]
  !gapprompt@gap>| !gapinput@C3 = ReedSolomonCode( 4, 3 );|
  true
\end{Verbatim}
  \index{code, Bose-Chaudhuri-Hockenghem} 

\subsection{\textcolor{Chapter }{BCHCode}}
\logpage{[ 5, 5, 4 ]}\nobreak
\hyperdef{L}{X7C6BB07C87853C00}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BCHCode({\mdseries\slshape n[, b], delta, F})\index{BCHCode@\texttt{BCHCode}}
\label{BCHCode}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{BCHCode} returns a 'Bose-Chaudhuri-Hockenghem code' (or \emph{BCH code} for short). This is the largest possible cyclic code of length \mbox{\texttt{\mdseries\slshape n}} over field \mbox{\texttt{\mdseries\slshape F}}, whose generator polynomial has zeros 
\[ a^{b},a^{b+1}, ..., a^{b+delta-2}, \]
 where $a$ is a primitive $n^{th}$ root of unity in the splitting field $GF(q^m)$, \mbox{\texttt{\mdseries\slshape b}} is an integer $0\leq b\leq n-delta+1$ and $m$ is the multiplicative order of $q$ modulo \mbox{\texttt{\mdseries\slshape n}}. (The integers $\{b,...,b+delta-2\}$ typically lie in the range $\{1,...,n-1\}$.) Default value for \mbox{\texttt{\mdseries\slshape b}} is $1$, though the algorithm allows $b=0$. The length \mbox{\texttt{\mdseries\slshape n}} of the code and the size $q$ of the field must be relatively prime. The generator polynomial is equal to
the least common multiple of the minimal polynomials of 
\[ a^{b}, a^{b+1}, ..., a^{b+delta-2}. \]
 The set of zeroes of the generator polynomial is equal to the union of the
sets 
\[ \{a^x\ |\ x \in C_k\}, \]
 where $C_k$ is the $k^{th}$ cyclotomic coset of $q$ modulo $n$ and $b\leq k\leq b+delta-2$ (see \texttt{CyclotomicCosets} (\ref{CyclotomicCosets})). 

 Special cases are $b=1$ (resulting codes are called 'narrow-sense' BCH codes), and $n=q^m-1$ (known as 'primitive' BCH codes). \textsf{GUAVA} calculates the largest value of $d$ for which the BCH code with designed distance $d$ coincides with the BCH code with designed distance \mbox{\texttt{\mdseries\slshape delta}}. This distance $d$ is called the \emph{Bose distance} of the code. The true minimum distance of the code is greater than or equal to
the Bose distance. \index{Bose distance} 

 Printed are the designed distance (to be precise, the Bose distance) $d$, and the starting power $b$. 

 The Sugiyama decoding algorithm has been implemented for this code (see \texttt{Decode} (\ref{Decode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := BCHCode( 15, 3, 5, GF(2) );|
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@DesignedDistance( C1 );|
  7
  !gapprompt@gap>| !gapinput@C2 := BCHCode( 23, 2, GF(2) );|
  a cyclic [23,12,5..7]3 BCH code, delta=5, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@DesignedDistance( C2 );       |
  5
  !gapprompt@gap>| !gapinput@MinimumDistance(C2);|
  7 
\end{Verbatim}
  See \texttt{RootsCode} (\ref{RootsCode}) for a more general construction. \index{code, Reed-Solomon} 

\subsection{\textcolor{Chapter }{ReedSolomonCode}}
\logpage{[ 5, 5, 5 ]}\nobreak
\hyperdef{L}{X838F3CB3872CEF95}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ReedSolomonCode({\mdseries\slshape n, d})\index{ReedSolomonCode@\texttt{ReedSolomonCode}}
\label{ReedSolomonCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ReedSolomonCode} returns a 'Reed-Solomon code' of length \mbox{\texttt{\mdseries\slshape n}}, designed distance \mbox{\texttt{\mdseries\slshape d}}. This code is a primitive narrow-sense BCH code over the field $GF(q)$, where $q=n+1$. The dimension of an RS code is $n-d+1$. According to the Singleton bound (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton})) the dimension cannot be greater than this, so the true minimum distance of
an RS code is equal to \mbox{\texttt{\mdseries\slshape d}} and the code is maximum distance separable (see \texttt{IsMDSCode} (\ref{IsMDSCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := ReedSolomonCode( 3, 2 );|
  a cyclic [3,2,2]1 Reed-Solomon code over GF(4)
  !gapprompt@gap>| !gapinput@IsCyclicCode(C1);|
  true
  !gapprompt@gap>| !gapinput@C2 := ReedSolomonCode( 4, 3 );|
  a cyclic [4,2,3]2 Reed-Solomon code over GF(5)
  !gapprompt@gap>| !gapinput@RootsOfCode( C2 );|
  [ Z(5), Z(5)^2 ]
  !gapprompt@gap>| !gapinput@IsMDSCode(C2);|
  true 
\end{Verbatim}
  See \texttt{GeneralizedReedSolomonCode} (\ref{GeneralizedReedSolomonCode}) for a more general construction. 

\subsection{\textcolor{Chapter }{ExtendedReedSolomonCode}}
\logpage{[ 5, 5, 6 ]}\nobreak
\hyperdef{L}{X8730B90A862A3B3E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtendedReedSolomonCode({\mdseries\slshape n, d})\index{ExtendedReedSolomonCode@\texttt{ExtendedReedSolomonCode}}
\label{ExtendedReedSolomonCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExtendedReedSolomonCode} creates a Reed-Solomon code of length $n-1$ with designed distance $d-1$ and then returns the code which is extended by adding an overall parity-check
symbol. The motivation for creating this function is calling \texttt{ExtendedCode} (\ref{ExtendedCode}) function over a Reed-Solomon code will take considerably long time. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := ExtendedReedSolomonCode(17, 13);|
  a linear [17,5,13]9..12 extended Reed Solomon code over GF(17)
  !gapprompt@gap>| !gapinput@IsMDSCode(C);|
  true
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{QRCode}}
\logpage{[ 5, 5, 7 ]}\nobreak
\hyperdef{L}{X825F42F68179D2AB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{QRCode({\mdseries\slshape n, F})\index{QRCode@\texttt{QRCode}}
\label{QRCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{QRCode} returns a quadratic residue code. If \mbox{\texttt{\mdseries\slshape F}} is a field $GF(q)$, then $q$ must be a quadratic residue modulo \mbox{\texttt{\mdseries\slshape n}}. That is, an $x$ exists with $x^2 \equiv q \pmod n$. Both \mbox{\texttt{\mdseries\slshape n}} and $q$ must be primes. Its generator polynomial is the product of the polynomials $x-a^i$. $a$ is a primitive $n^{th}$ root of unity, and $i$ is an integer in the set of quadratic residues modulo \mbox{\texttt{\mdseries\slshape n}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := QRCode( 7, GF(2) );|
  a cyclic [7,4,3]1 quadratic residue code over GF(2)
  !gapprompt@gap>| !gapinput@IsEquivalent( C1, HammingCode( 3, GF(2) ) );|
  true
  !gapprompt@gap>| !gapinput@IsCyclicCode(C1);|
  true
  !gapprompt@gap>| !gapinput@IsCyclicCode(HammingCode( 3, GF(2) ));|
  false
  !gapprompt@gap>| !gapinput@C2 := QRCode( 11, GF(3) );|
  a cyclic [11,6,4..5]2 quadratic residue code over GF(3)
  !gapprompt@gap>| !gapinput@C2 = TernaryGolayCode();|
  true 
  !gapprompt@gap>| !gapinput@Q1 := QRCode( 7, GF(2));|
  a cyclic [7,4,3]1 quadratic residue code over GF(2)
  !gapprompt@gap>| !gapinput@P1:=AutomorphismGroup(Q1); IdGroup(P1);|
  Group([ (1,2)(5,7), (2,3)(4,7), (2,4)(5,6), (3,5)(6,7), (3,7)(5,6) ])
  [ 168, 42 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{QQRCodeNC}}
\logpage{[ 5, 5, 8 ]}\nobreak
\hyperdef{L}{X8764ABCF854C695E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{QQRCodeNC({\mdseries\slshape p})\index{QQRCodeNC@\texttt{QQRCodeNC}}
\label{QQRCodeNC}
}\hfill{\scriptsize (function)}}\\


 \texttt{QQRCodeNC} is the same as \texttt{QQRCode}, except that it uses \texttt{GeneratorMatCodeNC} instead of \texttt{GeneratorMatCode}. }

 

\subsection{\textcolor{Chapter }{QQRCode}}
\logpage{[ 5, 5, 9 ]}\nobreak
\hyperdef{L}{X7F4C3AD2795A8D7A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{QQRCode({\mdseries\slshape p})\index{QQRCode@\texttt{QQRCode}}
\label{QQRCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{QQRCode} returns a quasi-quadratic residue code, as defined by Proposition 2.2 in
Bazzi-Mittel \cite{BM03}. The parameter \mbox{\texttt{\mdseries\slshape p}} must be a prime. Its generator matrix has the block form $G=(Q,N)$. Here $Q$ is a $p\times $ circulant matrix whose top row is $(0,x_1,...,x_{p-1})$, where $x_i=1$ if and only if $i$ is a quadratic residue mod $p$, and $N$ is a $p\times $ circulant matrix whose top row is $(0,y_1,...,y_{p-1})$, where $x_i+y_i=1$ for all $i$. (In fact, this matrix can be recovered as the component \texttt{DoublyCirculant} of the code.) }

 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>B @gapinput|C1 := QQRCode( 7);B
  a linear [14,7,1..4]3..5 code defined by generator matrix over GF(2)
  @gapprompt|gap>B @gapinput|G1:=GeneratorMat(C1);;B
  @gapprompt|gap>B @gapinput|Display(G1);B
   . 1 1 . 1 . . . . . 1 . 1 1
   1 . 1 1 1 . . . . 1 1 1 . 1
   . . . 1 1 . 1 . 1 1 . . . 1
   . . 1 . 1 1 1 1 . 1 . . 1 1
   . . . . . . . 1 . . 1 1 1 .
   . . . . . . . . . 1 1 1 . 1
   . . . . . . . . 1 . . 1 1 1
  @gapprompt|gap>B @gapinput|Display(C1!.DoublyCirculant);B
   . 1 1 . 1 . . . . . 1 . 1 1
   1 1 . 1 . . . . . 1 . 1 1 .
   1 . 1 . . . 1 . 1 . 1 1 . .
   . 1 . . . 1 1 1 . 1 1 . . .
   1 . . . 1 1 . . 1 1 . . . 1
   . . . 1 1 . 1 1 1 . . . 1 .
   . . 1 1 . 1 . 1 . . . 1 . 1
  @gapprompt|gap>B @gapinput|MinimumDistance(C1);B
  4
  @gapprompt|gap>B @gapinput|C2 := QQRCode( 29); MinimumDistance(C2);B
  a linear [58,28,1..14]8..29 code defined by generator matrix over GF(2)
  12
  @gapprompt|gap>B @gapinput|Aut2:=AutomorphismGroup(C2); IdGroup(Aut2);B
  [ permutation group of size 812 with 4 generators ]
  [ 812, 7 ]
\end{Verbatim}
  \index{code, Fire} 

\subsection{\textcolor{Chapter }{FireCode}}
\logpage{[ 5, 5, 10 ]}\nobreak
\hyperdef{L}{X7F3B8CC8831DA0E4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FireCode({\mdseries\slshape g, b})\index{FireCode@\texttt{FireCode}}
\label{FireCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{FireCode} constructs a (binary) Fire code. \mbox{\texttt{\mdseries\slshape g}} is a primitive polynomial of degree $m$, and a factor of $x^r-1$. \mbox{\texttt{\mdseries\slshape b}} an integer $0 \leq b \leq m$ not divisible by $r$, that determines the burst length of a single error burst that can be
corrected. The argument \mbox{\texttt{\mdseries\slshape g}} can be a polynomial with base ring $GF(2)$, or a list of coefficients in $GF(2)$. The generator polynomial of the code is defined as the product of \mbox{\texttt{\mdseries\slshape g}} and $x^{2b-1}+1$. 

 Here is the general definition of 'Fire code', named after P. Fire, who
introduced these codes in 1959 in order to correct burst errors. First, a
definition. If $F=GF(q)$ and $f\in F[x]$ then we say $f$ has \emph{order} $e$ if $f(x)|(x^e-1)$. \index{order of polynomial} A \emph{Fire code} is a cyclic code over $F$ with generator polynomial $g(x)= (x^{2t-1}-1)p(x)$, where $p(x)$ does not divide $x^{2t-1}-1$ and satisfies $deg(p(x))\geq t$. The length of such a code is the order of $g(x)$.  Non-binary Fire codes have not been implemented. }

 . 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:= Indeterminate( GF(2) );; G:= x^3+x^2+1;|
  Z(2)^0+x^2+x^3
  !gapprompt@gap>| !gapinput@Factors( G );|
  [ Z(2)^0+x^2+x^3 ]
  !gapprompt@gap>| !gapinput@C := FireCode( G, 3 );|
  a cyclic [35,27,1..4]2..6 3 burst error correcting fire code over GF(2)
  !gapprompt@gap>| !gapinput@MinimumDistance( C );|
  4     # Still it can correct bursts of length 3 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{WholeSpaceCode}}
\logpage{[ 5, 5, 11 ]}\nobreak
\hyperdef{L}{X7BC245E37EB7B23F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WholeSpaceCode({\mdseries\slshape n, F})\index{WholeSpaceCode@\texttt{WholeSpaceCode}}
\label{WholeSpaceCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{WholeSpaceCode} returns the cyclic whole space code of length \mbox{\texttt{\mdseries\slshape n}} over \mbox{\texttt{\mdseries\slshape F}}. This code consists of all polynomials of degree less than \mbox{\texttt{\mdseries\slshape n}} and coefficients in \mbox{\texttt{\mdseries\slshape F}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := WholeSpaceCode( 5, GF(3) );|
  a cyclic [5,5,1]0 whole space code over GF(3)
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NullCode}}
\logpage{[ 5, 5, 12 ]}\nobreak
\hyperdef{L}{X7B4EF2017B2C61AD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NullCode({\mdseries\slshape n, F})\index{NullCode@\texttt{NullCode}}
\label{NullCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{NullCode} returns the zero-dimensional nullcode with length \mbox{\texttt{\mdseries\slshape n}} over \mbox{\texttt{\mdseries\slshape F}}. This code has only one word: the all zero word. It is cyclic though! }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := NullCode( 5, GF(3) );|
  a cyclic [5,0,5]5 nullcode over GF(3)
  !gapprompt@gap>| !gapinput@AsSSortedList( C );|
  [ [ 0 0 0 0 0 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RepetitionCode}}
\logpage{[ 5, 5, 13 ]}\nobreak
\hyperdef{L}{X83C5F8FE7827EAA7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RepetitionCode({\mdseries\slshape n, F})\index{RepetitionCode@\texttt{RepetitionCode}}
\label{RepetitionCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RepetitionCode} returns the cyclic repetition code of length \mbox{\texttt{\mdseries\slshape n}} over \mbox{\texttt{\mdseries\slshape F}}. The code has as many elements as \mbox{\texttt{\mdseries\slshape F}}, because each codeword consists of a repetition of one of these elements. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := RepetitionCode( 3, GF(5) );|
  a cyclic [3,1,3]2 repetition code over GF(5)
  !gapprompt@gap>| !gapinput@AsSSortedList( C );|
  [ [ 0 0 0 ], [ 1 1 1 ], [ 2 2 2 ], [ 4 4 4 ], [ 3 3 3 ] ]
  !gapprompt@gap>| !gapinput@IsPerfectCode( C );|
  false
  !gapprompt@gap>| !gapinput@IsMDSCode( C );|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CyclicCodes}}
\logpage{[ 5, 5, 14 ]}\nobreak
\hyperdef{L}{X82FA9F65854D98A6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CyclicCodes({\mdseries\slshape n, F})\index{CyclicCodes@\texttt{CyclicCodes}}
\label{CyclicCodes}
}\hfill{\scriptsize (function)}}\\


 \texttt{CyclicCodes} returns a list of all cyclic codes of length \mbox{\texttt{\mdseries\slshape n}} over \mbox{\texttt{\mdseries\slshape F}}. It constructs all possible generator polynomials from the factors of $x^n-1$. Each combination of these factors yields a generator polynomial after
multiplication. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CyclicCodes(3,GF(3));|
  [ a cyclic [3,3,1]0 enumerated code over GF(3), 
  a cyclic [3,2,1..2]1 enumerated code over GF(3), 
  a cyclic [3,1,3]2 enumerated code over GF(3), 
  a cyclic [3,0,3]3 enumerated code over GF(3) ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{NrCyclicCodes}}
\logpage{[ 5, 5, 15 ]}\nobreak
\hyperdef{L}{X8263CE4A790D294A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NrCyclicCodes({\mdseries\slshape n, F})\index{NrCyclicCodes@\texttt{NrCyclicCodes}}
\label{NrCyclicCodes}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{NrCyclicCodes} calculates the number of cyclic codes of length \mbox{\texttt{\mdseries\slshape n}} over field \mbox{\texttt{\mdseries\slshape F}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@NrCyclicCodes( 23, GF(2) );|
  8
  !gapprompt@gap>| !gapinput@codelist := CyclicCodes( 23, GF(2) );|
  [ a cyclic [23,23,1]0 enumerated code over GF(2), 
    a cyclic [23,22,1..2]1 enumerated code over GF(2), 
    a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
    a cyclic [23,0,23]23 enumerated code over GF(2), 
    a cyclic [23,11,1..8]4..7 enumerated code over GF(2), 
    a cyclic [23,12,1..7]3 enumerated code over GF(2), 
    a cyclic [23,1,23]11 enumerated code over GF(2), 
    a cyclic [23,12,1..7]3 enumerated code over GF(2) ]
  !gapprompt@gap>| !gapinput@BinaryGolayCode() in codelist;|
  true
  !gapprompt@gap>| !gapinput@RepetitionCode( 23, GF(2) ) in codelist;|
  true
  !gapprompt@gap>| !gapinput@CordaroWagnerCode( 23 ) in codelist;|
  false    # This code is not cyclic 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{QuasiCyclicCode}}
\logpage{[ 5, 5, 16 ]}\nobreak
\hyperdef{L}{X79826B16785E8BD3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{QuasiCyclicCode({\mdseries\slshape G, s, F})\index{QuasiCyclicCode@\texttt{QuasiCyclicCode}}
\label{QuasiCyclicCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{QuasiCyclicCode( G, k, F )} generates a rate $1/m$ quasi-cyclic code over field \mbox{\texttt{\mdseries\slshape F}}. The input \mbox{\texttt{\mdseries\slshape G}} is a list of univariate polynomials and $m$ is the cardinality of this list. Note that $m$ must be at least $2$. The input \mbox{\texttt{\mdseries\slshape s}} is the size of each circulant and it may not necessarily be the same as the
code dimension $k$, i.e. $k \le s$. 

 There also exists another version, \texttt{QuasiCyclicCode( G, s )} which produces quasi-cyclic codes over $F_2$ only. Here the parameter \mbox{\texttt{\mdseries\slshape s}} holds the same definition and the input \mbox{\texttt{\mdseries\slshape G}} is a list of integers, where each integer is an octal representation of a
binary univariate polynomial. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@# This example show the case for k = s|
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@L1 := PolyCodeword( Codeword("10000000000", GF(4)) );|
  Z(2)^0
  !gapprompt@gap>| !gapinput@L2 := PolyCodeword( Codeword("12223201000", GF(4)) );|
  x^7+Z(2^2)*x^5+Z(2^2)^2*x^4+Z(2^2)*x^3+Z(2^2)*x^2+Z(2^2)*x+Z(2)^0
  !gapprompt@gap>| !gapinput@L3 := PolyCodeword( Codeword("31111220110", GF(4)) );|
  x^9+x^8+Z(2^2)*x^6+Z(2^2)*x^5+x^4+x^3+x^2+x+Z(2^2)^2
  !gapprompt@gap>| !gapinput@L4 := PolyCodeword( Codeword("13320333010", GF(4)) );|
  x^9+Z(2^2)^2*x^7+Z(2^2)^2*x^6+Z(2^2)^2*x^5+Z(2^2)*x^3+Z(2^2)^2*x^2+Z(2^2)^2*x+\
  Z(2)^0
  !gapprompt@gap>| !gapinput@L5 := PolyCodeword( Codeword("20102211100", GF(4)) );|
  x^8+x^7+x^6+Z(2^2)*x^5+Z(2^2)*x^4+x^2+Z(2^2)
  !gapprompt@gap>| !gapinput@C := QuasiCyclicCode( [L1, L2, L3, L4, L5], 11, GF(4) );|
  a linear [55,11,1..32]24..41 quasi-cyclic code over GF(4)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  29
  !gapprompt@gap>| !gapinput@Display(C);|
  a linear [55,11,29]24..41 quasi-cyclic code over GF(4)
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@# This example show the case for k < s|
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@L1 := PolyCodeword( Codeword("02212201220120211002000",GF(3)) );|
  -x^19+x^16+x^15-x^14-x^12+x^11-x^9-x^8+x^7-x^5-x^4+x^3-x^2-x
  !gapprompt@gap>| !gapinput@L2 := PolyCodeword( Codeword("00221100200120220001110",GF(3)) );|
  x^21+x^20+x^19-x^15-x^14-x^12+x^11-x^8+x^5+x^4-x^3-x^2
  !gapprompt@gap>| !gapinput@L3 := PolyCodeword( Codeword("22021011202221111020021",GF(3)) );|
  x^22-x^21-x^18+x^16+x^15+x^14+x^13-x^12-x^11-x^10-x^8+x^7+x^6+x^4-x^3-x-Z(3)^0
  !gapprompt@gap>| !gapinput@C := QuasiCyclicCode( [L1, L2, L3], 23, GF(3) );|
  a linear [69,12,1..37]27..46 quasi-cyclic code over GF(3)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  34
  !gapprompt@gap>| !gapinput@Display(C);|
  a linear [69,12,34]27..46 quasi-cyclic code over GF(3)
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@# This example show the binary case using octal representation|
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@L1 := 001;;   # 0 000 001|
  !gapprompt@gap>| !gapinput@L2 := 013;;   # 0 001 011|
  !gapprompt@gap>| !gapinput@L3 := 015;;   # 0 001 101|
  !gapprompt@gap>| !gapinput@L4 := 077;;   # 0 111 111|
  !gapprompt@gap>| !gapinput@C := QuasiCyclicCode( [L1, L2, L3, L4], 7 );|
  a linear [28,7,1..12]8..14 quasi-cyclic code over GF(2)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  12
  !gapprompt@gap>| !gapinput@Display(C);|
  a linear [28,7,12]8..14 quasi-cyclic code over GF(2)
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CyclicMDSCode}}
\logpage{[ 5, 5, 17 ]}\nobreak
\hyperdef{L}{X7BFEDA52835A601D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CyclicMDSCode({\mdseries\slshape q, m, k})\index{CyclicMDSCode@\texttt{CyclicMDSCode}}
\label{CyclicMDSCode}
}\hfill{\scriptsize (function)}}\\


 Given the input parameters \mbox{\texttt{\mdseries\slshape q}}, \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape k}}, this function returns a $[q^m + 1, k, q^m - k + 2]$ cyclic MDS code over GF($q^m$). If $q^m$ is even, any value of $k$ can be used, otherwise only odd value of $k$ is accepted. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=CyclicMDSCode(2,6,24);|
  a cyclic [65,24,42]31..41 MDS code over GF(64)
  !gapprompt@gap>| !gapinput@IsMDSCode(C);|
  true
  !gapprompt@gap>| !gapinput@C:=CyclicMDSCode(5,3,77);|
  a cyclic [126,77,50]35..49 MDS code over GF(125)
  !gapprompt@gap>| !gapinput@IsMDSCode(C);|
  true
  !gapprompt@gap>| !gapinput@C:=CyclicMDSCode(3,3,25);|
  a cyclic [28,25,4]2..3 MDS code over GF(27)
  !gapprompt@gap>| !gapinput@GeneratorPol(C);|
  x^3+Z(3^3)^7*x^2+Z(3^3)^20*x-Z(3)^0
  gap>
\end{Verbatim}
  \index{MDS} \index{cyclic} 

\subsection{\textcolor{Chapter }{FourNegacirculantSelfDualCode}}
\logpage{[ 5, 5, 18 ]}\nobreak
\hyperdef{L}{X7F40AF3B81C252DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FourNegacirculantSelfDualCode({\mdseries\slshape ax, bx, k})\index{FourNegacirculantSelfDualCode@\texttt{FourNegacirculantSelfDualCode}}
\label{FourNegacirculantSelfDualCode}
}\hfill{\scriptsize (function)}}\\


 A four-negacirculant self-dual code has a generator matrix $G$ of the the following form 
\begin{verbatim}  
      -                    -
      |        |  A  |  B  |
  G = |  I_2k  |-----+-----|
      |        | -B^T| A^T |
      -                    -
  		
\end{verbatim}
 where $AA^T + BB^T = -I_k$ and $A$, $B$ and their transposed are all $k \times k$ negacirculant matrices. The generator matrix $G$ returns a $[2k, k, d]_q$ self-dual code over GF($q$). For discussion on four-negacirculant self-dual codes, refer to \cite{HHKK07}. 

 The input parameters \mbox{\texttt{\mdseries\slshape ax}} and \mbox{\texttt{\mdseries\slshape bx}} are the defining polynomials over GF($q$) of negacirculant matrices $A$ and $B$ respectively. The last parameter \mbox{\texttt{\mdseries\slshape k}} is the dimension of the code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ax:=PolyCodeword(Codeword("1200200", GF(3)));|
  -x_1^4-x_1+Z(3)^0
  !gapprompt@gap>| !gapinput@bx:=PolyCodeword(Codeword("2020221", GF(3)));|
  x_1^6-x_1^5-x_1^4-x_1^2-Z(3)^0
  !gapprompt@gap>| !gapinput@C:=FourNegacirculantSelfDualCode(ax, bx, 14);;|
  !gapprompt@gap>| !gapinput@MinimumDistance(C);;|
  !gapprompt@gap>| !gapinput@CoveringRadius(C);;|
  !gapprompt@gap>| !gapinput@IsSelfDualCode(C);|
  true
  !gapprompt@gap>| !gapinput@Display(C);|
  a linear [28,14,9]7 four-negacirculant self-dual code over GF(3)
  !gapprompt@gap>| !gapinput@Display( GeneratorMat(C) );|
   1 . . . . . . . . . . . . . 1 2 . . 2 . . 2 . 2 . 2 2 1
   . 1 . . . . . . . . . . . . . 1 2 . . 2 . 2 2 . 2 . 2 2
   . . 1 . . . . . . . . . . . . . 1 2 . . 2 1 2 2 . 2 . 2
   . . . 1 . . . . . . . . . . 1 . . 1 2 . . 1 1 2 2 . 2 .
   . . . . 1 . . . . . . . . . . 1 . . 1 2 . . 1 1 2 2 . 2
   . . . . . 1 . . . . . . . . . . 1 . . 1 2 1 . 1 1 2 2 .
   . . . . . . 1 . . . . . . . 1 . . 1 . . 1 . 1 . 1 1 2 2
   . . . . . . . 1 . . . . . . 1 1 2 2 . 2 . 1 . . 1 . . 1
   . . . . . . . . 1 . . . . . . 1 1 2 2 . 2 2 1 . . 1 . .
   . . . . . . . . . 1 . . . . 1 . 1 1 2 2 . . 2 1 . . 1 .
   . . . . . . . . . . 1 . . . . 1 . 1 1 2 2 . . 2 1 . . 1
   . . . . . . . . . . . 1 . . 1 . 1 . 1 1 2 2 . . 2 1 . .
   . . . . . . . . . . . . 1 . 1 1 . 1 . 1 1 . 2 . . 2 1 .
   . . . . . . . . . . . . . 1 2 1 1 . 1 . 1 . . 2 . . 2 1
  !gapprompt@gap>| !gapinput@ax:=PolyCodeword(Codeword("013131000", GF(7)));|
  x_1^5+Z(7)*x_1^4+x_1^3+Z(7)*x_1^2+x_1
  !gapprompt@gap>| !gapinput@bx:=PolyCodeword(Codeword("425435030", GF(7)));|
  Z(7)*x_1^7+Z(7)^5*x_1^5+Z(7)*x_1^4+Z(7)^4*x_1^3+Z(7)^5*x_1^2+Z(7)^2*x_1+Z(7)^4
  !gapprompt@gap>| !gapinput@C:=FourNegacirculantSelfDualCodeNC(ax, bx, 18);|
  a linear [36,18,1..13]0..36 four-negacirculant self-dual code over GF(7)
  !gapprompt@gap>| !gapinput@IsSelfDualCode(C);|
  true
\end{Verbatim}
  \index{self-dual} 

\subsection{\textcolor{Chapter }{FourNegacirculantSelfDualCodeNC}}
\logpage{[ 5, 5, 19 ]}\nobreak
\hyperdef{L}{X87137A257E761291}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FourNegacirculantSelfDualCodeNC({\mdseries\slshape ax, bx, k})\index{FourNegacirculantSelfDualCodeNC@\texttt{FourNegacirculantSelfDualCodeNC}}
\label{FourNegacirculantSelfDualCodeNC}
}\hfill{\scriptsize (function)}}\\


 This function is the same as \texttt{FourNegacirculantSelfDualCode}, except this version is faster as it does not estimate the minimum distance
and covering radius of the code. }

 }

 
\section{\textcolor{Chapter }{ Evaluation Codes }}\logpage{[ 5, 6, 0 ]}
\hyperdef{L}{X850A28C579137220}{}
{
  \label{Evaluation Codes} \index{code, evaluation} 

\subsection{\textcolor{Chapter }{EvaluationCode}}
\logpage{[ 5, 6, 1 ]}\nobreak
\hyperdef{L}{X78E078567D19D433}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EvaluationCode({\mdseries\slshape P, L, R})\index{EvaluationCode@\texttt{EvaluationCode}}
\label{EvaluationCode}
}\hfill{\scriptsize (function)}}\\


 Input: \mbox{\texttt{\mdseries\slshape F}} is a finite field, \mbox{\texttt{\mdseries\slshape L}} is a list of rational functions in $R=F[x_1,...,x_r]$, \mbox{\texttt{\mdseries\slshape P}} is a list of $n$ points in $F^r$ at which all of the functions in \mbox{\texttt{\mdseries\slshape L}} are defined. \\
 Output: The 'evaluation code' $C$, which is the image of the evalation map 
\[ Eval_P:span(L)\rightarrow F^n, \]
 given by $f\longmapsto (f(p_1),...,f(p_n))$, where $P=\{p_1,...,p_n\}$ and $f \in L$. The generator matrix of $C$ is $G=(f_i(p_j))_{f_i\in L,p_j\in P}$. 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.EvaluationMat} (not the same as the generator matrix in general), \texttt{C!.points} (namely \mbox{\texttt{\mdseries\slshape P}}), \texttt{C!.basis} (namely \mbox{\texttt{\mdseries\slshape L}}), and \texttt{C!.ring} (namely \mbox{\texttt{\mdseries\slshape R}}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R := PolynomialRing(F,2);;|
  !gapprompt@gap>| !gapinput@indets := IndeterminatesOfPolynomialRing(R);;|
  !gapprompt@gap>| !gapinput@x:=indets[1];; y:=indets[2];;|
  !gapprompt@gap>| !gapinput@L:=[x^2*y,x*y,x^5,x^4,x^3,x^2,x,x^0];;|
  !gapprompt@gap>| !gapinput@Pts:=[ [ Z(11)^9, Z(11) ], [ Z(11)^8, Z(11) ], [ Z(11)^7, 0*Z(11) ],|
     [ Z(11)^6, 0*Z(11) ], [ Z(11)^5, 0*Z(11) ], [ Z(11)^4, 0*Z(11) ],
     [ Z(11)^3, Z(11) ], [ Z(11)^2, 0*Z(11) ], [ Z(11), 0*Z(11) ], 
     [ Z(11)^0, 0*Z(11) ], [ 0*Z(11), Z(11) ] ];;
  !gapprompt@gap>| !gapinput@C:=EvaluationCode(Pts,L,R);|
  a linear [11,8,1..3]2..3  evaluation code over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  3
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralizedReedSolomonCode}}
\logpage{[ 5, 6, 2 ]}\nobreak
\hyperdef{L}{X810AB3DB844FFCE9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralizedReedSolomonCode({\mdseries\slshape P, k, R})\index{GeneralizedReedSolomonCode@\texttt{GeneralizedReedSolomonCode}}
\label{GeneralizedReedSolomonCode}
}\hfill{\scriptsize (function)}}\\


 Input: R=F[x], where \mbox{\texttt{\mdseries\slshape F}} is a finite field, \mbox{\texttt{\mdseries\slshape k}} is a positive integer, \mbox{\texttt{\mdseries\slshape P}} is a list of $n$ points in $F$. \\
 Output: The $C$ which is the image of the evaluation map 
\[ Eval_P:F[x]_k\rightarrow F^n, \]
 given by $f\longmapsto (f(p_1),...,f(p_n))$, where $P=\{p_1,...,p_n\}\subset F$ and $f$ ranges over the space $F[x]_k$ of all polynomials of degree less than $k$. 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.points} (namely \mbox{\texttt{\mdseries\slshape P}}), \texttt{C!.degree} (namely \mbox{\texttt{\mdseries\slshape k}}), and \texttt{C!.ring} (namely \mbox{\texttt{\mdseries\slshape R}}). 

 This code can be decoded using \texttt{Decodeword}, which applies the special decoder method (the interpolation method), or
using \texttt{GeneralizedReedSolomonDecoderGao} which applies an algorithm of S. Gao (see \texttt{GeneralizedReedSolomonDecoderGao} (\ref{GeneralizedReedSolomonDecoderGao})). This code has a special decoder record which implements the interpolation
algorithm described in section 5.2 of Justesen and Hoholdt \cite{JH04}. See \texttt{Decode} (\ref{Decode}) and \texttt{Decodeword} (\ref{Decodeword}) for more details. 

 The weighted version has implemented with the option \texttt{GeneralizedReedSolomonCode(P,k,R,wts)}, where $wts = [v_1, ..., v_n]$ is a sequence of $n$ non-zero elements from the base field $F$ of \mbox{\texttt{\mdseries\slshape R}}. See also the generalized Reed--Solomon code $GRS_k(P, V)$ described in \cite{MS83}, p.303. 

 The list-decoding algorithm of Sudan-Guraswami (described in section 12.1 of \cite{JH04}) has been implemented for generalized Reed-Solomon codes. See \texttt{GeneralizedReedSolomonListDecoder} (\ref{GeneralizedReedSolomonListDecoder}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R:=PolynomialRing(GF(11),["t"]);|
  GF(11)[t]
  !gapprompt@gap>| !gapinput@P:=List([1,3,4,5,7],i->Z(11)^i);|
  [ Z(11), Z(11)^3, Z(11)^4, Z(11)^5, Z(11)^7 ]
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedSolomonCode(P,3,R);|
  a linear [5,3,1..3]2  generalized Reed-Solomon code over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  3
  !gapprompt@gap>| !gapinput@V:=[Z(11)^0,Z(11)^0,Z(11)^0,Z(11)^0,Z(11)];|
  [ Z(11)^0, Z(11)^0, Z(11)^0, Z(11)^0, Z(11) ]
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedSolomonCode(P,3,R,V);|
  a linear [5,3,1..3]2  weighted generalized Reed-Solomon code over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  3
\end{Verbatim}
  See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. 

\subsection{\textcolor{Chapter }{GeneralizedReedMullerCode}}
\logpage{[ 5, 6, 3 ]}\nobreak
\hyperdef{L}{X85B8699680B9D786}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralizedReedMullerCode({\mdseries\slshape Pts, r, F})\index{GeneralizedReedMullerCode@\texttt{GeneralizedReedMullerCode}}
\label{GeneralizedReedMullerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedReedMullerCode} returns a 'Reed-Muller code' $C$ with length $|Pts|$ and order $r$. One considers (a) a basis of monomials for the vector space over $F=GF(q)$ of all polynomials in $F[x_1,...,x_d]$ of degree at most $r$, and (b) a set $Pts$ of points in $F^d$. The generator matrix of the associated \emph{Reed-Muller code} $C$ is $G=(f(p))_{f\in B,p \in Pts}$. This code $C$ is constructed using the command \texttt{GeneralizedReedMullerCode(Pts,r,F)}. When $Pts$ is the set of all $q^d$ points in $F^d$ then the command \texttt{GeneralizedReedMuller(d,r,F)} yields the code. When $Pts$ is the set of all $(q-1)^d$ points with no coordinate equal to $0$ then this is can be constructed using the \texttt{ToricCode} command (as a special case). 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.points} (namely \mbox{\texttt{\mdseries\slshape Pts}}) and \texttt{C!.degree} (namely \mbox{\texttt{\mdseries\slshape r}}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Pts:=ToricPoints(2,GF(5));|
  [ [ Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5) ], [ Z(5)^0, Z(5)^2 ], [ Z(5)^0, Z(5)^3 ],
    [ Z(5), Z(5)^0 ], [ Z(5), Z(5) ], [ Z(5), Z(5)^2 ], [ Z(5), Z(5)^3 ],
    [ Z(5)^2, Z(5)^0 ], [ Z(5)^2, Z(5) ], [ Z(5)^2, Z(5)^2 ], [ Z(5)^2, Z(5)^3 ],
    [ Z(5)^3, Z(5)^0 ], [ Z(5)^3, Z(5) ], [ Z(5)^3, Z(5)^2 ], [ Z(5)^3, Z(5)^3 ] ]
  !gapprompt@gap>| !gapinput@C:=GeneralizedReedMullerCode(Pts,2,GF(5));|
  a linear [16,6,1..11]6..10  generalized Reed-Muller code over GF(5)
\end{Verbatim}
 See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. 

\subsection{\textcolor{Chapter }{ToricPoints}}
\logpage{[ 5, 6, 4 ]}\nobreak
\hyperdef{L}{X7EE68B58872D7E82}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ToricPoints({\mdseries\slshape n, F})\index{ToricPoints@\texttt{ToricPoints}}
\label{ToricPoints}
}\hfill{\scriptsize (function)}}\\


 \texttt{ToricPoints(n,F)} returns the points in $(F^{\times})^n$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ToricPoints(2,GF(5));|
  [ [ Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5) ], [ Z(5)^0, Z(5)^2 ], 
    [ Z(5)^0, Z(5)^3 ], [ Z(5), Z(5)^0 ], [ Z(5), Z(5) ], [ Z(5), Z(5)^2 ], 
    [ Z(5), Z(5)^3 ], [ Z(5)^2, Z(5)^0 ], [ Z(5)^2, Z(5) ], [ Z(5)^2, Z(5)^2 ], 
    [ Z(5)^2, Z(5)^3 ], [ Z(5)^3, Z(5)^0 ], [ Z(5)^3, Z(5) ], 
    [ Z(5)^3, Z(5)^2 ], [ Z(5)^3, Z(5)^3 ] ]
\end{Verbatim}
  \index{code, toric} 

\subsection{\textcolor{Chapter }{ToricCode}}
\logpage{[ 5, 6, 5 ]}\nobreak
\hyperdef{L}{X7B24BE418010F596}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ToricCode({\mdseries\slshape L, F})\index{ToricCode@\texttt{ToricCode}}
\label{ToricCode}
}\hfill{\scriptsize (function)}}\\


 This function returns the toric codes as in D. Joyner \cite{Jo04} (see also J. P. Hansen \cite{Han99}). This is a truncated (generalized) Reed-Muller code. Here \mbox{\texttt{\mdseries\slshape L}} is a list of integral vectors and \mbox{\texttt{\mdseries\slshape F}} is the finite field. The size of \mbox{\texttt{\mdseries\slshape F}} must be different from $2$. 

 This command returns a record object \texttt{C} with an extra component (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.exponents} (namely \mbox{\texttt{\mdseries\slshape L}}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=ToricCode([[1,0],[3,4]],GF(3));|
  a linear [4,1,4]2 toric code over GF(3)
  !gapprompt@gap>| !gapinput@Display(GeneratorMat(C));|
   1 1 2 2
  !gapprompt@gap>| !gapinput@Elements(C);|
  [ [ 0 0 0 0 ], [ 1 1 2 2 ], [ 2 2 1 1 ] ]
\end{Verbatim}
  See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. }

 
\section{\textcolor{Chapter }{ Algebraic geometric codes }}\logpage{[ 5, 7, 0 ]}
\hyperdef{L}{X7AE2B2CD7C647990}{}
{
  \label{Algebraic geometric codes} \index{code, AG} Certain \textsf{GUAVA} functions related to algebraic geometric codes are described in this section. 

\subsection{\textcolor{Chapter }{AffineCurve}}
\logpage{[ 5, 7, 1 ]}\nobreak
\hyperdef{L}{X802DD9FB79A9ACA7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AffineCurve({\mdseries\slshape poly, ring})\index{AffineCurve@\texttt{AffineCurve}}
\label{AffineCurve}
}\hfill{\scriptsize (function)}}\\


 This function simply defines the data structure of an affine plane curve. In \textsf{GUAVA}, an affine curve is a record \mbox{\texttt{\mdseries\slshape crv}} having two components: a polynomial \mbox{\texttt{\mdseries\slshape poly}}, accessed in \textsf{GUAVA} by \mbox{\texttt{\mdseries\slshape crv.polynomial}}, and a polynomial ring over a field $F$ in two variables \mbox{\texttt{\mdseries\slshape ring}}, accessed in \textsf{GUAVA} by \mbox{\texttt{\mdseries\slshape crv.ring}}, containing \mbox{\texttt{\mdseries\slshape poly}}. You use this function to define a curve in \textsf{GUAVA}. 

 For example, for the ring, one could take ${\mathbb{Q}}[x,y]$, and for the polynomial one could take $f(x,y)=x^2+y^2-1$. For the affine line, simply taking ${\mathbb{Q}}[x,y]$ for the ring and $f(x,y)=y$ for the polynomial. 

 (Not sure if $F$ neeeds to be a field in fact ...) 

 To compute its degree, simply use the \texttt{DegreeMultivariatePolynomial} (\ref{DegreeMultivariatePolynomial}) command. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  gap>
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,2);|
  PolynomialRing(..., [ x_1, x_2 ])
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R2);;|
  !gapprompt@gap>| !gapinput@x:=vars[1];; y:=vars[2];;|
  !gapprompt@gap>| !gapinput@poly:=y;; crvP1:=AffineCurve(poly,R2);|
  rec( ring := PolynomialRing(..., [ x_1, x_2 ]), polynomial := x_2 )
  !gapprompt@gap>| !gapinput@degree_crv:=DegreeMultivariatePolynomial(poly,R2);|
  1
  !gapprompt@gap>| !gapinput@poly:=y^2-x*(x^2-1);; ell_crv:=AffineCurve(poly,R2);|
  rec( ring := PolynomialRing(..., [ x_1, x_2 ]), polynomial := -x_1^3+x_2^2+x_1 )
  !gapprompt@gap>| !gapinput@degree_crv:=DegreeMultivariatePolynomial(poly,R2);|
  3
  !gapprompt@gap>| !gapinput@poly:=x^2+y^2-1;; circle:=AffineCurve(poly,R2);|
  rec( ring := PolynomialRing(..., [ x_1, x_2 ]), polynomial := x_1^2+x_2^2-Z(11)^0 )
  !gapprompt@gap>| !gapinput@degree_crv:=DegreeMultivariatePolynomial(poly,R2);|
  2
  !gapprompt@gap>| !gapinput@q:=3;;|
  !gapprompt@gap>| !gapinput@F:=GF(q^2);;|
  !gapprompt@gap>| !gapinput@R:=PolynomialRing(F,2);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R);|
  [ x_1, x_2 ]
  !gapprompt@gap>| !gapinput@x:=vars[1];|
  x_1
  !gapprompt@gap>| !gapinput@y:=vars[2];|
  x_2
  !gapprompt@gap>| !gapinput@crv:=AffineCurve(y^q+y-x^(q+1),R);|
  rec( ring := PolynomialRing(..., [ x_1, x_2 ]), polynomial := -x_1^4+x_2^3+x_2 )
  gap>
\end{Verbatim}
  In GAP, a \emph{point} \index{point} on a curve defined by $f(x,y)=0$ is simply a list \mbox{\texttt{\mdseries\slshape [a,b]}} of elements of $F$ satisfying this polynomial equation. 

\subsection{\textcolor{Chapter }{AffinePointsOnCurve}}
\logpage{[ 5, 7, 2 ]}\nobreak
\hyperdef{L}{X857EFE567C05C981}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AffinePointsOnCurve({\mdseries\slshape f, R, E})\index{AffinePointsOnCurve@\texttt{AffinePointsOnCurve}}
\label{AffinePointsOnCurve}
}\hfill{\scriptsize (function)}}\\


 \texttt{AffinePointsOnCurve(f,R,E)} returns the points $(x,y) \in E^2$ satisying $f(x,y)=0$, where \mbox{\texttt{\mdseries\slshape f}} is an element of $R=F[x,y]$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R := PolynomialRing(F,["x","y"]);|
  PolynomialRing(..., [ x, y ])
  !gapprompt@gap>| !gapinput@indets := IndeterminatesOfPolynomialRing(R);;|
  !gapprompt@gap>| !gapinput@x:=indets[1];; y:=indets[2];;|
  !gapprompt@gap>| !gapinput@P:=AffinePointsOnCurve(y^2-x^11+x,R,F);|
  [ [ Z(11)^9, 0*Z(11) ], [ Z(11)^8, 0*Z(11) ], [ Z(11)^7, 0*Z(11) ], 
    [ Z(11)^6, 0*Z(11) ], [ Z(11)^5, 0*Z(11) ], [ Z(11)^4, 0*Z(11) ], 
    [ Z(11)^3, 0*Z(11) ], [ Z(11)^2, 0*Z(11) ], [ Z(11), 0*Z(11) ], 
    [ Z(11)^0, 0*Z(11) ], [ 0*Z(11), 0*Z(11) ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GenusCurve}}
\logpage{[ 5, 7, 3 ]}\nobreak
\hyperdef{L}{X857E36ED814A40B8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GenusCurve({\mdseries\slshape crv})\index{GenusCurve@\texttt{GenusCurve}}
\label{GenusCurve}
}\hfill{\scriptsize (function)}}\\


 If \mbox{\texttt{\mdseries\slshape crv}} represents $f(x,y)=0$, where $f$ is a polynomial of degree $d$, then this function simply returns $(d-1)(d-2)/2$. At the present, the function does not check if the curve is singular (in
which case the result may be false). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@q:=4;;|
  !gapprompt@gap>| !gapinput@F:=GF(q^2);;|
  !gapprompt@gap>| !gapinput@a:=X(F);;|
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,[a]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);;|
  !gapprompt@gap>| !gapinput@b:=X(F);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,[a,b]);;|
  !gapprompt@gap>| !gapinput@var2:=IndeterminatesOfPolynomialRing(R2);;|
  !gapprompt@gap>| !gapinput@crv:=AffineCurve(b^q+b-a^(q+1),R2);;|
  !gapprompt@gap>| !gapinput@crv:=AffineCurve(b^q+b-a^(q+1),R2);|
  rec( ring := PolynomialRing(..., [ x_1, x_1 ]), polynomial := x_1^5+x_1^4+x_1 )
  !gapprompt@gap>| !gapinput@GenusCurve(crv);|
  36
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{GOrbitPoint }}
\logpage{[ 5, 7, 4 ]}\nobreak
\hyperdef{L}{X8572A3037DA66F88}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GOrbitPoint ({\mdseries\slshape G, P})\index{GOrbitPoint @\texttt{GOrbitPoint }}
\label{GOrbitPoint }
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape P}} must be a point in projective space $\mathbb{P}^n(F)$, \mbox{\texttt{\mdseries\slshape G}} must be a finite subgroup of $GL(n+1,F)$, This function returns all (representatives of projective) points in the
orbit $G\cdot P$. 

 The example below computes the orbit of the automorphism group on the Klein
quartic over the field $GF(43)$ on the ``point at infinity''. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R:= PolynomialRing( GF(43), 3 );;|
  !gapprompt@gap>| !gapinput@vars:= IndeterminatesOfPolynomialRing(R);;|
  !gapprompt@gap>| !gapinput@x:= vars[1];; y:= vars[2];; z:= vars[3];;|
  !gapprompt@gap>| !gapinput@zz:=Z(43)^6;|
  Z(43)^6
  !gapprompt@gap>| !gapinput@zzz:=Z(43);|
  Z(43)
  !gapprompt@gap>| !gapinput@rho1:=zz^0*[[zz^4,0,0],[0,zz^2,0],[0,0,zz]];|
  [ [ Z(43)^24, 0*Z(43), 0*Z(43) ], 
  [ 0*Z(43), Z(43)^12, 0*Z(43) ], 
  [ 0*Z(43), 0*Z(43), Z(43)^6 ] ]
  !gapprompt@gap>| !gapinput@rho2:=zz^0*[[0,1,0],[0,0,1],[1,0,0]];|
  [ [ 0*Z(43), Z(43)^0, 0*Z(43) ], 
  [ 0*Z(43), 0*Z(43), Z(43)^0 ], 
  [ Z(43)^0, 0*Z(43), 0*Z(43) ] ]
  !gapprompt@gap>| !gapinput@rho3:=(-1)*[[(zz-zz^6 )/zzz^7,( zz^2-zz^5 )/ zzz^7, ( zz^4-zz^3 )/ zzz^7],|
  !gapprompt@>| !gapinput@            [( zz^2-zz^5 )/ zzz^7, ( zz^4-zz^3 )/ zzz^7, ( zz-zz^6 )/ zzz^7],|
  !gapprompt@>| !gapinput@            [( zz^4-zz^3 )/ zzz^7, ( zz-zz^6 )/ zzz^7, ( zz^2-zz^5 )/ zzz^7]];|
  [ [ Z(43)^9, Z(43)^28, Z(43)^12 ], 
  [ Z(43)^28, Z(43)^12, Z(43)^9 ], 
  [ Z(43)^12, Z(43)^9, Z(43)^28 ] ]
  !gapprompt@gap>| !gapinput@G:=Group([rho1,rho2,rho3]);; #PSL(2,7)|
  !gapprompt@gap>| !gapinput@Size(G);|
  168
  !gapprompt@gap>| !gapinput@P:=[1,0,0]*zzz^0;|
  [ Z(43)^0, 0*Z(43), 0*Z(43) ]
  !gapprompt@gap>| !gapinput@O:=GOrbitPoint(G,P);|
  [ [ Z(43)^0, 0*Z(43), 0*Z(43) ], [ 0*Z(43), Z(43)^0, 0*Z(43) ], 
  [ 0*Z(43), 0*Z(43), Z(43)^0 ], [ Z(43)^0, Z(43)^39, Z(43)^16 ], 
  [ Z(43)^0, Z(43)^33, Z(43)^28 ], [ Z(43)^0, Z(43)^27, Z(43)^40 ],
  [ Z(43)^0, Z(43)^21, Z(43)^10 ], [ Z(43)^0, Z(43)^15, Z(43)^22 ], 
  [ Z(43)^0, Z(43)^9, Z(43)^34 ], [ Z(43)^0, Z(43)^3, Z(43)^4 ], 
  [ Z(43)^3, Z(43)^22, Z(43)^6 ], [ Z(43)^3, Z(43)^16, Z(43)^18 ],
  [ Z(43)^3, Z(43)^10, Z(43)^30 ], [ Z(43)^3, Z(43)^4, Z(43)^0 ], 
  [ Z(43)^3, Z(43)^40, Z(43)^12 ], [ Z(43)^3, Z(43)^34, Z(43)^24 ], 
  [ Z(43)^3, Z(43)^28, Z(43)^36 ], [ Z(43)^4, Z(43)^30, Z(43)^27 ],
  [ Z(43)^4, Z(43)^24, Z(43)^39 ], [ Z(43)^4, Z(43)^18, Z(43)^9 ], 
  [ Z(43)^4, Z(43)^12, Z(43)^21 ], [ Z(43)^4, Z(43)^6, Z(43)^33 ], 
  [ Z(43)^4, Z(43)^0, Z(43)^3 ], [ Z(43)^4, Z(43)^36, Z(43)^15 ] ]
  !gapprompt@gap>| !gapinput@Length(O);|
  24
  
\end{Verbatim}
 Informally, a \emph{divisor} \index{divisor} on a curve is a formal integer linear combination of points on the curve, $D=m_1P_1+...+m_kP_k$, where the $m_i$ are integers (the ``multiplicity'' of $P_i$ in $D$) and $P_i$ are ($F$-rational) points on the affine plane curve. In other words, a divisor is an
element of the free abelian group generated by the $F$-rational affine points on the curve. The \emph{support} \index{support} of a divisor $D$ is simply the set of points which occurs in the sum defining $D$ with non-zero ``multiplicity''. The data structure for a divisor on an affine
plane curve is a record having the following components: 
\begin{itemize}
\item  the coefficients (the integer weights of the points in the support), 
\item  the support, 
\item  the curve, itself a record which has components: polynomial and polynomial
ring. 
\end{itemize}
 

 

 

\subsection{\textcolor{Chapter }{DivisorOnAffineCurve}}
\logpage{[ 5, 7, 5 ]}\nobreak
\hyperdef{L}{X79742B7183051D99}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorOnAffineCurve({\mdseries\slshape cdiv, sdiv, crv})\index{DivisorOnAffineCurve@\texttt{DivisorOnAffineCurve}}
\label{DivisorOnAffineCurve}
}\hfill{\scriptsize (function)}}\\


 This is the command you use to define a divisor in \textsf{GUAVA}. Of course, \mbox{\texttt{\mdseries\slshape crv}} is the curve on which the divisor lives, \mbox{\texttt{\mdseries\slshape cdiv}} is the list of coefficients (or ``multiplicities''), \mbox{\texttt{\mdseries\slshape sdiv}} is the list of points on \mbox{\texttt{\mdseries\slshape crv}} in the support. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@q:=5;|
  5
  !gapprompt@gap>| !gapinput@F:=GF(q);|
  GF(5)
  !gapprompt@gap>| !gapinput@R:=PolynomialRing(F,2);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R);|
  [ x_1, x_2 ]
  !gapprompt@gap>| !gapinput@x:=vars[1];|
  x_1
  !gapprompt@gap>| !gapinput@y:=vars[2];|
  x_2
  !gapprompt@gap>| !gapinput@crv:=AffineCurve(y^3-x^3-x-1,R);|
  rec( ring := PolynomialRing(..., [ x_1, x_2 ]), 
       polynomial := -x_1^3+x_2^3-x_1-Z(5)^0 )
  !gapprompt@gap>| !gapinput@Pts:=AffinePointsOnCurve(crv,R,F);;|
  !gapprompt@gap>| !gapinput@supp:=[Pts[1],Pts[2]];|
  [ [ 0*Z(5), Z(5)^0 ], [ Z(5)^0, Z(5) ] ]
  !gapprompt@gap>| !gapinput@D:=DivisorOnAffineCurve([1,-1],supp,crv);|
  rec( coeffs := [ 1, -1 ], 
       support := [ [ 0*Z(5), Z(5)^0 ], [ Z(5)^0, Z(5) ] ],
       curve := rec( ring := PolynomialRing(..., [ x_1, x_2 ]), 
                     polynomial := -x_1^3+x_2^3-x_1-Z(5)^0 ) )
  
\end{Verbatim}
  }

 

\subsection{\textcolor{Chapter }{DivisorAddition }}
\logpage{[ 5, 7, 6 ]}\nobreak
\hyperdef{L}{X8626E2B57D01F2DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorAddition ({\mdseries\slshape D1, D2})\index{DivisorAddition @\texttt{DivisorAddition }}
\label{DivisorAddition }
}\hfill{\scriptsize (function)}}\\


 If $D_1=m_1P_1+...+m_kP_k$ and $D_2=n_1P_1+...+n_kP_k$ are divisors then $D_1+D_2=(m_1+n_1)P_1+...+(m_k+n_k)P_k$. }

 

\subsection{\textcolor{Chapter }{DivisorDegree }}
\logpage{[ 5, 7, 7 ]}\nobreak
\hyperdef{L}{X865FE28D828C1EAD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorDegree ({\mdseries\slshape D})\index{DivisorDegree @\texttt{DivisorDegree }}
\label{DivisorDegree }
}\hfill{\scriptsize (function)}}\\


 If $D=m_1P_1+...+m_kP_k$ is a divisor then the \emph{degree} \index{degree} is $m_1+...+m_k$. }

 

\subsection{\textcolor{Chapter }{DivisorNegate }}
\logpage{[ 5, 7, 8 ]}\nobreak
\hyperdef{L}{X789DC358819A8F54}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorNegate ({\mdseries\slshape D})\index{DivisorNegate @\texttt{DivisorNegate }}
\label{DivisorNegate }
}\hfill{\scriptsize (function)}}\\


 Self-explanatory. }

 

\subsection{\textcolor{Chapter }{DivisorIsZero }}
\logpage{[ 5, 7, 9 ]}\nobreak
\hyperdef{L}{X8688C0E187B5C7DB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorIsZero ({\mdseries\slshape D})\index{DivisorIsZero @\texttt{DivisorIsZero }}
\label{DivisorIsZero }
}\hfill{\scriptsize (function)}}\\


 Self-explanatory. }

 

\subsection{\textcolor{Chapter }{DivisorsEqual }}
\logpage{[ 5, 7, 10 ]}\nobreak
\hyperdef{L}{X816A07997D9A7075}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorsEqual ({\mdseries\slshape D1, D2})\index{DivisorsEqual @\texttt{DivisorsEqual }}
\label{DivisorsEqual }
}\hfill{\scriptsize (function)}}\\


 Self-explanatory. }

 

\subsection{\textcolor{Chapter }{DivisorGCD }}
\logpage{[ 5, 7, 11 ]}\nobreak
\hyperdef{L}{X857B89847A649A26}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorGCD ({\mdseries\slshape D1, D2})\index{DivisorGCD @\texttt{DivisorGCD }}
\label{DivisorGCD }
}\hfill{\scriptsize (function)}}\\


 If $m=p_1^{e_1}...p_k^{e_k}$ and $n=p_1^{f_1}...p_k^{f_k}$ are two integers then their greatest common divisor is $GCD(m,n)=p_1^{min(e_1,f_1)}...p_k^{min(e_k,f_k)}$. A similar definition works for two divisors on a curve. If $D_1=e_1P_1+...+e_kP_k$ and $D_2n=f_1P_1+...+f_kP_k$ are two divisors on a curve then their \emph{greatest common divisor} \index{greatest common divisor} is $GCD(m,n)=min(e_1,f_1)P_1+...+min(e_k,f_k)P_k$. This function computes this quantity. }

 

\subsection{\textcolor{Chapter }{DivisorLCM }}
\logpage{[ 5, 7, 12 ]}\nobreak
\hyperdef{L}{X82231CF08073695F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorLCM ({\mdseries\slshape D1, D2})\index{DivisorLCM @\texttt{DivisorLCM }}
\label{DivisorLCM }
}\hfill{\scriptsize (function)}}\\


 If $m=p_1^{e_1}...p_k^{e_k}$ and $n=p_1^{f_1}...p_k^{f_k}$ are two integers then their least common multiple is $LCM(m,n)=p_1^{max(e_1,f_1)}...p_k^{max(e_k,f_k)}$. A similar definition works for two divisors on a curve. If $D_1=e_1P_1+...+e_kP_k$ and $D_2=f_1P_1+...+f_kP_k$ are two divisors on a curve then their \emph{least common multiple} \index{least common multiple} is $LCM(m,n)=max(e_1,f_1)P_1+...+max(e_k,f_k)P_k$. This function computes this quantity. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@b:=X(F,"b",var1);|
  b
  !gapprompt@gap>| !gapinput@var2:=Concatenation(var1,[b]);|
  [ a, b ]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,var2);|
  PolynomialRing(..., [ a, b ])
  !gapprompt@gap>| !gapinput@crvP1:=AffineCurve(b,R2);|
  rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b )
  !gapprompt@gap>| !gapinput@div1:=DivisorOnAffineCurve([1,2,3,4],[Z(11)^2,Z(11)^3,Z(11)^7,Z(11)],crvP1);|
  rec( coeffs := [ 1, 2, 3, 4 ], 
       support := [ Z(11)^2, Z(11)^3, Z(11)^7, Z(11) ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@DivisorDegree(div1);|
  10
  !gapprompt@gap>| !gapinput@div2:=DivisorOnAffineCurve([1,2,3,4],[Z(11),Z(11)^2,Z(11)^3,Z(11)^4],crvP1);|
  rec( coeffs := [ 1, 2, 3, 4 ], 
       support := [ Z(11), Z(11)^2, Z(11)^3, Z(11)^4 ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@DivisorDegree(div2);|
  10
  !gapprompt@gap>| !gapinput@div3:=DivisorAddition(div1,div2);|
  rec( coeffs := [ 5, 3, 5, 4, 3 ], 
       support := [ Z(11), Z(11)^2, Z(11)^3, Z(11)^4, Z(11)^7 ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@DivisorDegree(div3);|
  20
  !gapprompt@gap>| !gapinput@DivisorIsEffective(div1);|
  true
  !gapprompt@gap>| !gapinput@DivisorIsEffective(div2);|
  true
  gap>
  !gapprompt@gap>| !gapinput@ndiv1:=DivisorNegate(div1);|
  rec( coeffs := [ -1, -2, -3, -4 ], 
       support := [ Z(11)^2, Z(11)^3, Z(11)^7, Z(11) ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@zdiv:=DivisorAddition(div1,ndiv1);|
  rec( coeffs := [ 0, 0, 0, 0 ], 
       support := [ Z(11), Z(11)^2, Z(11)^3, Z(11)^7 ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@DivisorIsZero(zdiv);|
  true
  !gapprompt@gap>| !gapinput@div_gcd:=DivisorGCD(div1,div2);|
  rec( coeffs := [ 1, 1, 2, 0, 0 ], 
       support := [ Z(11), Z(11)^2, Z(11)^3, Z(11)^4, Z(11)^7 ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@div_lcm:=DivisorLCM(div1,div2);|
  rec( coeffs := [ 4, 2, 3, 4, 3 ], 
       support := [ Z(11), Z(11)^2, Z(11)^3, Z(11)^4, Z(11)^7 ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@DivisorDegree(div_gcd);|
  4
  !gapprompt@gap>| !gapinput@DivisorDegree(div_lcm);|
  16
  !gapprompt@gap>| !gapinput@DivisorEqual(div3,DivisorAddition(div_gcd,div_lcm));|
  true
  
\end{Verbatim}
  }

 Let $G$ denote a finite subgroup of $PGL(2,F)$ and let $D$ denote a divisor on the projective line $\mathbb{P}^1(F)$. If $G$ leaves $D$ unchanged (it may permute the points in the support of $D$ but must preserve their sum in $D$) then the Riemann-Roch space $L(D)$ is a $G$-module. The commands in this section help explore the $G$-module structure of $L(D)$ in the case then the ground field $F$ is finite. 

 

\subsection{\textcolor{Chapter }{RiemannRochSpaceBasisFunctionP1 }}
\logpage{[ 5, 7, 13 ]}\nobreak
\hyperdef{L}{X79C878697F99A10F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RiemannRochSpaceBasisFunctionP1 ({\mdseries\slshape P, k, R2})\index{RiemannRochSpaceBasisFunctionP1 @\texttt{RiemannRochSpaceBasisFunctionP1 }}
\label{RiemannRochSpaceBasisFunctionP1 }
}\hfill{\scriptsize (function)}}\\


 Input: \mbox{\texttt{\mdseries\slshape R2}} is a polynomial ring in two variables, say $F[x,y]$; \mbox{\texttt{\mdseries\slshape P}} is an element of the base field, say $F$; \mbox{\texttt{\mdseries\slshape k}} is an integer. Output: $1/(x-P)^k$ }

 

\subsection{\textcolor{Chapter }{DivisorOfRationalFunctionP1 }}
\logpage{[ 5, 7, 14 ]}\nobreak
\hyperdef{L}{X856DDA207EDDF256}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorOfRationalFunctionP1 ({\mdseries\slshape f, R})\index{DivisorOfRationalFunctionP1 @\texttt{DivisorOfRationalFunctionP1 }}
\label{DivisorOfRationalFunctionP1 }
}\hfill{\scriptsize (function)}}\\


 Here $R = F[x,y]$ is a polynomial ring in the variables $x,y$ and $f$ is a rational function of $x$. Simply returns the principal divisor on ${\mathbb{P}}^1$ associated to $f$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@b:=X(F,"b",var1);|
  b
  !gapprompt@gap>| !gapinput@var2:=Concatenation(var1,[b]);|
  [ a, b ]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,var2);|
  PolynomialRing(..., [ a, b ])
  !gapprompt@gap>| !gapinput@pt:=Z(11);|
  Z(11)
  !gapprompt@gap>| !gapinput@f:=RiemannRochSpaceBasisFunctionP1(pt,2,R2);|
  (Z(11)^0)/(a^2+Z(11)^7*a+Z(11)^2)
  !gapprompt@gap>| !gapinput@Df:=DivisorOfRationalFunctionP1(f,R2);|
  rec( coeffs := [ -2 ], support := [ Z(11) ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := a )
     )
  !gapprompt@gap>| !gapinput@Df.support;|
  [ Z(11) ]
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R:=PolynomialRing(F,2);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R);;|
  !gapprompt@gap>| !gapinput@a:=vars[1];;|
  !gapprompt@gap>| !gapinput@b:=vars[2];;|
  !gapprompt@gap>| !gapinput@f:=(a^4+Z(11)^6*a^3-a^2+Z(11)^7*a+Z(11)^0)/(a^4+Z(11)*a^2+Z(11)^7*a+Z(11));;|
  !gapprompt@gap>| !gapinput@divf:=DivisorOfRationalFunctionP1(f,R);|
  rec( coeffs := [ 3, 1 ], support := [ Z(11), Z(11)^7 ],
    curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := a ) )
  !gapprompt@gap>| !gapinput@denf:=DenominatorOfRationalFunction(f); RootsOfUPol(denf);|
  a^4+Z(11)*a^2+Z(11)^7*a+Z(11)
  [  ]
  !gapprompt@gap>| !gapinput@numf:=NumeratorOfRationalFunction(f); RootsOfUPol(numf);|
  a^4+Z(11)^6*a^3-a^2+Z(11)^7*a+Z(11)^0
  [ Z(11)^7, Z(11), Z(11), Z(11) ]
  
\end{Verbatim}
  }

 

\subsection{\textcolor{Chapter }{RiemannRochSpaceBasisP1 }}
\logpage{[ 5, 7, 15 ]}\nobreak
\hyperdef{L}{X878970A17E580224}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RiemannRochSpaceBasisP1 ({\mdseries\slshape D})\index{RiemannRochSpaceBasisP1 @\texttt{RiemannRochSpaceBasisP1 }}
\label{RiemannRochSpaceBasisP1 }
}\hfill{\scriptsize (function)}}\\


 This returns the basis of the Riemann-Roch space $L(D)$ associated to the divisor \mbox{\texttt{\mdseries\slshape D}} on the projective line ${\mathbb{P}}^1$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@b:=X(F,"b",var1);|
  b
  !gapprompt@gap>| !gapinput@var2:=Concatenation(var1,[b]);|
  [ a, b ]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,var2);|
  PolynomialRing(..., [ a, b ])
  !gapprompt@gap>| !gapinput@crvP1:=AffineCurve(b,R2);|
  rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b )
  !gapprompt@gap>| !gapinput@D:=DivisorOnAffineCurve([1,2,3,4],[Z(11)^2,Z(11)^3,Z(11)^7,Z(11)],crvP1);|
  rec( coeffs := [ 1, 2, 3, 4 ], 
       support := [ Z(11)^2, Z(11)^3, Z(11)^7, Z(11) ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@B:=RiemannRochSpaceBasisP1(D);|
  [ Z(11)^0, (Z(11)^0)/(a+Z(11)^7), (Z(11)^0)/(a+Z(11)^8), 
  (Z(11)^0)/(a^2+Z(11)^9*a+Z(11)^6), (Z(11)^0)/(a+Z(11)^2), 
  (Z(11)^0)/(a^2+Z(11)^3*a+Z(11)^4), (Z(11)^0)/(a^3+a^2+Z(11)^2*a+Z(11)^6),
    (Z(11)^0)/(a+Z(11)^6), (Z(11)^0)/(a^2+Z(11)^7*a+Z(11)^2), 
  (Z(11)^0)/(a^3+Z(11)^4*a^2+a+Z(11)^8), 
  (Z(11)^0)/(a^4+Z(11)^8*a^3+Z(11)*a^2+a+Z(11)^4) ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[1],R2).support;|
  [  ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[2],R2).support;|
  [ Z(11)^2 ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[3],R2).support;|
  [ Z(11)^3 ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[4],R2).support;|
  [ Z(11)^3 ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[5],R2).support;|
  [ Z(11)^7 ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[6],R2).support;|
  [ Z(11)^7 ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[7],R2).support;|
  [ Z(11)^7 ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[8],R2).support;|
  [ Z(11) ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[9],R2).support;|
  [ Z(11) ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[10],R2).support;|
  [ Z(11) ]
  !gapprompt@gap>| !gapinput@DivisorOfRationalFunctionP1(B[11],R2).support;|
  [ Z(11) ]
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MoebiusTransformation }}
\logpage{[ 5, 7, 16 ]}\nobreak
\hyperdef{L}{X807C52E67A440DEB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MoebiusTransformation ({\mdseries\slshape A, R})\index{MoebiusTransformation @\texttt{MoebiusTransformation }}
\label{MoebiusTransformation }
}\hfill{\scriptsize (function)}}\\


 The arguments are a $2\times 2$ matrix $A$ with entries in a field $F$ and a polynomial ring \mbox{\texttt{\mdseries\slshape R}}of one variable, say $F[x]$. This function returns the linear fractional transformatio associated to \mbox{\texttt{\mdseries\slshape A}}. These transformations can be composed with each other using GAP's \texttt{Value} command. }

 

\subsection{\textcolor{Chapter }{ActionMoebiusTransformationOnFunction }}
\logpage{[ 5, 7, 17 ]}\nobreak
\hyperdef{L}{X85A0419580ED0391}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ActionMoebiusTransformationOnFunction ({\mdseries\slshape A, f, R2})\index{ActionMoebiusTransformationOnFunction @\texttt{Action}\-\texttt{Moebius}\-\texttt{Transformation}\-\texttt{On}\-\texttt{Function }}
\label{ActionMoebiusTransformationOnFunction }
}\hfill{\scriptsize (function)}}\\


 The arguments are a $2\times 2$ matrix $A$ with entries in a field $F$, a rational function \mbox{\texttt{\mdseries\slshape f}} of one variable, say in $F(x)$, and a polynomial ring \mbox{\texttt{\mdseries\slshape R2}}, say $F[x,y]$. This function simply returns the composition of the function \mbox{\texttt{\mdseries\slshape f}} with the M{\"o}bius transformation of \mbox{\texttt{\mdseries\slshape A}}. }

 

\subsection{\textcolor{Chapter }{ActionMoebiusTransformationOnDivisorP1 }}
\logpage{[ 5, 7, 18 ]}\nobreak
\hyperdef{L}{X7E48F9C67E7FB7B5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ActionMoebiusTransformationOnDivisorP1 ({\mdseries\slshape A, D})\index{ActionMoebiusTransformationOnDivisorP1 @\texttt{Action}\-\texttt{Moebius}\-\texttt{Transformation}\-\texttt{On}\-\texttt{DivisorP1 }}
\label{ActionMoebiusTransformationOnDivisorP1 }
}\hfill{\scriptsize (function)}}\\


 A M{\"o}bius transformation may be regarded as an automorphism of the
projective line $\mathbb{P}^1$. This function simply returns the image of the divisor \mbox{\texttt{\mdseries\slshape D}} under the M{\"o}bius transformation defined by \mbox{\texttt{\mdseries\slshape A}}, provided that \texttt{IsActionMoebiusTransformationOnDivisorDefinedP1(A,D)} returns true. }

 

\subsection{\textcolor{Chapter }{IsActionMoebiusTransformationOnDivisorDefinedP1 }}
\logpage{[ 5, 7, 19 ]}\nobreak
\hyperdef{L}{X79FD980E7B24DB9C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsActionMoebiusTransformationOnDivisorDefinedP1 ({\mdseries\slshape A, D})\index{IsActionMoebiusTransformationOnDivisorDefinedP1 @\texttt{IsAction}\-\texttt{Moebius}\-\texttt{Transformation}\-\texttt{On}\-\texttt{Divisor}\-\texttt{DefinedP1 }}
\label{IsActionMoebiusTransformationOnDivisorDefinedP1 }
}\hfill{\scriptsize (function)}}\\


 Returns true of none of the points in the support of the divisor \mbox{\texttt{\mdseries\slshape D}} is the pole of the M{\"o}bius transformation. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@b:=X(F,"b",var1);|
  b
  !gapprompt@gap>| !gapinput@var2:=Concatenation(var1,[b]);|
  [ a, b ]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,var2);|
  PolynomialRing(..., [ a, b ])
  !gapprompt@gap>| !gapinput@crvP1:=AffineCurve(b,R2);|
  rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b )
  !gapprompt@gap>| !gapinput@D:=DivisorOnAffineCurve([1,2,3,4],[Z(11)^2,Z(11)^3,Z(11)^7,Z(11)],crvP1);|
  rec( coeffs := [ 1, 2, 3, 4 ], 
       support := [ Z(11)^2, Z(11)^3, Z(11)^7, Z(11) ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@A:=Z(11)^0*[[1,2],[1,4]];|
  [ [ Z(11)^0, Z(11) ], [ Z(11)^0, Z(11)^2 ] ]
  !gapprompt@gap>| !gapinput@ActionMoebiusTransformationOnDivisorDefinedP1(A,D);|
  false
  !gapprompt@gap>| !gapinput@A:=Z(11)^0*[[1,2],[3,4]];|
  [ [ Z(11)^0, Z(11) ], [ Z(11)^8, Z(11)^2 ] ]
  !gapprompt@gap>| !gapinput@ActionMoebiusTransformationOnDivisorDefinedP1(A,D);|
  true
  !gapprompt@gap>| !gapinput@ActionMoebiusTransformationOnDivisorP1(A,D);|
  rec( coeffs := [ 1, 2, 3, 4 ], 
       support := [ Z(11)^5, Z(11)^6, Z(11)^8, Z(11)^7 ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@f:=MoebiusTransformation(A,R1);|
  (a+Z(11))/(Z(11)^8*a+Z(11)^2)
  !gapprompt@gap>| !gapinput@ActionMoebiusTransformationOnFunction(A,f,R1);|
  -Z(11)^0+Z(11)^3*a^-1
  
\end{Verbatim}
  }

 

\subsection{\textcolor{Chapter }{DivisorAutomorphismGroupP1 }}
\logpage{[ 5, 7, 20 ]}\nobreak
\hyperdef{L}{X823386037F450B0E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorAutomorphismGroupP1 ({\mdseries\slshape D})\index{DivisorAutomorphismGroupP1 @\texttt{DivisorAutomorphismGroupP1 }}
\label{DivisorAutomorphismGroupP1 }
}\hfill{\scriptsize (function)}}\\


 Input: A divisor \mbox{\texttt{\mdseries\slshape D}} on $\mathbb{P}^1(F)$, where $F$ is a finite field. Output: A subgroup $Aut(D)\subset Aut(\mathbb{P}^1)$ preserving \mbox{\texttt{\mdseries\slshape D}}. 

 Very slow. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@b:=X(F,"b",var1);|
  b
  !gapprompt@gap>| !gapinput@var2:=Concatenation(var1,[b]);|
  [ a, b ]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,var2);|
  PolynomialRing(..., [ a, b ])
  !gapprompt@gap>| !gapinput@crvP1:=AffineCurve(b,R2);|
  rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b )
  !gapprompt@gap>| !gapinput@D:=DivisorOnAffineCurve([1,2,3,4],[Z(11)^2,Z(11)^3,Z(11)^7,Z(11)],crvP1);|
  rec( coeffs := [ 1, 2, 3, 4 ], 
       support := [ Z(11)^2, Z(11)^3, Z(11)^7, Z(11) ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@agp:=DivisorAutomorphismGroupP1(D);; time;|
  7305
  !gapprompt@gap>| !gapinput@IdGroup(agp);|
  [ 10, 2 ]
  
\end{Verbatim}
  }

 

\subsection{\textcolor{Chapter }{MatrixRepresentationOnRiemannRochSpaceP1 }}
\logpage{[ 5, 7, 21 ]}\nobreak
\hyperdef{L}{X80EDF3D682E7EF3F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MatrixRepresentationOnRiemannRochSpaceP1 ({\mdseries\slshape g, D})\index{MatrixRepresentationOnRiemannRochSpaceP1 @\texttt{Matrix}\-\texttt{Representation}\-\texttt{On}\-\texttt{Riemann}\-\texttt{Roch}\-\texttt{SpaceP1 }}
\label{MatrixRepresentationOnRiemannRochSpaceP1 }
}\hfill{\scriptsize (function)}}\\


 Input: An element \mbox{\texttt{\mdseries\slshape g}} in $G$, a subgroup of $Aut(D)\subset Aut(\mathbb{P}^1)$, and a divisor \mbox{\texttt{\mdseries\slshape D}} on $\mathbb{P}^1(F)$, where $F$ is a finite field. Output: a $d\times d$ matrix, where $d = dim\, L(D)$, representing the action of \mbox{\texttt{\mdseries\slshape g}} on $L(D)$. 

 Note: \mbox{\texttt{\mdseries\slshape g}} sends $L(D)$ to $r\cdot L(D)$, where $r$ is a polynomial of degree $1$ depending on \mbox{\texttt{\mdseries\slshape g}} and \mbox{\texttt{\mdseries\slshape D}}. 

 Also very slow. 

 The GAP command \texttt{BrauerCharacterValue} can be used to ``lift'' the eigenvalues of this matrix to the complex numbers. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@b:=X(F,"b",var1);|
  b
  !gapprompt@gap>| !gapinput@var2:=Concatenation(var1,[b]);|
  [ a, b ]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,var2);|
  PolynomialRing(..., [ a, b ])
  !gapprompt@gap>| !gapinput@crvP1:=AffineCurve(b,R2);|
  rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b )
  !gapprompt@gap>| !gapinput@D:=DivisorOnAffineCurve([1,1,1,4],[Z(11)^2,Z(11)^3,Z(11)^7,Z(11)],crvP1);|
  rec( coeffs := [ 1, 1, 1, 4 ],  
       support := [ Z(11)^2, Z(11)^3, Z(11)^7, Z(11) ], 
       curve := rec( ring := PolynomialRing(..., [ a, b ]), polynomial := b ) )
  !gapprompt@gap>| !gapinput@agp:=DivisorAutomorphismGroupP1(D);; time;|
  7198
  !gapprompt@gap>| !gapinput@IdGroup(agp);|
  [ 20, 5 ]
  !gapprompt@gap>| !gapinput@g:=Random(agp);|
  [ [ Z(11)^4, Z(11)^9 ], [ Z(11)^0, Z(11)^9 ] ]
  !gapprompt@gap>| !gapinput@rho:=MatrixRepresentationOnRiemannRochSpaceP1(g,D);|
  [ [ Z(11)^0, 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11) ], 
  [ Z(11)^0, 0*Z(11), 0*Z(11), Z(11), 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11) ],
    [ Z(11)^7, 0*Z(11), Z(11)^5, 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11) ], 
  [ Z(11)^4, Z(11)^9, 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11), 0*Z(11) ],
    [ Z(11)^2, 0*Z(11), 0*Z(11), 0*Z(11), Z(11)^5, 0*Z(11), 0*Z(11), 0*Z(11) ], 
  [ Z(11)^4, 0*Z(11), 0*Z(11), 0*Z(11), Z(11)^8, Z(11)^0, 0*Z(11), 0*Z(11) ],
    [ Z(11)^6, 0*Z(11), 0*Z(11), 0*Z(11), Z(11)^7, Z(11)^0, Z(11)^5, 0*Z(11) ], 
  [ Z(11)^8, 0*Z(11), 0*Z(11), 0*Z(11), Z(11)^3, Z(11)^3, Z(11)^9, Z(11)^0 ] ]
  !gapprompt@gap>| !gapinput@Display(rho);|
    1  .  .  .  .  .  .  .
    1  .  .  2  .  .  .  .
    7  . 10  .  .  .  .  .
    5  6  .  .  .  .  .  .
    4  .  .  . 10  .  .  .
    5  .  .  .  3  1  .  .
    9  .  .  .  7  1 10  .
    3  .  .  .  8  8  6  1
  
\end{Verbatim}
 }

   

\subsection{\textcolor{Chapter }{GoppaCodeClassical}}
\logpage{[ 5, 7, 22 ]}\nobreak
\hyperdef{L}{X8777388C7885E335}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoppaCodeClassical({\mdseries\slshape div, pts})\index{GoppaCodeClassical@\texttt{GoppaCodeClassical}}
\label{GoppaCodeClassical}
}\hfill{\scriptsize (function)}}\\


 Input: A divisor \mbox{\texttt{\mdseries\slshape div}} on the projective line ${\mathbb{P}}^1(F)$ over a finite field $F$ and a list \mbox{\texttt{\mdseries\slshape pts}} of points $\{P_1,...,P_n\}\subset F$ disjoint from the support of \mbox{\texttt{\mdseries\slshape div}}. \\
 Output: The classical (evaluation) Goppa code associated to this data. This is
the code 
\[ C=\{(f(P_1),...,f(P_n))\ |\ f\in L(D)_F\}. \]
 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,2);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R2);;|
  !gapprompt@gap>| !gapinput@a:=vars[1];;b:=vars[2];;|
  !gapprompt@gap>| !gapinput@cdiv:=[ 1, 2, -1, -2 ];|
  [ 1, 2, -1, -2 ]
  !gapprompt@gap>| !gapinput@sdiv:=[ Z(11)^2, Z(11)^3, Z(11)^6, Z(11)^9 ];|
  [ Z(11)^2, Z(11)^3, Z(11)^6, Z(11)^9 ]
  !gapprompt@gap>| !gapinput@crv:=rec(polynomial:=b,ring:=R2);|
  rec( polynomial := x_2, ring := PolynomialRing(..., [ x_1, x_2 ]) )
  !gapprompt@gap>| !gapinput@div:=DivisorOnAffineCurve(cdiv,sdiv,crv);|
  rec( coeffs := [ 1, 2, -1, -2 ], support := [ Z(11)^2, Z(11)^3, Z(11)^6, Z(11)^9 ],
    curve := rec( polynomial := x_2, ring := PolynomialRing(..., [ x_1, x_2 ]) ) )
  !gapprompt@gap>| !gapinput@pts:=Difference(Elements(GF(11)),div.support);|
  [ 0*Z(11), Z(11)^0, Z(11), Z(11)^4, Z(11)^5, Z(11)^7, Z(11)^8 ]
  !gapprompt@gap>| !gapinput@C:=GoppaCodeClassical(div,pts);|
  a linear [7,2,1..6]4..5 code defined by generator matrix over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  6
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{EvaluationBivariateCode}}
\logpage{[ 5, 7, 23 ]}\nobreak
\hyperdef{L}{X8422A310854C09B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EvaluationBivariateCode({\mdseries\slshape pts, L, crv})\index{EvaluationBivariateCode@\texttt{EvaluationBivariateCode}}
\label{EvaluationBivariateCode}
}\hfill{\scriptsize (function)}}\\


 Input: \texttt{pts} is a set of affine points on \texttt{crv}, \texttt{L} is a list of rational functions on \texttt{crv}. \\
 Output: The evaluation code associated to the points in \texttt{pts} and functions in \texttt{L}, but specifically for affine plane curves and this function checks if points
are "bad" (if so removes them from the list \texttt{pts} automatically). A point is ``bad'' if either it does not lie on the set of
non-singular $F$-rational points (places of degree 1) on the curve. 

 Very similar to \texttt{EvaluationCode} (see \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction). }

 

\subsection{\textcolor{Chapter }{EvaluationBivariateCodeNC}}
\logpage{[ 5, 7, 24 ]}\nobreak
\hyperdef{L}{X7B6C2BED8319C811}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EvaluationBivariateCodeNC({\mdseries\slshape pts, L, crv})\index{EvaluationBivariateCodeNC@\texttt{EvaluationBivariateCodeNC}}
\label{EvaluationBivariateCodeNC}
}\hfill{\scriptsize (function)}}\\


 As in \texttt{EvaluationBivariateCode} but does not check if the points are ``bad''. 

 Input: \texttt{pts} is a set of affine points on \texttt{crv}, \texttt{L} is a list of rational functions on \texttt{crv}. \\
 Output: The evaluation code associated to the points in \texttt{pts} and functions in \texttt{L}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@q:=4;;|
  !gapprompt@gap>| !gapinput@F:=GF(q^2);;|
  !gapprompt@gap>| !gapinput@R:=PolynomialRing(F,2);;|
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R);;|
  !gapprompt@gap>| !gapinput@x:=vars[1];;|
  !gapprompt@gap>| !gapinput@y:=vars[2];;|
  !gapprompt@gap>| !gapinput@crv:=AffineCurve(y^q+y-x^(q+1),R);|
  rec( ring := PolynomialRing(..., [ x_1, x_2 ]), polynomial := x_1^5+x_2^4+x_2 )
  !gapprompt@gap>| !gapinput@L:=[ x^0, x, x^2*y^-1 ];|
  [ Z(2)^0, x_1, x_1^2/x_2 ]
  !gapprompt@gap>| !gapinput@Pts:=AffinePointsOnCurve(crv.polynomial,crv.ring,F);;|
  !gapprompt@gap>| !gapinput@C1:=EvaluationBivariateCode(Pts,L,crv); time;|
  
  
   Automatically removed the following 'bad' points (either a pole or not 
   on the curve):
  [ [ 0*Z(2), 0*Z(2) ] ]
  
  a linear [63,3,1..60]51..59  evaluation code over GF(16)
  52
  !gapprompt@gap>| !gapinput@P:=Difference(Pts,[[ 0*Z(2^4)^0, 0*Z(2)^0 ]]);;|
  !gapprompt@gap>| !gapinput@C2:=EvaluationBivariateCodeNC(P,L,crv); time;|
  a linear [63,3,1..60]51..59  evaluation code over GF(16)
  48
  !gapprompt@gap>| !gapinput@C3:=EvaluationCode(P,L,R); time;|
  a linear [63,3,1..56]51..59  evaluation code over GF(16)
  58
  !gapprompt@gap>| !gapinput@MinimumDistance(C1);|
  56
  !gapprompt@gap>| !gapinput@MinimumDistance(C2);|
  56
  !gapprompt@gap>| !gapinput@MinimumDistance(C3);|
  56
  gap>
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{OnePointAGCode}}
\logpage{[ 5, 7, 25 ]}\nobreak
\hyperdef{L}{X842E227E8785168E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OnePointAGCode({\mdseries\slshape f, P, m, R})\index{OnePointAGCode@\texttt{OnePointAGCode}}
\label{OnePointAGCode}
}\hfill{\scriptsize (function)}}\\


 Input: \mbox{\texttt{\mdseries\slshape f}} is a polynomial in R=F[x,y], where \mbox{\texttt{\mdseries\slshape F}} is a finite field, \mbox{\texttt{\mdseries\slshape m}} is a positive integer (the multiplicity of the `point at infinity' $\infty$ on the curve $f(x,y)=0$), \mbox{\texttt{\mdseries\slshape P}} is a list of $n$ points on the curve over $F$. \\
 Output: The $C$ which is the image of the evaluation map 
\[ Eval_P:L(m \cdot \infty)\rightarrow F^n, \]
 given by $f\longmapsto (f(p_1),...,f(p_n))$, where $p_i \in P$. Here $L(m \cdot \infty)$ denotes the Riemann-Roch space of the divisor $m \cdot \infty$ on the curve. This has a basis consisting of monomials $x^iy^j$, where $(i,j)$ range over a polygon depending on $m$ and $f(x,y)$. For more details on the Riemann-Roch space of the divisor $m \cdot \infty$ see Proposition III.10.5 in Stichtenoth \cite{St93}. 

 This command returns a "record" object \texttt{C} with several extra components (type \texttt{NamesOfComponents(C)} to see them all): \texttt{C!.points} (namely \mbox{\texttt{\mdseries\slshape P}}), \texttt{C!.multiplicity} (namely \mbox{\texttt{\mdseries\slshape m}}), \texttt{C!.curve} (namely \mbox{\texttt{\mdseries\slshape f}}) and \texttt{C!.ring} (namely \mbox{\texttt{\mdseries\slshape R}}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R := PolynomialRing(F,["x","y"]);|
  PolynomialRing(..., [ x, y ])
  !gapprompt@gap>| !gapinput@indets := IndeterminatesOfPolynomialRing(R);|
  [ x, y ]
  !gapprompt@gap>| !gapinput@x:=indets[1]; y:=indets[2];|
  x
  y
  !gapprompt@gap>| !gapinput@P:=AffinePointsOnCurve(y^2-x^11+x,R,F);;|
  !gapprompt@gap>| !gapinput@C:=OnePointAGCode(y^2-x^11+x,P,15,R);|
  a linear [11,8,1..0]2..3  one-point AG code over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  4
  !gapprompt@gap>| !gapinput@Pts:=List([1,2,4,6,7,8,9,10,11],i->P[i]);;|
  !gapprompt@gap>| !gapinput@C:=OnePointAGCode(y^2-x^11+x,PT,10,R);|
  a linear [9,6,1..4]2..3 one-point AG code over GF(11)
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  4
\end{Verbatim}
  See \texttt{EvaluationCode} (\ref{EvaluationCode}) for a more general construction. }

 
\section{\textcolor{Chapter }{ Low-Density Parity-Check Codes }}\logpage{[ 5, 8, 0 ]}
\hyperdef{L}{X84F3673D7BBF5956}{}
{
  \label{LDPC} \index{LDPC} Low-density parity-check (LDPC) codes form a class of linear block codes whose
parity-check matrix--as the name implies, is sparse. LDPC codes were
introduced by Robert Gallager in 1962 \cite{Gallager.1962} as his PhD work. Due to the decoding complexity for the technology back then,
these codes were forgotten. Not until the late 1990s, these codes were
rediscovered and research results have shown that LDPC codes can achieve near
Shannon's capacity performance provided that their block length is long enough
and soft-decision iterative decoder is employed. Note that the bit-flipping
decoder (see \texttt{BitFlipDecoder}) is a hard-decision decoder and hence capacity achieving performance cannot
be achieved despite having a large block length. 

 Based on the structure of their parity-check matrix, LDPC codes may be
categorised into two classes: 
\begin{itemize}
\item  Regular LDPC codes 

 This class of codes has a fixed number of non zeros per column and per row in
their parity-check matrix. These codes are usually denoted as $(n,j,k)$ codes where $n$ is the block length, $j$ is the number of non zeros per column in their parity-check matrix and $k$ is the number of non zeros per row in their parity-check matrix. 
\item  Irregular LDPC codes 

 The irregular codes, on the other hand, do not have a fixed number of non
zeros per column and row in their parity-check matrix. This class of codes are
commonly represented by two polynomials which denote the distribution of the
number of non zeros in the columns and rows respectively of their parity-check
matrix. 
\end{itemize}
 

\subsection{\textcolor{Chapter }{QCLDPCCodeFromGroup}}
\logpage{[ 5, 8, 1 ]}\nobreak
\hyperdef{L}{X8020A9357AD0BA92}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{QCLDPCCodeFromGroup({\mdseries\slshape m, j, k})\index{QCLDPCCodeFromGroup@\texttt{QCLDPCCodeFromGroup}}
\label{QCLDPCCodeFromGroup}
}\hfill{\scriptsize (function)}}\\


 \texttt{QCLDCCodeFromGroup} produces an $(n,j,k)$ regular quasi-cyclic LDPC code over GF(2) of block length $n = mk$. The term quasi-cyclic in the context of LDPC codes typically refers to LDPC
codes whose parity-check matrix $H$ has the following form 
\begin{verbatim}  
      -                                              -
      |  I_P(0,0)  |  I_P(0,1)  | ... |  I_P(0,k-1)  |
      |  I_P(1,0)  |  I_P(1,1)  | ... |  I_P(1,k-1)  |
  H = |      .     |     .      |  .  |       .      |,
      |      .     |     .      |  .  |       .      |
      | I_P(j-1,0) | I_P(j-1,1) | ... | I_P(j-1,k-1) |
      -                                              -
  		
\end{verbatim}
 where $I_{P(s,t)}$ is an identity matrix of size $m \times m$ which has been shifted so that the $1$ on the first row starts at position $P(s,t)$. 

 Let $F$ be a multiplicative group of integers modulo $m$. If $m$ is a prime, $F=\{0,1,...,m-1\}$, otherwise $F$ contains a set of integers which are relatively prime to $m$. In both cases, the order of $F$ is equal to $\phi(m)$. Let $a$ and $b$ be non zeros of $F$ such that the orders of $a$ and $b$ are $k$ and $j$ respectively. Note that the integers $a$ and $b$ can always be found provided that $k$ and $j$ respectively divide $\phi(m)$. Having obtain integers $a$ and $b$, construct the following $j \times k$ matrix $P$ so that the element at row $s$ and column $t$ is given by $P(s,t) = a^tb^s$, i.e. 
\begin{verbatim}  
      -                                             -
      |    1    |     a    | . . . |      a^{k-1}   |
      |    b    |    ab    | . . . |     a^{k-1}b   |
  P = |    .    |    .     |   .   |        .       |.
      |    .    |    .     |   .   |        .       |
      | b^{j-1} | ab^{j-1} | . . . | a^{k-1}b^{j-1} |
      -                                             -
  		
\end{verbatim}
 The parity-check matrix $H$ of the LDPC code can be obtained by replacing each element of matrix $P$, i.e. $P(s,t)$, with an identity matrix $I_{P(s,t)}$ of size $m \times m$. 

 The code rate $R$ of the constructed code is given by 
\[ R \geq 1 - \frac{j}{k} \]
 where the sign $\geq$ is due to the possible existence of some non linearly independent rows in $H$. For more details, refer to the paper by Tanner et al \cite{TSSFC04}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := QCLDPCCodeFromGroup(7,2,3);|
  a linear [21,8,1..6]5..10 low-density parity-check code over GF(2)
  !gapprompt@gap>| !gapinput@MinimumWeight(C);|
  [21,8] linear code over GF(2) - minimum weight evaluation
  Known lower-bound: 1
  There are 3 generator matrices, ranks : 8 8 5 
  The weight of the minimum weight codeword satisfies 0 mod 2 congruence
  Enumerating codewords with information weight 1 (w=1)
      Found new minimum weight 6
  Number of matrices required for codeword enumeration 2
  Completed w= 1, 24 codewords enumerated, lower-bound 4, upper-bound 6
  Termination expected with information weight 2 at matrix 1
  -----------------------------------------------------------------------------
  Enumerating codewords with information weight 2 (w=2) using 1 matrices
  Completed w= 2, 28 codewords enumerated, lower-bound 6, upper-bound 6
  -----------------------------------------------------------------------------
  Minimum weight: 6
  6
  !gapprompt@gap>| !gapinput@# The quasi-cyclic structure is obvious from the check matrix|
  !gapprompt@gap>| !gapinput@Display( CheckMat(C) );|
   1 . . . . . . . 1 . . . . . . . . 1 . . .
   . 1 . . . . . . . 1 . . . . . . . . 1 . .
   . . 1 . . . . . . . 1 . . . . . . . . 1 .
   . . . 1 . . . . . . . 1 . . . . . . . . 1
   . . . . 1 . . . . . . . 1 . 1 . . . . . .
   . . . . . 1 . . . . . . . 1 . 1 . . . . .
   . . . . . . 1 1 . . . . . . . . 1 . . . .
   . . . . . 1 . . . . . 1 . . . . 1 . . . .
   . . . . . . 1 . . . . . 1 . . . . 1 . . .
   1 . . . . . . . . . . . . 1 . . . . 1 . .
   . 1 . . . . . 1 . . . . . . . . . . . 1 .
   . . 1 . . . . . 1 . . . . . . . . . . . 1
   . . . 1 . . . . . 1 . . . . 1 . . . . . .
   . . . . 1 . . . . . 1 . . . . 1 . . . . .
  !gapprompt@gap>| !gapinput@# This is the famous [155,64,20] quasi-cyclic LDPC codes|
  !gapprompt@gap>| !gapinput@C := QCLDPCCodeFromGroup(31,3,5);|
  a linear [155,64,1..24]24..77 low-density parity-check code over GF(2)
  !gapprompt@gap>| !gapinput@# An example using non prime m, it may take a while to construct this code|
  !gapprompt@gap>| !gapinput@C := QCLDPCCodeFromGroup(356,4,8);|
  a linear [2848,1436,1..120]312..1412 low-density parity-check code over GF(2)
\end{Verbatim}
  }

 }

 
\chapter{\textcolor{Chapter }{Manipulating Codes}}\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X866FC1117814B64D}{}
{
  \label{Manipulating Codes} In this chapter we describe several functions \textsf{GUAVA} uses to manipulate codes. Some of the best codes are obtained by starting with
for example a BCH code, and manipulating it. 

 In some cases, it is faster to perform calculations with a manipulated code
than to use the original code. For example, if the dimension of the code is
larger than half the word length, it is generally faster to compute the weight
distribution by first calculating the weight distribution of the dual code
than by directly calculating the weight distribution of the original code. The
size of the dual code is smaller in these cases. 

 Because \textsf{GUAVA} keeps all information in a code record, in some cases the information can be
preserved after manipulations. Therefore, computations do not always have to
start from scratch. 

 In Section \ref{Functions that Generate a New Code from a Given Code}, we describe functions that take a code with certain parameters, modify it in
some way and return a different code (see \texttt{ExtendedCode} (\ref{ExtendedCode}), \texttt{PuncturedCode} (\ref{PuncturedCode}), \texttt{EvenWeightSubcode} (\ref{EvenWeightSubcode}), \texttt{PermutedCode} (\ref{PermutedCode}), \texttt{ExpurgatedCode} (\ref{ExpurgatedCode}), \texttt{AugmentedCode} (\ref{AugmentedCode}), \texttt{RemovedElementsCode} (\ref{RemovedElementsCode}), \texttt{AddedElementsCode} (\ref{AddedElementsCode}), \texttt{ShortenedCode} (\ref{ShortenedCode}), \texttt{LengthenedCode} (\ref{LengthenedCode}), \texttt{ResidueCode} (\ref{ResidueCode}), \texttt{ConstructionBCode} (\ref{ConstructionBCode}), \texttt{DualCode} (\ref{DualCode}), \texttt{ConversionFieldCode} (\ref{ConversionFieldCode}), \texttt{ConstantWeightSubcode} (\ref{ConstantWeightSubcode}), \texttt{StandardFormCode} (\ref{StandardFormCode}) and \texttt{CosetCode} (\ref{CosetCode})). In Section \ref{Functions that Generate a New Code from Two or More Given Codes}, we describe functions that generate a new code out of two codes (see \texttt{DirectSumCode} (\ref{DirectSumCode}), \texttt{UUVCode} (\ref{UUVCode}), \texttt{DirectProductCode} (\ref{DirectProductCode}), \texttt{IntersectionCode} (\ref{IntersectionCode}) and \texttt{UnionCode} (\ref{UnionCode})). 
\section{\textcolor{Chapter }{ Functions that Generate a New Code from a Given Code }}\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X8271A4697FDA97B2}{}
{
  \label{Functions that Generate a New Code from a Given Code} \index{Parity check} 

\subsection{\textcolor{Chapter }{ExtendedCode}}
\logpage{[ 6, 1, 1 ]}\nobreak
\hyperdef{L}{X794679BE7F9EB5C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtendedCode({\mdseries\slshape C[, i]})\index{ExtendedCode@\texttt{ExtendedCode}}
\label{ExtendedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExtendedCode} extends the code \mbox{\texttt{\mdseries\slshape C}} \mbox{\texttt{\mdseries\slshape i}} times and returns the result. \mbox{\texttt{\mdseries\slshape i}} is equal to $1$ by default. Extending is done by adding a parity check bit after the last
coordinate. The coordinates of all codewords now add up to zero. In the binary
case, each codeword has even weight. 

 The word length increases by \mbox{\texttt{\mdseries\slshape i}}. The size of the code remains the same. In the binary case, the minimum
distance increases by one if it was odd. In other cases, that is not always
true. 

 A cyclic code in general is no longer cyclic after extending. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := HammingCode( 3, GF(2) );|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@C2 := ExtendedCode( C1 );|
  a linear [8,4,4]2 extended code
  !gapprompt@gap>| !gapinput@IsEquivalent( C2, ReedMullerCode( 1, 3 ) );|
  true
  !gapprompt@gap>| !gapinput@List( AsSSortedList( C2 ), WeightCodeword );|
  [ 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8 ]
  !gapprompt@gap>| !gapinput@C3 := EvenWeightSubcode( C1 );|
  a linear [7,3,4]2..3 even weight subcode 
\end{Verbatim}
  To undo extending, call \texttt{PuncturedCode} (see \texttt{PuncturedCode} (\ref{PuncturedCode})). The function \texttt{EvenWeightSubcode} (see \texttt{EvenWeightSubcode} (\ref{EvenWeightSubcode})) also returns a related code with only even weights, but without changing its
word length. 

\subsection{\textcolor{Chapter }{PuncturedCode}}
\logpage{[ 6, 1, 2 ]}\nobreak
\hyperdef{L}{X7E6E4DDA79574FDB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PuncturedCode({\mdseries\slshape C})\index{PuncturedCode@\texttt{PuncturedCode}}
\label{PuncturedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PuncturedCode} punctures \mbox{\texttt{\mdseries\slshape C}} in the last column, and returns the result. Puncturing is done simply by
cutting off the last column from each codeword. This means the word length
decreases by one. The minimum distance in general also decrease by one. 

 This command can also be called with the syntax \texttt{PuncturedCode( C, L )}. In this case, \texttt{PuncturedCode} punctures \mbox{\texttt{\mdseries\slshape C}} in the columns specified by \mbox{\texttt{\mdseries\slshape L}}, a list of integers. All columns specified by \mbox{\texttt{\mdseries\slshape L}} are omitted from each codeword. If $l$ is the length of \mbox{\texttt{\mdseries\slshape L}} (so the number of removed columns), the word length decreases by $l$. The minimum distance can also decrease by $l$ or less. 

 Puncturing a cyclic code in general results in a non-cyclic code. If the code
is punctured in all the columns where a word of minimal weight is unequal to
zero, the dimension of the resulting code decreases. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := BCHCode( 15, 5, GF(2) );|
  a cyclic [15,7,5]3..5 BCH code, delta=5, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@C2 := PuncturedCode( C1 );|
  a linear [14,7,4]3..5 punctured code
  !gapprompt@gap>| !gapinput@ExtendedCode( C2 ) = C1;|
  false
  !gapprompt@gap>| !gapinput@PuncturedCode( C1, [1,2,3,4,5,6,7] );|
  a linear [8,7,1]1 punctured code
  !gapprompt@gap>| !gapinput@PuncturedCode( WholeSpaceCode( 4, GF(5) ) );|
  a linear [3,3,1]0 punctured code  # The dimension decreased from 4 to 3 
\end{Verbatim}
  \texttt{ExtendedCode} extends the code again (see \texttt{ExtendedCode} (\ref{ExtendedCode})), although in general this does not result in the old code. 

\subsection{\textcolor{Chapter }{EvenWeightSubcode}}
\logpage{[ 6, 1, 3 ]}\nobreak
\hyperdef{L}{X87691AB67FF5621B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EvenWeightSubcode({\mdseries\slshape C})\index{EvenWeightSubcode@\texttt{EvenWeightSubcode}}
\label{EvenWeightSubcode}
}\hfill{\scriptsize (function)}}\\


 \texttt{EvenWeightSubcode} returns the even weight subcode of \mbox{\texttt{\mdseries\slshape C}}, consisting of all codewords of \mbox{\texttt{\mdseries\slshape C}} with even weight. If \mbox{\texttt{\mdseries\slshape C}} is a linear code and contains words of odd weight, the resulting code has a
dimension of one less. The minimum distance always increases with one if it
was odd. If \mbox{\texttt{\mdseries\slshape C}} is a binary cyclic code, and $g(x)$ is its generator polynomial, the even weight subcode either has generator
polynomial $g(x)$ (if $g(x)$ is divisible by $x-1$) or $g(x)\cdot (x-1)$ (if no factor $x-1$ was present in $g(x)$). So the even weight subcode is again cyclic. 

 Of course, if all codewords of \mbox{\texttt{\mdseries\slshape C}} are already of even weight, the returned code is equal to \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := EvenWeightSubcode( BCHCode( 8, 4, GF(3) ) );|
  an (8,33,4..8)3..8 even weight subcode
  !gapprompt@gap>| !gapinput@List( AsSSortedList( C1 ), WeightCodeword );|
  [ 0, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 4, 4, 8, 6, 4, 6, 8, 4, 4, 
    4, 6, 4, 6, 8, 4, 6, 8 ]
  !gapprompt@gap>| !gapinput@EvenWeightSubcode( ReedMullerCode( 1, 3 ) );|
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 
\end{Verbatim}
  \texttt{ExtendedCode} also returns a related code of only even weights, but without reducing its
dimension (see \texttt{ExtendedCode} (\ref{ExtendedCode})). 

\subsection{\textcolor{Chapter }{PermutedCode}}
\logpage{[ 6, 1, 4 ]}\nobreak
\hyperdef{L}{X79577EB27BE8524B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PermutedCode({\mdseries\slshape C, L})\index{PermutedCode@\texttt{PermutedCode}}
\label{PermutedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutedCode} returns \mbox{\texttt{\mdseries\slshape C}} after column permutations. \mbox{\texttt{\mdseries\slshape L}} (in GAP disjoint cycle notation) is the permutation to be executed on the
columns of \mbox{\texttt{\mdseries\slshape C}}. If \mbox{\texttt{\mdseries\slshape C}} is cyclic, the result in general is no longer cyclic. If a permutation results
in the same code as \mbox{\texttt{\mdseries\slshape C}}, this permutation belongs to the automorphism group of \mbox{\texttt{\mdseries\slshape C}} (see \texttt{AutomorphismGroup} (\ref{AutomorphismGroup})). In any case, the returned code is equivalent to \mbox{\texttt{\mdseries\slshape C}} (see \texttt{IsEquivalent} (\ref{IsEquivalent})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := PuncturedCode( ReedMullerCode( 1, 4 ) );|
  a linear [15,5,7]5 punctured code
  !gapprompt@gap>| !gapinput@C2 := BCHCode( 15, 7, GF(2) );|
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@C2 = C1;|
  false
  !gapprompt@gap>| !gapinput@p := CodeIsomorphism( C1, C2 );|
  ( 2, 4,14, 9,13, 7,11,10, 6, 8,12, 5)
  !gapprompt@gap>| !gapinput@C3 := PermutedCode( C1, p );|
  a linear [15,5,7]5 permuted code
  !gapprompt@gap>| !gapinput@C2 = C3;|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExpurgatedCode}}
\logpage{[ 6, 1, 5 ]}\nobreak
\hyperdef{L}{X87E5849784BC60D2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExpurgatedCode({\mdseries\slshape C, L})\index{ExpurgatedCode@\texttt{ExpurgatedCode}}
\label{ExpurgatedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExpurgatedCode} expurgates the code \mbox{\texttt{\mdseries\slshape C}}{\textgreater} by throwing away codewords in list \mbox{\texttt{\mdseries\slshape L}}. \mbox{\texttt{\mdseries\slshape C}} must be a linear code. \mbox{\texttt{\mdseries\slshape L}} must be a list of codeword input. The generator matrix of the new code no
longer is a basis for the codewords specified by \mbox{\texttt{\mdseries\slshape L}}. Since the returned code is still linear, it is very likely that, besides the
words of \mbox{\texttt{\mdseries\slshape L}}, more codewords of \mbox{\texttt{\mdseries\slshape C}} are no longer in the new code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := HammingCode( 4 );; WeightDistribution( C1 );|
  [ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@L := Filtered( AsSSortedList(C1), i -> WeightCodeword(i) = 3 );;|
  !gapprompt@gap>| !gapinput@C2 := ExpurgatedCode( C1, L );|
  a linear [15,4,3..4]5..11 code, expurgated with 7 word(s)
  !gapprompt@gap>| !gapinput@WeightDistribution( C2 );|
  [ 1, 0, 0, 0, 14, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] 
\end{Verbatim}
  This function does not work on non-linear codes. For removing words from a
non-linear code, use \texttt{RemovedElementsCode} (see \texttt{RemovedElementsCode} (\ref{RemovedElementsCode})). For expurgating a code of all words of odd weight, use `EvenWeightSubcode'
(see \texttt{EvenWeightSubcode} (\ref{EvenWeightSubcode})). 

\subsection{\textcolor{Chapter }{AugmentedCode}}
\logpage{[ 6, 1, 6 ]}\nobreak
\hyperdef{L}{X8134BE2B8478BE8A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AugmentedCode({\mdseries\slshape C, L})\index{AugmentedCode@\texttt{AugmentedCode}}
\label{AugmentedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AugmentedCode} returns \mbox{\texttt{\mdseries\slshape C}} after augmenting. \mbox{\texttt{\mdseries\slshape C}} must be a linear code, \mbox{\texttt{\mdseries\slshape L}} must be a list of codeword inputs. The generator matrix of the new code is a
basis for the codewords specified by \mbox{\texttt{\mdseries\slshape L}} as well as the words that were already in code \mbox{\texttt{\mdseries\slshape C}}. Note that the new code in general will consist of more words than only the
codewords of \mbox{\texttt{\mdseries\slshape C}} and the words \mbox{\texttt{\mdseries\slshape L}}. The returned code is also a linear code. 

 This command can also be called with the syntax \texttt{AugmentedCode(C)}. When called without a list of codewords, \texttt{AugmentedCode} returns \mbox{\texttt{\mdseries\slshape C}} after adding the all-ones vector to the generator matrix. \mbox{\texttt{\mdseries\slshape C}} must be a linear code. If the all-ones vector was already in the code, nothing
happens and a copy of the argument is returned. If \mbox{\texttt{\mdseries\slshape C}} is a binary code which does not contain the all-ones vector, the complement of
all codewords is added. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C31 := ReedMullerCode( 1, 3 );|
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  !gapprompt@gap>| !gapinput@C32 := AugmentedCode(C31,["00000011","00000101","00010001"]);|
  a linear [8,7,1..2]1 code, augmented with 3 word(s)
  !gapprompt@gap>| !gapinput@C32 = ReedMullerCode( 2, 3 );|
  true 
  !gapprompt@gap>| !gapinput@C1 := CordaroWagnerCode(6);|
  a linear [6,2,4]2..3 Cordaro-Wagner code over GF(2)
  !gapprompt@gap>| !gapinput@Codeword( [0,0,1,1,1,1] ) in C1;|
  true
  !gapprompt@gap>| !gapinput@C2 := AugmentedCode( C1 );|
  a linear [6,3,1..2]2..3 code, augmented with 1 word(s)
  !gapprompt@gap>| !gapinput@Codeword( [1,1,0,0,0,0] ) in C2;|
  true
\end{Verbatim}
  The function \texttt{AddedElementsCode} adds elements to the codewords instead of adding them to the basis (see \texttt{AddedElementsCode} (\ref{AddedElementsCode})). 

\subsection{\textcolor{Chapter }{RemovedElementsCode}}
\logpage{[ 6, 1, 7 ]}\nobreak
\hyperdef{L}{X7B0A6E1F82686B43}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RemovedElementsCode({\mdseries\slshape C, L})\index{RemovedElementsCode@\texttt{RemovedElementsCode}}
\label{RemovedElementsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{RemovedElementsCode} returns code \mbox{\texttt{\mdseries\slshape C}} after removing a list of codewords \mbox{\texttt{\mdseries\slshape L}} from its elements. \mbox{\texttt{\mdseries\slshape L}} must be a list of codeword input. The result is an unrestricted code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := HammingCode( 4 );; WeightDistribution( C1 );|
  [ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@L := Filtered( AsSSortedList(C1), i -> WeightCodeword(i) = 3 );;|
  !gapprompt@gap>| !gapinput@C2 := RemovedElementsCode( C1, L );|
  a (15,2013,3..15)2..15 code with 35 word(s) removed
  !gapprompt@gap>| !gapinput@WeightDistribution( C2 );|
  [ 1, 0, 0, 0, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@MinimumDistance( C2 );|
  3        # C2 is not linear, so the minimum weight does not have to
           # be equal to the minimum distance 
\end{Verbatim}
  Adding elements to a code is done by the function \texttt{AddedElementsCode} (see \texttt{AddedElementsCode} (\ref{AddedElementsCode})). To remove codewords from the base of a linear code, use \texttt{ExpurgatedCode} (see \texttt{ExpurgatedCode} (\ref{ExpurgatedCode})). 

\subsection{\textcolor{Chapter }{AddedElementsCode}}
\logpage{[ 6, 1, 8 ]}\nobreak
\hyperdef{L}{X784E1255874FCA8A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddedElementsCode({\mdseries\slshape C, L})\index{AddedElementsCode@\texttt{AddedElementsCode}}
\label{AddedElementsCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AddedElementsCode} returns code \mbox{\texttt{\mdseries\slshape C}} after adding a list of codewords \mbox{\texttt{\mdseries\slshape L}} to its elements. \mbox{\texttt{\mdseries\slshape L}} must be a list of codeword input. The result is an unrestricted code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := NullCode( 6, GF(2) );|
  a cyclic [6,0,6]6 nullcode over GF(2)
  !gapprompt@gap>| !gapinput@C2 := AddedElementsCode( C1, [ "111111" ] );|
  a (6,2,1..6)3 code with 1 word(s) added
  !gapprompt@gap>| !gapinput@IsCyclicCode( C2 );|
  true
  !gapprompt@gap>| !gapinput@C3 := AddedElementsCode( C2, [ "101010", "010101" ] );|
  a (6,4,1..6)2 code with 2 word(s) added
  !gapprompt@gap>| !gapinput@IsCyclicCode( C3 );|
  true 
\end{Verbatim}
  To remove elements from a code, use \texttt{RemovedElementsCode} (see \texttt{RemovedElementsCode} (\ref{RemovedElementsCode})). To add elements to the base of a linear code, use \texttt{AugmentedCode} (see \texttt{AugmentedCode} (\ref{AugmentedCode})). 

\subsection{\textcolor{Chapter }{ShortenedCode}}
\logpage{[ 6, 1, 9 ]}\nobreak
\hyperdef{L}{X81CBEAFF7B9DE6EF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ShortenedCode({\mdseries\slshape C[, L]})\index{ShortenedCode@\texttt{ShortenedCode}}
\label{ShortenedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ShortenedCode( C )} returns the code \mbox{\texttt{\mdseries\slshape C}} shortened by taking a cross section. If \mbox{\texttt{\mdseries\slshape C}} is a linear code, this is done by removing all codewords that start with a
non-zero entry, after which the first column is cut off. If \mbox{\texttt{\mdseries\slshape C}} was a $[n,k,d]$ code, the shortened code generally is a $[n-1,k-1,d]$ code. It is possible that the dimension remains the same; it is also possible
that the minimum distance increases. 

 If \mbox{\texttt{\mdseries\slshape C}} is a non-linear code, \texttt{ShortenedCode} first checks which finite field element occurs most often in the first column
of the codewords. The codewords not starting with this element are removed
from the code, after which the first column is cut off. The resulting
shortened code has at least the same minimum distance as \mbox{\texttt{\mdseries\slshape C}}. 

 This command can also be called using the syntax \texttt{ShortenedCode(C,L)}. When called in this format, \texttt{ShortenedCode} repeats the shortening process on each of the columns specified by \mbox{\texttt{\mdseries\slshape L}}. \mbox{\texttt{\mdseries\slshape L}} therefore is a list of integers. The column numbers in \mbox{\texttt{\mdseries\slshape L}} are the numbers as they are before the shortening process. If \mbox{\texttt{\mdseries\slshape L}} has $l$ entries, the returned code has a word length of $l$ positions shorter than \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := HammingCode( 4 );|
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  !gapprompt@gap>| !gapinput@C2 := ShortenedCode( C1 );|
  a linear [14,10,3]2 shortened code
  !gapprompt@gap>| !gapinput@C3 := ElementsCode( ["1000", "1101", "0011" ], GF(2) );|
  a (4,3,1..4)2 user defined unrestricted code over GF(2)
  !gapprompt@gap>| !gapinput@MinimumDistance( C3 );|
  2
  !gapprompt@gap>| !gapinput@C4 := ShortenedCode( C3 );|
  a (3,2,2..3)1..2 shortened code
  !gapprompt@gap>| !gapinput@AsSSortedList( C4 );|
  [ [ 0 0 0 ], [ 1 0 1 ] ]
  !gapprompt@gap>| !gapinput@C5 := HammingCode( 5, GF(2) );|
  a linear [31,26,3]1 Hamming (5,2) code over GF(2)
  !gapprompt@gap>| !gapinput@C6 := ShortenedCode( C5, [ 1, 2, 3 ] );|
  a linear [28,23,3]2 shortened code
  !gapprompt@gap>| !gapinput@OptimalityLinearCode( C6 );|
  0
\end{Verbatim}
  The function \texttt{LengthenedCode} lengthens the code again (only for linear codes), see \texttt{LengthenedCode} (\ref{LengthenedCode}). In general, this is not exactly the inverse function. 

\subsection{\textcolor{Chapter }{LengthenedCode}}
\logpage{[ 6, 1, 10 ]}\nobreak
\hyperdef{L}{X7A5D5419846FC867}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LengthenedCode({\mdseries\slshape C[, i]})\index{LengthenedCode@\texttt{LengthenedCode}}
\label{LengthenedCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{LengthenedCode( C )} returns the code \mbox{\texttt{\mdseries\slshape C}} lengthened. \mbox{\texttt{\mdseries\slshape C}} must be a linear code. First, the all-ones vector is added to the generator
matrix (see \texttt{AugmentedCode} (\ref{AugmentedCode})). If the all-ones vector was already a codeword, nothing happens to the code.
Then, the code is extended \mbox{\texttt{\mdseries\slshape i}} times (see \texttt{ExtendedCode} (\ref{ExtendedCode})). \mbox{\texttt{\mdseries\slshape i}} is equal to $1$ by default. If \mbox{\texttt{\mdseries\slshape C}} was an $[n,k]$ code, the new code generally is a $[n+i,k+1]$ code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := CordaroWagnerCode( 5 );|
  a linear [5,2,3]2 Cordaro-Wagner code over GF(2)
  !gapprompt@gap>| !gapinput@C2 := LengthenedCode( C1 );|
  a linear [6,3,2]2..3 code, lengthened with 1 column(s) 
\end{Verbatim}
  \texttt{ShortenedCode}' shortens the code, see \texttt{ShortenedCode} (\ref{ShortenedCode}). In general, this is not exactly the inverse function. 

\subsection{\textcolor{Chapter }{SubCode}}
\logpage{[ 6, 1, 11 ]}\nobreak
\hyperdef{L}{X7982D699803ECD0F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubCode({\mdseries\slshape C[, s]})\index{SubCode@\texttt{SubCode}}
\label{SubCode}
}\hfill{\scriptsize (function)}}\\


 This function \texttt{SubCode} returns a subcode of \mbox{\texttt{\mdseries\slshape C}} by taking the first $k - s$ rows of the generator matrix of \mbox{\texttt{\mdseries\slshape C}}, where $k$ is the dimension of \mbox{\texttt{\mdseries\slshape C}}. The interger \mbox{\texttt{\mdseries\slshape s}} may be omitted and in this case it is assumed as 1. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := BCHCode(31,11);|
  a cyclic [31,11,11]7..11 BCH code, delta=11, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@S1:= SubCode(C);|
  a linear [31,10,11]7..13 subcode
  !gapprompt@gap>| !gapinput@WeightDistribution(S1);|
  [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 190, 0, 0, 272, 255, 0, 0, 120, 66,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@S2:= SubCode(C, 8);|
  a linear [31,3,11]14..20 subcode
  !gapprompt@gap>| !gapinput@History(S2);|
  [ "a linear [31,3,11]14..20 subcode of",
    "a cyclic [31,11,11]7..11 BCH code, delta=11, b=1 over GF(2)" ]
  !gapprompt@gap>| !gapinput@WeightDistribution(S2);|
  [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ResidueCode}}
\logpage{[ 6, 1, 12 ]}\nobreak
\hyperdef{L}{X809376187C1525AA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ResidueCode({\mdseries\slshape C[, c]})\index{ResidueCode@\texttt{ResidueCode}}
\label{ResidueCode}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{ResidueCode} takes a codeword \mbox{\texttt{\mdseries\slshape c}} of \mbox{\texttt{\mdseries\slshape C}} (if \mbox{\texttt{\mdseries\slshape c}} is omitted, a codeword of minimal weight is used). It removes this word and
all its linear combinations from the code and then punctures the code in the
coordinates where \mbox{\texttt{\mdseries\slshape c}} is unequal to zero. The resulting code is an $[n-w, k-1, d-\lfloor w*(q-1)/q \rfloor ]$ code. \mbox{\texttt{\mdseries\slshape C}} must be a linear code and \mbox{\texttt{\mdseries\slshape c}} must be non-zero. If \mbox{\texttt{\mdseries\slshape c}} is not in \mbox{\texttt{\mdseries\slshape }} then no change is made to \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := BCHCode( 15, 7 );|
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@C2 := ResidueCode( C1 );|
  a linear [8,4,4]2 residue code
  !gapprompt@gap>| !gapinput@c := Codeword( [ 0,0,0,1,0,0,1,1,0,1,0,1,1,1,1 ], C1);;|
  !gapprompt@gap>| !gapinput@C3 := ResidueCode( C1, c );|
  a linear [7,4,3]1 residue code 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ConstructionBCode}}
\logpage{[ 6, 1, 13 ]}\nobreak
\hyperdef{L}{X7E92DC9581F96594}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConstructionBCode({\mdseries\slshape C})\index{ConstructionBCode@\texttt{ConstructionBCode}}
\label{ConstructionBCode}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{ConstructionBCode} takes a binary linear code \mbox{\texttt{\mdseries\slshape C}} and calculates the minimum distance of the dual of \mbox{\texttt{\mdseries\slshape C}} (see \texttt{DualCode} (\ref{DualCode})). It then removes the columns of the parity check matrix of \mbox{\texttt{\mdseries\slshape C}} where a codeword of the dual code of minimal weight has coordinates unequal to
zero. The resulting matrix is a parity check matrix for an $[n-dd, k-dd+1, \geq d]$ code, where $dd$ is the minimum distance of the dual of \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := ReedMullerCode( 2, 5 );|
  a linear [32,16,8]6 Reed-Muller (2,5) code over GF(2)
  !gapprompt@gap>| !gapinput@C2 := ConstructionBCode( C1 );|
  a linear [24,9,8]5..10 Construction B (8 coordinates)
  !gapprompt@gap>| !gapinput@BoundsMinimumDistance( 24, 9, GF(2) );|
  rec( n := 24, k := 9, q := 2, references := rec(  ), 
    construction := [ [ Operation "UUVCode" ], 
        [ [ [ Operation "UUVCode" ], [ [ [ Operation "DualCode" ], 
                        [ [ [ Operation "RepetitionCode" ], [ 6, 2 ] ] ] ], 
                    [ [ Operation "CordaroWagnerCode" ], [ 6 ] ] ] ], 
            [ [ Operation "CordaroWagnerCode" ], [ 12 ] ] ] ], lowerBound := 8, 
    lowerBoundExplanation := [ "Lb(24,9)=8, u u+v construction of C1 and C2:", 
        "Lb(12,7)=4, u u+v construction of C1 and C2:", 
        "Lb(6,5)=2, dual of the repetition code", 
        "Lb(6,2)=4, Cordaro-Wagner code", "Lb(12,2)=8, Cordaro-Wagner code" ], 
    upperBound := 8, 
    upperBoundExplanation := [ "Ub(24,9)=8, otherwise construction B would 
                               contradict:", "Ub(18,4)=8, Griesmer bound" ] )
  # so C2 is optimal
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DualCode}}
\logpage{[ 6, 1, 14 ]}\nobreak
\hyperdef{L}{X799B12F085ACB609}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DualCode({\mdseries\slshape C})\index{DualCode@\texttt{DualCode}}
\label{DualCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DualCode} returns the dual code of \mbox{\texttt{\mdseries\slshape C}}. The dual code consists of all codewords that are orthogonal to the codewords
of \mbox{\texttt{\mdseries\slshape C}}. If \mbox{\texttt{\mdseries\slshape C}} is a linear code with generator matrix $G$, the dual code has parity check matrix $G$ (or if \mbox{\texttt{\mdseries\slshape C}} has parity check matrix $H$, the dual code has generator matrix $H$). So if \mbox{\texttt{\mdseries\slshape C}} is a linear $[n, k]$ code, the dual code of \mbox{\texttt{\mdseries\slshape C}} is a linear $[n, n-k]$ code. If \mbox{\texttt{\mdseries\slshape C}} is a cyclic code with generator polynomial $g(x)$, the dual code has the reciprocal polynomial of $g(x)$ as check polynomial. 

 The dual code is always a linear code, even if \mbox{\texttt{\mdseries\slshape C}} is non-linear. 

 If a code \mbox{\texttt{\mdseries\slshape C}} is equal to its dual code, it is called \emph{self-dual}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R := ReedMullerCode( 1, 3 );|
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  !gapprompt@gap>| !gapinput@RD := DualCode( R );|
  a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
  !gapprompt@gap>| !gapinput@R = RD;|
  true
  !gapprompt@gap>| !gapinput@N := WholeSpaceCode( 7, GF(4) );|
  a cyclic [7,7,1]0 whole space code over GF(4)
  !gapprompt@gap>| !gapinput@DualCode( N ) = NullCode( 7, GF(4) );|
  true 
\end{Verbatim}
  \index{self-dual} 

\subsection{\textcolor{Chapter }{ConversionFieldCode}}
\logpage{[ 6, 1, 15 ]}\nobreak
\hyperdef{L}{X81FE1F387DFCCB22}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConversionFieldCode({\mdseries\slshape C})\index{ConversionFieldCode@\texttt{ConversionFieldCode}}
\label{ConversionFieldCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ConversionFieldCode} returns the code obtained from \mbox{\texttt{\mdseries\slshape C}} after converting its field. If the field of \mbox{\texttt{\mdseries\slshape C}} is $GF(q^m)$, the returned code has field $GF(q)$. Each symbol of every codeword is replaced by a concatenation of $m$ symbols from $GF(q)$. If \mbox{\texttt{\mdseries\slshape C}} is an $(n, M, d_1)$ code, the returned code is a $(n\cdot m, M, d_2)$ code, where $d_2 > d_1$. 

 See also \texttt{HorizontalConversionFieldMat} (\ref{HorizontalConversionFieldMat}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R := RepetitionCode( 4, GF(4) );|
  a cyclic [4,1,4]3 repetition code over GF(4)
  !gapprompt@gap>| !gapinput@R2 := ConversionFieldCode( R );|
  a linear [8,2,4]3..4 code, converted to basefield GF(2)
  !gapprompt@gap>| !gapinput@Size( R ) = Size( R2 );|
  true
  !gapprompt@gap>| !gapinput@GeneratorMat( R );|
  [ [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ] ]
  !gapprompt@gap>| !gapinput@GeneratorMat( R2 );|
  [ [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ],
    [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ] ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{TraceCode}}
\logpage{[ 6, 1, 16 ]}\nobreak
\hyperdef{L}{X82D18907800FE3D9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TraceCode({\mdseries\slshape C})\index{TraceCode@\texttt{TraceCode}}
\label{TraceCode}
}\hfill{\scriptsize (function)}}\\


 Input: \mbox{\texttt{\mdseries\slshape C}} is a linear code defined over an extension $E$ of \mbox{\texttt{\mdseries\slshape F}} (\mbox{\texttt{\mdseries\slshape F}} is the ``base field'') 

 Output: The linear code generated by $Tr_{E/F}(c)$, for all $c \in C$. 

 \texttt{TraceCode} returns the image of the code \mbox{\texttt{\mdseries\slshape C}} under the trace map. If the field of \mbox{\texttt{\mdseries\slshape C}} is $GF(q^m)$, the returned code has field $GF(q)$. 

 Very slow. It does not seem to be easy to related the parameters of the trace
code to the original except in the ``Galois closed'' case. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,4,GF(4)); MinimumDistance(C);|
  a  [10,4,?] randomly generated code over GF(4)
  5
  !gapprompt@gap>| !gapinput@trC:=TraceCode(C,GF(2)); MinimumDistance(trC);|
  a linear [10,7,1]1..3 user defined unrestricted code over GF(2)
  1
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CosetCode}}
\logpage{[ 6, 1, 17 ]}\nobreak
\hyperdef{L}{X8799F4BF81B0842B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CosetCode({\mdseries\slshape C, w})\index{CosetCode@\texttt{CosetCode}}
\label{CosetCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{CosetCode} returns the coset of a code \mbox{\texttt{\mdseries\slshape C}} with respect to word \mbox{\texttt{\mdseries\slshape w}}. \mbox{\texttt{\mdseries\slshape w}} must be of the codeword type. Then, \mbox{\texttt{\mdseries\slshape w}} is added to each codeword of \mbox{\texttt{\mdseries\slshape C}}, yielding the elements of the new code. If \mbox{\texttt{\mdseries\slshape C}} is linear and \mbox{\texttt{\mdseries\slshape w}} is an element of \mbox{\texttt{\mdseries\slshape C}}, the new code is equal to \mbox{\texttt{\mdseries\slshape C}}, otherwise the new code is an unrestricted code. 

 Generating a coset is also possible by simply adding the word \mbox{\texttt{\mdseries\slshape w}} to \mbox{\texttt{\mdseries\slshape C}}. See \ref{Operations for Codes}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H := HammingCode(3, GF(2));|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@c := Codeword("1011011");; c in H;|
  false
  !gapprompt@gap>| !gapinput@C := CosetCode(H, c);|
  a (7,16,3)1 coset code
  !gapprompt@gap>| !gapinput@List(AsSSortedList(C), el-> Syndrome(H, el));|
  [ [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
    [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
    [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ] ]
  # All elements of the coset have the same syndrome in H 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ConstantWeightSubcode}}
\logpage{[ 6, 1, 18 ]}\nobreak
\hyperdef{L}{X873EA5EE85699832}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConstantWeightSubcode({\mdseries\slshape C, w})\index{ConstantWeightSubcode@\texttt{ConstantWeightSubcode}}
\label{ConstantWeightSubcode}
}\hfill{\scriptsize (function)}}\\


 \texttt{ConstantWeightSubcode} returns the subcode of \mbox{\texttt{\mdseries\slshape C}} that only has codewords of weight \mbox{\texttt{\mdseries\slshape w}}. The resulting code is a non-linear code, because it does not contain the
all-zero vector. 

 This command also can be called with the syntax \texttt{ConstantWeightSubcode(C)} In this format, \texttt{ConstantWeightSubcode} returns the subcode of \mbox{\texttt{\mdseries\slshape C}} consisting of all minimum weight codewords of \mbox{\texttt{\mdseries\slshape C}}. 

 \texttt{ConstantWeightSubcode} first checks if Leon's binary \texttt{wtdist} exists on your computer (in the default directory). If it does, then this
program is called. Otherwise, the constant weight subcode is computed using a
GAP program which checks each codeword in \mbox{\texttt{\mdseries\slshape C}} to see if it is of the desired weight. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@N := NordstromRobinsonCode();; WeightDistribution(N);|
  [ 1, 0, 0, 0, 0, 0, 112, 0, 30, 0, 112, 0, 0, 0, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@C := ConstantWeightSubcode(N, 8);|
  a (16,30,6..16)5..8 code with codewords of weight 8
  !gapprompt@gap>| !gapinput@WeightDistribution(C);|
  [ 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0 ] 
  !gapprompt@gap>| !gapinput@eg := ExtendedTernaryGolayCode();; WeightDistribution(eg);|
  [ 1, 0, 0, 0, 0, 0, 264, 0, 0, 440, 0, 0, 24 ]
  !gapprompt@gap>| !gapinput@C := ConstantWeightSubcode(eg);|
  a (12,264,6..12)3..6 code with codewords of weight 6
  !gapprompt@gap>| !gapinput@WeightDistribution(C);|
  [ 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 0, 0 ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{StandardFormCode}}
\logpage{[ 6, 1, 19 ]}\nobreak
\hyperdef{L}{X7AA203A380BC4C79}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StandardFormCode({\mdseries\slshape C})\index{StandardFormCode@\texttt{StandardFormCode}}
\label{StandardFormCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{StandardFormCode} returns \mbox{\texttt{\mdseries\slshape C}} after putting it in standard form. If \mbox{\texttt{\mdseries\slshape C}} is a non-linear code, this means the elements are organized using
lexicographical order. This means they form a legal GAP `Set'. 

 If \mbox{\texttt{\mdseries\slshape C}} is a linear code, the generator matrix and parity check matrix are put in
standard form. The generator matrix then has an identity matrix in its left
part, the parity check matrix has an identity matrix in its right part.
Although \textsf{GUAVA} always puts both matrices in a standard form using \texttt{BaseMat}, this never alters the code. \texttt{StandardFormCode} even applies column permutations if unavoidable, and thereby changes the code.
The column permutations are recorded in the construction history of the new
code (see \texttt{Display} (\ref{Display})). \mbox{\texttt{\mdseries\slshape C}} and the new code are of course equivalent. 

 If \mbox{\texttt{\mdseries\slshape C}} is a cyclic code, its generator matrix cannot be put in the usual upper
triangular form, because then it would be inconsistent with the generator
polynomial. The reason is that generating the elements from the generator
matrix would result in a different order than generating the elements from the
generator polynomial. This is an unwanted effect, and therefore \texttt{StandardFormCode} just returns a copy of \mbox{\texttt{\mdseries\slshape C}} for cyclic codes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := GeneratorMatCode( Z(2) * [ [0,1,1,0], [0,1,0,1], [0,0,1,1] ], |
            "random form code", GF(2) );
  a linear [4,2,1..2]1..2 random form code over GF(2)
  !gapprompt@gap>| !gapinput@Codeword( GeneratorMat( G ) );|
  [ [ 0 1 0 1 ], [ 0 0 1 1 ] ]
  !gapprompt@gap>| !gapinput@Codeword( GeneratorMat( StandardFormCode( G ) ) );|
  [ [ 1 0 0 1 ], [ 0 1 0 1 ] ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{PiecewiseConstantCode}}
\logpage{[ 6, 1, 20 ]}\nobreak
\hyperdef{L}{X7EF49A257D6DB53B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PiecewiseConstantCode({\mdseries\slshape part, wts[, F]})\index{PiecewiseConstantCode@\texttt{PiecewiseConstantCode}}
\label{PiecewiseConstantCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{PiecewiseConstantCode} returns a code with length $n = \sum n_i$, where \mbox{\texttt{\mdseries\slshape part}}=$[ n_1, \dots, n_k ]$. \mbox{\texttt{\mdseries\slshape wts}} is a list of \mbox{\texttt{\mdseries\slshape constraints}} $w=(w_1,...,w_k)$, each of length $k$, where $0 \leq w_i \leq n_i$. The default field is $GF(2)$. 

 A constraint is a list of integers, and a word $c = ( c_1, \dots, c_k )$ (according to \mbox{\texttt{\mdseries\slshape part}}, i.e., each $c_i$ is a subword of length $n_i$) is in the resulting code if and only if, for some constraint $w \in$ \mbox{\texttt{\mdseries\slshape wts}}, $\|c_i\| = w_i$ for all $1 \leq i \leq k$, where $\| ...\|$ denotes the Hamming weight. 

 An example might make things clearer: }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PiecewiseConstantCode( [ 2, 3 ],|
       [ [ 0, 0 ], [ 0, 3 ], [ 1, 0 ], [ 2, 2 ] ],GF(2) );
  the C code programs are compiled, so using Leon's binary....
  the C code programs are compiled, so using Leon's binary....
  the C code programs are compiled, so using Leon's binary....
  the C code programs are compiled, so using Leon's binary....
  a (5,7,1..5)1..5 piecewise constant code over GF(2)
  !gapprompt@gap>| !gapinput@AsSSortedList(last);|
  [ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 0 0 ], [ 1 0 0 0 0 ], 
    [ 1 1 0 1 1 ], [ 1 1 1 0 1 ], [ 1 1 1 1 0 ] ]
  gap>
  
\end{Verbatim}
  The first constraint is satisfied by codeword 1, the second by codeword 2, the
third by codewords 3 and 4, and the fourth by codewords 5, 6 and 7. }

 
\section{\textcolor{Chapter }{ Functions that Generate a New Code from Two or More Given Codes }}\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X7964BF0081CC8352}{}
{
  \label{Functions that Generate a New Code from Two or More Given Codes} 

\subsection{\textcolor{Chapter }{DirectSumCode}}
\logpage{[ 6, 2, 1 ]}\nobreak
\hyperdef{L}{X79E00D3A8367D65A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DirectSumCode({\mdseries\slshape C1, C2})\index{DirectSumCode@\texttt{DirectSumCode}}
\label{DirectSumCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DirectSumCode} returns the direct sum of codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. The direct sum code consists of every codeword of \mbox{\texttt{\mdseries\slshape C1}} concatenated by every codeword of \mbox{\texttt{\mdseries\slshape C2}}. Therefore, if \mbox{\texttt{\mdseries\slshape Ci}} was a $(n_i,M_i,d_i)$ code, the result is a $(n_1+n_2,M_1*M_2,min(d_1,d_2))$ code. 

 If both \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} are linear codes, the result is also a linear code. If one of them is
non-linear, the direct sum is non-linear too. In general, a direct sum code is
not cyclic. 

 Performing a direct sum can also be done by adding two codes (see Section \ref{Operations for Codes}). Another often used method is the `u, u+v'-construction, described in \texttt{UUVCode} (\ref{UUVCode}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := ElementsCode( [ [1,0], [4,5] ], GF(7) );;|
  !gapprompt@gap>| !gapinput@C2 := ElementsCode( [ [0,0,0], [3,3,3] ], GF(7) );;|
  !gapprompt@gap>| !gapinput@D := DirectSumCode(C1, C2);;|
  !gapprompt@gap>| !gapinput@AsSSortedList(D);|
  [ [ 1 0 0 0 0 ], [ 1 0 3 3 3 ], [ 4 5 0 0 0 ], [ 4 5 3 3 3 ] ]
  !gapprompt@gap>| !gapinput@D = C1 + C2;   # addition = direct sum|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UUVCode}}
\logpage{[ 6, 2, 2 ]}\nobreak
\hyperdef{L}{X86E9D6DE7F1A07E6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UUVCode({\mdseries\slshape C1, C2})\index{UUVCode@\texttt{UUVCode}}
\label{UUVCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{UUVCode} returns the so-called $(u\|u+v)$ construction applied to \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. The resulting code consists of every codeword $u$ of \mbox{\texttt{\mdseries\slshape C1}} concatenated by the sum of $u$ and every codeword $v$ of \mbox{\texttt{\mdseries\slshape C2}}. If \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} have different word lengths, sufficient zeros are added to the shorter code to
make this sum possible. If \mbox{\texttt{\mdseries\slshape Ci}} is a $(n_i,M_i,d_i)$ code, the result is an $(n_1+max(n_1,n_2),M_1\cdot M_2,min(2\cdot d_1,d_2))$ code. 

 If both \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} are linear codes, the result is also a linear code. If one of them is
non-linear, the UUV sum is non-linear too. In general, a UUV sum code is not
cyclic. 

 The function \texttt{DirectSumCode} returns another sum of codes (see \texttt{DirectSumCode} (\ref{DirectSumCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := EvenWeightSubcode(WholeSpaceCode(4, GF(2)));|
  a cyclic [4,3,2]1 even weight subcode
  !gapprompt@gap>| !gapinput@C2 := RepetitionCode(4, GF(2));|
  a cyclic [4,1,4]2 repetition code over GF(2)
  !gapprompt@gap>| !gapinput@R := UUVCode(C1, C2);|
  a linear [8,4,4]2 U U+V construction code
  !gapprompt@gap>| !gapinput@R = ReedMullerCode(1,3);|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DirectProductCode}}
\logpage{[ 6, 2, 3 ]}\nobreak
\hyperdef{L}{X7BFBBA5784C293C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DirectProductCode({\mdseries\slshape C1, C2})\index{DirectProductCode@\texttt{DirectProductCode}}
\label{DirectProductCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{DirectProductCode} returns the direct product of codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. Both must be linear codes. Suppose \mbox{\texttt{\mdseries\slshape Ci}} has generator matrix $G_i$. The direct product of \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} then has the Kronecker product of $G_1$ and $G_2$ as the generator matrix (see the GAP command \texttt{KroneckerProduct}). 

 If \mbox{\texttt{\mdseries\slshape Ci}} is a $[n_i, k_i, d_i]$ code, the direct product then is an $[n_1\cdot n_2,k_1\cdot k_2,d_1\cdot d_2]$ code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L1 := LexiCode(10, 4, GF(2));|
  a linear [10,5,4]2..4 lexicode over GF(2)
  !gapprompt@gap>| !gapinput@L2 := LexiCode(8, 3, GF(2));|
  a linear [8,4,3]2..3 lexicode over GF(2)
  !gapprompt@gap>| !gapinput@D := DirectProductCode(L1, L2);|
  a linear [80,20,12]20..45 direct product code 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{IntersectionCode}}
\logpage{[ 6, 2, 4 ]}\nobreak
\hyperdef{L}{X78F0B1BC81FB109C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IntersectionCode({\mdseries\slshape C1, C2})\index{IntersectionCode@\texttt{IntersectionCode}}
\label{IntersectionCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IntersectionCode} returns the intersection of codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. This code consists of all codewords that are both in \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. If both codes are linear, the result is also linear. If both are cyclic, the
result is also cyclic. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := CyclicCodes(7, GF(2));|
  [ a cyclic [7,7,1]0 enumerated code over GF(2),
    a cyclic [7,6,1..2]1 enumerated code over GF(2),
    a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
    a cyclic [7,0,7]7 enumerated code over GF(2),
    a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
    a cyclic [7,4,1..3]1 enumerated code over GF(2),
    a cyclic [7,1,7]3 enumerated code over GF(2),
    a cyclic [7,4,1..3]1 enumerated code over GF(2) ]
  !gapprompt@gap>| !gapinput@IntersectionCode(C[6], C[8]) = C[7];|
  true 
\end{Verbatim}
 \index{hull} The \emph{hull} of a linear code is the intersection of the code with its dual code. In other
words, the hull of $C$ is \texttt{IntersectionCode(C, DualCode(C))}. 

\subsection{\textcolor{Chapter }{UnionCode}}
\logpage{[ 6, 2, 5 ]}\nobreak
\hyperdef{L}{X8228A1F57A29B8F4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnionCode({\mdseries\slshape C1, C2})\index{UnionCode@\texttt{UnionCode}}
\label{UnionCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{UnionCode} returns the union of codes \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. This code consists of the union of all codewords of \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} and all linear combinations. Therefore this function works only for linear
codes. The function \texttt{AddedElementsCode} can be used for non-linear codes, or if the resulting code should not include
linear combinations. See \texttt{AddedElementsCode} (\ref{AddedElementsCode}). If both arguments are cyclic, the result is also cyclic. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := GeneratorMatCode([[1,0,1],[0,1,1]]*Z(2)^0, GF(2));|
  a linear [3,2,1..2]1 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@H := GeneratorMatCode([[1,1,1]]*Z(2)^0, GF(2));|
  a linear [3,1,3]1 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@U := UnionCode(G, H);|
  a linear [3,3,1]0 union code
  !gapprompt@gap>| !gapinput@c := Codeword("010");; c in G;|
  false
  !gapprompt@gap>| !gapinput@c in H;|
  false
  !gapprompt@gap>| !gapinput@c in U;|
  true 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExtendedDirectSumCode}}
\logpage{[ 6, 2, 6 ]}\nobreak
\hyperdef{L}{X7A85F8AF8154D387}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtendedDirectSumCode({\mdseries\slshape L, B, m})\index{ExtendedDirectSumCode@\texttt{ExtendedDirectSumCode}}
\label{ExtendedDirectSumCode}
}\hfill{\scriptsize (function)}}\\


 The extended direct sum construction is described in section V of Graham and
Sloane \cite{GS85}. The resulting code consists of \mbox{\texttt{\mdseries\slshape m}} copies of \mbox{\texttt{\mdseries\slshape L}}, extended by repeating the codewords of \mbox{\texttt{\mdseries\slshape B}} \mbox{\texttt{\mdseries\slshape m}} times. 

 Suppose \mbox{\texttt{\mdseries\slshape L}} is an $[n_L, k_L]r_L$ code, and \mbox{\texttt{\mdseries\slshape B}} is an $[n_L, k_B]r_B$ code (non-linear codes are also permitted). The length of \mbox{\texttt{\mdseries\slshape B}} must be equal to the length of \mbox{\texttt{\mdseries\slshape L}}. The length of the new code is $n = m n_L$, the dimension (in the case of linear codes) is $k \leq m k_L + k_B$, and the covering radius is $r \leq \lfloor m \Psi( L, B ) \rfloor$, with 
\[ \Psi( L, B ) = \max_{u \in F_2^{n_L}} \frac{1}{2^{k_B}} \sum_{v \in B} {\rm
d}( L, v + u ). \]
 However, this computation will not be executed, because it may be too time
consuming for large codes. 

 If $L \subseteq B$, and $L$ and $B$ are linear codes, the last copy of \mbox{\texttt{\mdseries\slshape L}} is omitted. In this case the dimension is $k = m k_L + (k_B - k_L)$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c := HammingCode( 3, GF(2) );|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@d := WholeSpaceCode( 7, GF(2) );|
  a cyclic [7,7,1]0 whole space code over GF(2)
  !gapprompt@gap>| !gapinput@e := ExtendedDirectSumCode( c, d, 3 );|
  a linear [21,15,1..3]2 3-fold extended direct sum code
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{AmalgamatedDirectSumCode}}
\logpage{[ 6, 2, 7 ]}\nobreak
\hyperdef{L}{X7E17107686A845DB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AmalgamatedDirectSumCode({\mdseries\slshape c1, c2[, check]})\index{AmalgamatedDirectSumCode@\texttt{AmalgamatedDirectSumCode}}
\label{AmalgamatedDirectSumCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{AmalgamatedDirectSumCode} returns the amalgamated direct sum of the codes \mbox{\texttt{\mdseries\slshape c1}} and \mbox{\texttt{\mdseries\slshape c2}}. The amalgamated direct sum code consists of all codewords of the form $(u \, \| \,0 \, \| \, v)$ if $(u \, \| \, 0) \in c_1$ and $(0 \, \| \, v) \in c_2$ and all codewords of the form $(u \, \| \, 1 \, \| \, v)$ if $(u \, \| \, 1) \in c_1$ and $(1 \, \| \, v) \in c_2$. The result is a code with length $ n = n_1 + n_2 - 1 $ and size $ M \leq M_1 \cdot M_2 / 2 $. 

 If both codes are linear, they will first be standardized, with information
symbols in the last and first coordinates of the first and second code,
respectively. 

 If \mbox{\texttt{\mdseries\slshape c1}} is a normal code (see \texttt{IsNormalCode} (\ref{IsNormalCode})) with the last coordinate acceptable (see \texttt{IsCoordinateAcceptable} (\ref{IsCoordinateAcceptable})), and \mbox{\texttt{\mdseries\slshape c2}} is a normal code with the first coordinate acceptable, then the covering
radius of the new code is $r \leq r_1 + r_2 $. However, checking whether a code is normal or not is a lot of work, and
almost all codes seem to be normal. Therefore, an option \mbox{\texttt{\mdseries\slshape check}} can be supplied. If \mbox{\texttt{\mdseries\slshape check}} is true, then the codes will be checked for normality. If \mbox{\texttt{\mdseries\slshape check}} is false or omitted, then the codes will not be checked. In this case it is
assumed that they are normal. Acceptability of the last and first coordinate
of the first and second code, respectively, is in the last case also assumed
to be done by the user. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c := HammingCode( 3, GF(2) );|
  a linear [7,4,3]1 Hamming (3,2) code over GF(2)
  !gapprompt@gap>| !gapinput@d := ReedMullerCode( 1, 4 );|
  a linear [16,5,8]6 Reed-Muller (1,4) code over GF(2)
  !gapprompt@gap>| !gapinput@e := DirectSumCode( c, d );|
  a linear [23,9,3]7 direct sum code
  !gapprompt@gap>| !gapinput@f := AmalgamatedDirectSumCode( c, d );;|
  !gapprompt@gap>| !gapinput@MinimumDistance( f );;|
  !gapprompt@gap>| !gapinput@CoveringRadius( f );; |
  !gapprompt@gap>| !gapinput@f;|
  a linear [22,8,3]7 amalgamated direct sum code
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{BlockwiseDirectSumCode}}
\logpage{[ 6, 2, 8 ]}\nobreak
\hyperdef{L}{X7D8981AF7DFE9814}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BlockwiseDirectSumCode({\mdseries\slshape C1, L1, C2, L2})\index{BlockwiseDirectSumCode@\texttt{BlockwiseDirectSumCode}}
\label{BlockwiseDirectSumCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{BlockwiseDirectSumCode} returns a subcode of the direct sum of \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}. The fields of \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}} must be same. The lists \mbox{\texttt{\mdseries\slshape L1}} and \mbox{\texttt{\mdseries\slshape L2}} are two equally long with elements from the ambient vector spaces of \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}, respectively, \emph{or} \mbox{\texttt{\mdseries\slshape L1}} and \mbox{\texttt{\mdseries\slshape L2}} are two equally long lists containing codes. The union of the codes in \mbox{\texttt{\mdseries\slshape L1}} and \mbox{\texttt{\mdseries\slshape L2}} must be \mbox{\texttt{\mdseries\slshape C1}} and \mbox{\texttt{\mdseries\slshape C2}}, respectively. 

 In the first case, the blockwise direct sum code is defined as 
\[ bds = \bigcup_{1 \leq i \leq \ell} ( C_1 + (L_1)_i ) \oplus ( C_2 + (L_2)_i ), \]
 where $\ell$ is the length of \mbox{\texttt{\mdseries\slshape L1}} and \mbox{\texttt{\mdseries\slshape L2}}, and $\oplus$ is the direct sum. 

 In the second case, it is defined as 
\[ bds = \bigcup_{1 \leq i \leq \ell} ( (L_1)_i \oplus (L_2)_i ). \]
 The length of the new code is $n = n_1 + n_2$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := HammingCode( 3, GF(2) );;|
  !gapprompt@gap>| !gapinput@C2 := EvenWeightSubcode( WholeSpaceCode( 6, GF(2) ) );;|
  !gapprompt@gap>| !gapinput@BlockwiseDirectSumCode( C1, [[ 0,0,0,0,0,0,0 ],[ 1,0,1,0,1,0,0 ]],|
  !gapprompt@>| !gapinput@C2, [[ 0,0,0,0,0,0 ],[ 1,0,1,0,1,0 ]] );|
  a (13,1024,1..13)1..2 blockwise direct sum code
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ConstructionXCode}}
\logpage{[ 6, 2, 9 ]}\nobreak
\hyperdef{L}{X7C37D467791CE99B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConstructionXCode({\mdseries\slshape C, A})\index{ConstructionXCode@\texttt{ConstructionXCode}}
\label{ConstructionXCode}
}\hfill{\scriptsize (function)}}\\


 Consider a list of $j$ linear codes of the same length $N$ over the same field $F$, $C = \{ C_1, C_2, \ldots, C_j \}$, where the parameter of the $i$th code is $C_i = [N, K_i, D_i]$ and $C_j \subset C_{j-1} \subset \ldots \subset C_2 \subset C_1$. Consider a list of $j-1$ auxiliary linear codes of the same field $F$, $A = \{ A_1, A_2, \ldots, A_{j-1} \}$ where the parameter of the $i$th code $A_i$ is $[n_i, k_i=(K_i-K_{i+1}), d_i]$, an $[n, K_1, d]$ linear code over field $F$ can be constructed where $n = N + \sum_{i=1}^{j-1} n_i$, and $d = \min\{ D_j, D_{j-1} + d_{j-1}, D_{j-2} + d_{j-2} + d_{j-1}, \ldots, D_1 +
\sum_{i=1}^{j-1} d_i\}$. 

 For more information on Construction X, refer to \cite{Sloane72}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C1 := BCHCode(127, 43);|
  a cyclic [127,29,43]31..59 BCH code, delta=43, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@C2 := BCHCode(127, 47);|
  a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@C3 := BCHCode(127, 55);|
  a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@G1 := ShallowCopy( GeneratorMat(C2) );;|
  !gapprompt@gap>| !gapinput@Append(G1, [ GeneratorMat(C1)[23] ]);;|
  !gapprompt@gap>| !gapinput@C1 := GeneratorMatCode(G1, GF(2));|
  a linear [127,23,1..43]35..63 code defined by generator matrix over GF(2)
  !gapprompt@gap>| !gapinput@MinimumDistance(C1);|
  43
  !gapprompt@gap>| !gapinput@C := [ C1, C2, C3 ];|
  [ a linear [127,23,43]35..63 code defined by generator matrix over GF(2), 
    a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2), 
    a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2) ]
  !gapprompt@gap>| !gapinput@IsSubset(C[1], C[2]);|
  true
  !gapprompt@gap>| !gapinput@IsSubset(C[2], C[3]);|
  true
  !gapprompt@gap>| !gapinput@A := [ RepetitionCode(4, GF(2)), EvenWeightSubcode( QRCode(17, GF(2)) ) ];|
  [ a cyclic [4,1,4]2 repetition code over GF(2), a cyclic [17,8,6]3..6 even weight subcode ]
  !gapprompt@gap>| !gapinput@CX := ConstructionXCode(C, A);|
  a linear [148,23,53]43..74 Construction X code
  !gapprompt@gap>| !gapinput@History(CX);|
  [ "a linear [148,23,53]43..74 Construction X code of", 
    "Base codes: [ a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2)\
  , a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2), a linear \
  [127,23,43]35..63 code defined by generator matrix over GF(2) ]", 
    "Auxiliary codes: [ a cyclic [4,1,4]2 repetition code over GF(2), a cyclic [\
  17,8,6]3..6 even weight subcode ]" ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ConstructionXXCode}}
\logpage{[ 6, 2, 10 ]}\nobreak
\hyperdef{L}{X7B50943B8014134F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConstructionXXCode({\mdseries\slshape C1, C2, C3, A1, A2})\index{ConstructionXXCode@\texttt{ConstructionXXCode}}
\label{ConstructionXXCode}
}\hfill{\scriptsize (function)}}\\


 Consider a set of linear codes over field $F$ of the same length, $n$, $C_1=[n, k_1, d_1]$, $C_2=[n, k_2, d_2]$ and $C_3=[n, k_3, d_3]$ such that $C_2 \subset C_1$, $C_3 \subset C_1$ and $C_4 = C_2 \cap C_3$. Given two auxiliary codes $A_1=[n_1, k_1-k_2, e_1]$ and $A_2=[n_2, k_1-k_3, e_2]$ over the same field $F$, there exists an $[n+n_1+n_2, k_1, d]$ linear code $C_{XX}$ over field $F$, where $d = \min\{d_4, d_3 + e_1, d_2 + e_2, d_1 + e_1 + e_2\}$. 

 The codewords of $C_{XX}$ can be partitioned into three sections $( v\;\|\;a\;\|\;b )$ where $v$ has length $n$, $a$ has length $n_1$ and $b$ has length $n_2$. A codeword from Construction XX takes the following form: 
\begin{itemize}
\item  $( v \; \| \; 0 \; \| \; 0 )$ if $v \in C_4$ 
\item  $( v \; \| \; a_1 \; \| \; 0 )$ if $v \in C_3 \backslash C_4$ 
\item  $( v \; \| \; 0 \; \| \; a_2 )$ if $v \in C_2 \backslash C_4$ 
\item  $( v \; \| \; a_1 \; \| \; a_2 )$ otherwise 
\end{itemize}
 For more information on Construction XX, refer to \cite{Alltop84}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a := PrimitiveRoot(GF(32));|
  Z(2^5)
  !gapprompt@gap>| !gapinput@f0 := MinimalPolynomial( GF(2), a^0 );|
  x_1+Z(2)^0
  !gapprompt@gap>| !gapinput@f1 := MinimalPolynomial( GF(2), a^1 );|
  x_1^5+x_1^2+Z(2)^0
  !gapprompt@gap>| !gapinput@f5 := MinimalPolynomial( GF(2), a^5 );|
  x_1^5+x_1^4+x_1^2+x_1+Z(2)^0
  !gapprompt@gap>| !gapinput@C2 := CheckPolCode( f0 * f1, 31, GF(2) );; MinimumDistance(C2);; Display(C2);|
  a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
  !gapprompt@gap>| !gapinput@C3 := CheckPolCode( f0 * f5, 31, GF(2) );; MinimumDistance(C3);; Display(C3);|
  a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
  !gapprompt@gap>| !gapinput@C1 := UnionCode(C2, C3);; MinimumDistance(C1);; Display(C1);|
  a linear [31,11,11]7..11 union code of
  U: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
  V: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
  !gapprompt@gap>| !gapinput@A1 := BestKnownLinearCode( 10, 5, GF(2) );|
  a linear [10,5,4]2..4 shortened code
  !gapprompt@gap>| !gapinput@A2 := DualCode( RepetitionCode(6, GF(2)) );|
  a cyclic [6,5,2]1 dual code
  !gapprompt@gap>| !gapinput@CXX:= ConstructionXXCode(C1, C2, C3, A1, A2 );|
  a linear [47,11,15..17]13..23 Construction XX code
  !gapprompt@gap>| !gapinput@MinimumDistance(CXX);|
  17
  !gapprompt@gap>| !gapinput@History(CXX);        |
  [ "a linear [47,11,17]13..23 Construction XX code of", 
    "C1: a cyclic [31,11,11]7..11 union code", 
    "C2: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)", 
    "C3: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)", 
    "A1: a linear [10,5,4]2..4 shortened code", 
    "A2: a cyclic [6,5,2]1 dual code" ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{BZCode}}
\logpage{[ 6, 2, 11 ]}\nobreak
\hyperdef{L}{X790C614985BFAE16}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BZCode({\mdseries\slshape O, I})\index{BZCode@\texttt{BZCode}}
\label{BZCode}
}\hfill{\scriptsize (function)}}\\


 Given a set of outer codes of the same length $O_i = [N, K_i, D_i]$ over GF($q^{e_i}$), where $i=1,2,\ldots,t$ and a set of inner codes of the same length $I_i = [n, k_i, d_i]$ over GF($q$), \texttt{BZCode} returns a Blokh-Zyablov multilevel concatenated code with parameter $[ n \times N, \sum_{i=1}^t e_i \times K_i, \min_{i=1,\ldots,t}\{d_i \times
D_i\} ]$ over GF($q$). 

 Note that the set of inner codes must satisfy chain condition, i.e. $I_1 = [n, k_1, d_1] \subset I_2=[n, k_2, d_2] \subset \ldots \subset I_t=[n,
k_t, d_t]$ where $0=k_0 < k_1 < k_2 < \ldots < k_t$. The dimension of the inner codes must satisfy the condition $e_i = k_i - k_{i-1}$, where GF($q^{e_i}$) is the field of the $i$th outer code. 

 For more information on Blokh-Zyablov multilevel concatenated code, refer to \cite{Brouwer98}. }

 

\subsection{\textcolor{Chapter }{BZCodeNC}}
\logpage{[ 6, 2, 12 ]}\nobreak
\hyperdef{L}{X820327D6854A50B5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BZCodeNC({\mdseries\slshape O, I})\index{BZCodeNC@\texttt{BZCodeNC}}
\label{BZCodeNC}
}\hfill{\scriptsize (function)}}\\


 This function is the same as \texttt{BZCode}, except this version is faster as it does not estimate the covering radius of
the code. Users are encouraged to use this version unless you are working on
very small codes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@# Binary code|
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@O := [ CyclicMDSCode(2,3,7), BestKnownLinearCode(9,5,GF(2)), CyclicMDSCode(2,3,4) ];|
  [ a cyclic [9,7,3]1 MDS code over GF(8), a linear [9,5,3]2..3 shortened code, 
    a cyclic [9,4,6]4..5 MDS code over GF(8) ]
  !gapprompt@gap>| !gapinput@A := ExtendedCode( HammingCode(3,GF(2)) );;|
  !gapprompt@gap>| !gapinput@I := [ SubCode(A), A, DualCode( RepetitionCode(8, GF(2)) ) ];|
  [ a linear [8,3,4]3..4 subcode, a linear [8,4,4]2 extended code, a cyclic [8,7,2]1 dual code ]
  !gapprompt@gap>| !gapinput@C := BZCodeNC(O, I);|
  a linear [72,38,12]0..72 Blokh Zyablov concatenated code
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@# Non binary code|
  !gapprompt@gap>| !gapinput@#|
  !gapprompt@gap>| !gapinput@O2 := ExtendedCode(GoppaCode(ConwayPolynomial(5,2), Elements(GF(5))));;|
  !gapprompt@gap>| !gapinput@O3 := ExtendedCode(GoppaCode(ConwayPolynomial(5,3), Elements(GF(5))));;|
  !gapprompt@gap>| !gapinput@O1 := DualCode( O3 );;|
  !gapprompt@gap>| !gapinput@MinimumDistance(O1);; MinimumDistance(O2);; MinimumDistance(O3);;|
  !gapprompt@gap>| !gapinput@Cy := CyclicCodes(5, GF(5));;|
  !gapprompt@gap>| !gapinput@for i in [4, 5] do; MinimumDistance(Cy[i]);; od;|
  !gapprompt@gap>| !gapinput@O  := [ O1, O2, O3 ];|
  [ a linear [6,4,3]1 dual code, a linear [6,3,4]2..3 extended code,
    a linear [6,2,5]3..4 extended code ]
  !gapprompt@gap>| !gapinput@I  := [ Cy[5], Cy[4], Cy[3] ];|
  [ a cyclic [5,1,5]3..4 enumerated code over GF(5),
    a cyclic [5,2,4]2..3 enumerated code over GF(5),
    a cyclic [5,3,1..3]2 enumerated code over GF(5) ]
  !gapprompt@gap>| !gapinput@C  := BZCodeNC( O, I );|
  a linear [30,9,5..15]0..30 Blokh Zyablov concatenated code
  !gapprompt@gap>| !gapinput@MinimumDistance(C);|
  15
  !gapprompt@gap>| !gapinput@History(C);|
  [ "a linear [30,9,15]0..30 Blokh Zyablov concatenated code of",
    "Inner codes: [ a cyclic [5,1,5]3..4 enumerated code over GF(5), a cyclic [5\
  ,2,4]2..3 enumerated code over GF(5), a cyclic [5,3,1..3]2 enumerated code ove\
  r GF(5) ]",
    "Outer codes: [ a linear [6,4,3]1 dual code, a linear [6,3,4]2..3 extended c\
  ode, a linear [6,2,5]3..4 extended code ]" ]
\end{Verbatim}
  }

 }

 
\chapter{\textcolor{Chapter }{ Bounds on codes, special matrices and miscellaneous functions }}\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X7A814D518460862E}{}
{
  In this chapter we describe functions that determine bounds on the size and
minimum distance of codes (Section \ref{Distance bounds on codes}), functions that determine bounds on the size and covering radius of codes
(Section \ref{Covering radius bounds on codes}), functions that work with special matrices \textsf{GUAVA} needs for several codes (see Section \ref{Special matrices in GUAVA}), and constructing codes or performing calculations with codes (see Section \ref{Miscellaneous functions}). 
\section{\textcolor{Chapter }{ Distance bounds on codes }}\logpage{[ 7, 1, 0 ]}
\hyperdef{L}{X87C753EB840C34D3}{}
{
  \label{Distance bounds on codes} This section describes the functions that calculate estimates for upper bounds
on the size and minimum distance of codes. Several algorithms are known to
compute a largest number of words a code can have with given length and
minimum distance. It is important however to understand that in some cases the
true upper bound is unknown. A code which has a size equalto the calculated
upper bound may not have been found. However, codes that have a larger size do
not exist. 

 A second way to obtain bounds is a table. In \textsf{GUAVA}, an extensive table is implemented for linear codes over $GF(2)$, $GF(3)$ and $GF(4)$. It contains bounds on the minimum distance for given  word length and dimension. It contains entries for word lengths less than or
equal to $257$, $243$ and $256$ for codes over $GF(2)$, $GF(3)$ and $GF(4)$ respectively. These entries were obtained from Brouwer's tables as of 11 May
2006. For the latest information, please see A. E. Brouwer's tables \cite{Br} on the internet. 

 Firstly, we describe functions that compute specific upper bounds on the code
size (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton}), \texttt{UpperBoundHamming} (\ref{UpperBoundHamming}), \texttt{UpperBoundJohnson} (\ref{UpperBoundJohnson}), \texttt{UpperBoundPlotkin} (\ref{UpperBoundPlotkin}), \texttt{UpperBoundElias} (\ref{UpperBoundElias}) and \texttt{UpperBoundGriesmer} (\ref{UpperBoundGriesmer})). 

 Next we describe a function that computes \textsf{GUAVA}'s best upper bound on the code size (see \texttt{UpperBound} (\ref{UpperBound})). 

 Then we describe two functions that compute a lower and upper bound on the
minimum distance of a code (see \texttt{LowerBoundMinimumDistance} (\ref{LowerBoundMinimumDistance}) and \texttt{UpperBoundMinimumDistance} (\ref{UpperBoundMinimumDistance})). 

 Finally, we describe a function that returns a lower and upper bound on the
minimum distance with given parameters and a description of how the bounds
were obtained (see \texttt{BoundsMinimumDistance} (\ref{BoundsMinimumDistance})). \index{bounds, Singleton} 

\subsection{\textcolor{Chapter }{UpperBoundSingleton}}
\logpage{[ 7, 1, 1 ]}\nobreak
\hyperdef{L}{X8673277C7F6C04C3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundSingleton({\mdseries\slshape n, d, q})\index{UpperBoundSingleton@\texttt{UpperBoundSingleton}}
\label{UpperBoundSingleton}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundSingleton} returns the Singleton bound for a code of length \mbox{\texttt{\mdseries\slshape n}}, minimum distance \mbox{\texttt{\mdseries\slshape d}} over a field of size \mbox{\texttt{\mdseries\slshape q}}. This bound is based on the shortening of codes. By shortening an $(n, M, d)$ code $d-1$ times, an $(n-d+1,M,1)$ code results, with $M \leq q^{n-d+1}$ (see \texttt{ShortenedCode} (\ref{ShortenedCode})). Thus 
\[ M \leq q^{n-d+1}. \]
 \index{maximum distance separable} Codes that meet this bound are called \emph{maximum distance separable} (see \texttt{IsMDSCode} (\ref{IsMDSCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UpperBoundSingleton(4, 3, 5);|
  25
  !gapprompt@gap>| !gapinput@C := ReedSolomonCode(4,3);; Size(C);|
  25
  !gapprompt@gap>| !gapinput@IsMDSCode(C);|
  true 
\end{Verbatim}
 \index{bounds, Hamming} \index{bounds, sphere packing bound} \index{perfect} 

\subsection{\textcolor{Chapter }{UpperBoundHamming}}
\logpage{[ 7, 1, 2 ]}\nobreak
\hyperdef{L}{X828095537C91FDFA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundHamming({\mdseries\slshape n, d, q})\index{UpperBoundHamming@\texttt{UpperBoundHamming}}
\label{UpperBoundHamming}
}\hfill{\scriptsize (function)}}\\


 The Hamming bound (also known as the \emph{sphere packing bound}) returns an upper bound on the size of a code of length \mbox{\texttt{\mdseries\slshape n}}, minimum distance \mbox{\texttt{\mdseries\slshape d}}, over a field of size \mbox{\texttt{\mdseries\slshape q}}. The Hamming bound is obtained by dividing the contents of the entire space $GF(q)^n$ by the contents of a ball with radius $\lfloor(d-1) / 2\rfloor$. As all these balls are disjoint, they can never contain more than the whole
vector space. 
\[ M \leq {q^n \over V(n,e)}, \]
 where $M$ is the maxmimum number of codewords and $V(n,e)$ is equal to the contents of a ball of radius $e$ (see \texttt{SphereContent} (\ref{SphereContent})). This bound is useful for small values of \mbox{\texttt{\mdseries\slshape d}}. Codes for which equality holds are called \emph{perfect} (see \texttt{IsPerfectCode} (\ref{IsPerfectCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UpperBoundHamming( 15, 3, 2 );|
  2048
  !gapprompt@gap>| !gapinput@C := HammingCode( 4, GF(2) );|
  a linear [15,11,3]1 Hamming (4,2) code over GF(2)
  !gapprompt@gap>| !gapinput@Size( C );|
  2048 
\end{Verbatim}
 \index{bounds, Johnson} 

\subsection{\textcolor{Chapter }{UpperBoundJohnson}}
\logpage{[ 7, 1, 3 ]}\nobreak
\hyperdef{L}{X82EBFAAB7F5BFD4A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundJohnson({\mdseries\slshape n, d})\index{UpperBoundJohnson@\texttt{UpperBoundJohnson}}
\label{UpperBoundJohnson}
}\hfill{\scriptsize (function)}}\\


 The Johnson bound is an improved version of the Hamming bound (see \texttt{UpperBoundHamming} (\ref{UpperBoundHamming})). In addition to the Hamming bound, it takes into account the elements of the
space outside the balls of radius $e$ around the elements of the code. The Johnson bound only works for binary
codes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UpperBoundJohnson( 13, 5 );|
  77
  !gapprompt@gap>| !gapinput@UpperBoundHamming( 13, 5, 2);|
  89   # in this case the Johnson bound is better 
\end{Verbatim}
 \index{bounds, Plotkin} 

\subsection{\textcolor{Chapter }{UpperBoundPlotkin}}
\logpage{[ 7, 1, 4 ]}\nobreak
\hyperdef{L}{X7A26E2537DFF4409}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundPlotkin({\mdseries\slshape n, d, q})\index{UpperBoundPlotkin@\texttt{UpperBoundPlotkin}}
\label{UpperBoundPlotkin}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{UpperBoundPlotkin} calculates the sum of the distances of all ordered pairs of different
codewords. It is based on the fact that the minimum distance is at most equal
to the average distance. It is a good bound if the weights of the codewords do
not differ much. It results in: 
\[ M \leq {d \over {d-(1-1/q)n}}, \]
 where $M$ is the maximum number of codewords. In this case, \mbox{\texttt{\mdseries\slshape d}} must be larger than $(1-1/q)n$, but by shortening the code, the case $d \ \ \langle\ \ (1-1/q)n$ is covered. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UpperBoundPlotkin( 15, 7, 2 );|
  32
  !gapprompt@gap>| !gapinput@C := BCHCode( 15, 7, GF(2) );|
  a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@Size(C);|
  32
  !gapprompt@gap>| !gapinput@WeightDistribution(C);|
  [ 1, 0, 0, 0, 0, 0, 0, 15, 15, 0, 0, 0, 0, 0, 0, 1 ] 
\end{Verbatim}
  \index{bounds, Elias} 

\subsection{\textcolor{Chapter }{UpperBoundElias}}
\logpage{[ 7, 1, 5 ]}\nobreak
\hyperdef{L}{X86A5A7C67F625A40}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundElias({\mdseries\slshape n, d, q})\index{UpperBoundElias@\texttt{UpperBoundElias}}
\label{UpperBoundElias}
}\hfill{\scriptsize (function)}}\\


 The Elias bound is an improvement of the Plotkin bound (see \texttt{UpperBoundPlotkin} (\ref{UpperBoundPlotkin})) for large codes. Subcodes are used to decrease the size of the code, in this
case the subcode of all codewords within a certain ball. This bound is useful
for large codes with relatively small minimum distances. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UpperBoundPlotkin( 16, 3, 2 );|
  12288
  !gapprompt@gap>| !gapinput@UpperBoundElias( 16, 3, 2 );|
  10280 
  !gapprompt@gap>| !gapinput@UpperBoundElias( 20, 10, 3 );|
  16255
\end{Verbatim}
 \index{bounds, Griesmer} 

\subsection{\textcolor{Chapter }{UpperBoundGriesmer}}
\logpage{[ 7, 1, 6 ]}\nobreak
\hyperdef{L}{X82366C277E218130}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundGriesmer({\mdseries\slshape n, d, q})\index{UpperBoundGriesmer@\texttt{UpperBoundGriesmer}}
\label{UpperBoundGriesmer}
}\hfill{\scriptsize (function)}}\\


 The Griesmer bound is valid only for linear codes. It is obtained by counting
the number of equal symbols in each row of the generator matrix of the code.
By omitting the coordinates in which all rows have a zero, a smaller code
results. The Griesmer bound is obtained by repeating this proces until a
trivial code is left in the end. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UpperBoundGriesmer( 13, 5, 2 );|
  64
  !gapprompt@gap>| !gapinput@UpperBoundGriesmer( 18, 9, 2 );|
  8        # the maximum number of words for a linear code is 8
  !gapprompt@gap>| !gapinput@Size( PuncturedCode( HadamardCode( 20, 1 ) ) );|
  20       # this non-linear code has 20 elements 
\end{Verbatim}
  \index{Griesmer code} 

\subsection{\textcolor{Chapter }{IsGriesmerCode}}
\logpage{[ 7, 1, 7 ]}\nobreak
\hyperdef{L}{X8301FA9F7C6C7445}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsGriesmerCode({\mdseries\slshape C})\index{IsGriesmerCode@\texttt{IsGriesmerCode}}
\label{IsGriesmerCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsGriesmerCode} returns `true' if a linear code \mbox{\texttt{\mdseries\slshape C}} is a Griesmer code, and `false' otherwise. A code is called \emph{Griesmer} if its length satisfies 
\[ n = g[k,d] = \sum_{i=0}^{k-1} \lceil \frac{d}{q^i} \rceil. \]
 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsGriesmerCode( HammingCode( 3, GF(2) ) );|
  true
  !gapprompt@gap>| !gapinput@IsGriesmerCode( BCHCode( 17, 2, GF(2) ) );|
  false 
\end{Verbatim}
 \index{$A(n,d)$} 

\subsection{\textcolor{Chapter }{UpperBound}}
\logpage{[ 7, 1, 8 ]}\nobreak
\hyperdef{L}{X7A5CB74485184FEE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBound({\mdseries\slshape n, d, q})\index{UpperBound@\texttt{UpperBound}}
\label{UpperBound}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBound} returns the best known upper bound $A(n,d)$ for the size of a code of length \mbox{\texttt{\mdseries\slshape n}}, minimum distance \mbox{\texttt{\mdseries\slshape d}} over a field of size \mbox{\texttt{\mdseries\slshape q}}. The function \texttt{UpperBound} first checks for trivial cases (like $d=1$ or $n=d$), and if the value is in the built-in table. Then it calculates the minimum
value of the upper bound using the methods of Singleton (see \texttt{UpperBoundSingleton} (\ref{UpperBoundSingleton})), Hamming (see \texttt{UpperBoundHamming} (\ref{UpperBoundHamming})), Johnson (see \texttt{UpperBoundJohnson} (\ref{UpperBoundJohnson})), Plotkin (see \texttt{UpperBoundPlotkin} (\ref{UpperBoundPlotkin})) and Elias (see \texttt{UpperBoundElias} (\ref{UpperBoundElias})). If the code is binary, $A(n, 2\cdot \ell-1) = A(n+1,2\cdot \ell)$, so the \texttt{UpperBound} takes the minimum of the values obtained from all methods for the parameters $(n, 2\cdot\ell-1)$ and $(n+1, 2\cdot \ell)$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UpperBound( 10, 3, 2 );|
  85
  !gapprompt@gap>| !gapinput@UpperBound( 25, 9, 8 );|
  1211778792827540 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundMinimumDistance}}
\logpage{[ 7, 1, 9 ]}\nobreak
\hyperdef{L}{X7FDF54BA81115D88}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundMinimumDistance({\mdseries\slshape C})\index{LowerBoundMinimumDistance@\texttt{LowerBoundMinimumDistance}}
\label{LowerBoundMinimumDistance}
}\hfill{\scriptsize (function)}}\\


 In this form, \texttt{LowerBoundMinimumDistance} returns a lower bound for the minimum distance of code \mbox{\texttt{\mdseries\slshape C}}. 

 This command can also be called using the syntax \texttt{LowerBoundMinimumDistance( n, k, F )}. In this form, \texttt{LowerBoundMinimumDistance} returns a lower bound for the minimum distance of the best known linear code
of length \mbox{\texttt{\mdseries\slshape n}}, dimension \mbox{\texttt{\mdseries\slshape k}} over field \mbox{\texttt{\mdseries\slshape F}}. It uses the mechanism explained in section \ref{BoundsMinimumDistance}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := BCHCode( 45, 7 );|
  a cyclic [45,23,7..9]6..16 BCH code, delta=7, b=1 over GF(2)
  !gapprompt@gap>| !gapinput@LowerBoundMinimumDistance( C );|
  7     # designed distance is lower bound for minimum distance 
  !gapprompt@gap>| !gapinput@LowerBoundMinimumDistance( 45, 23, GF(2) );|
  10 
\end{Verbatim}
  \index{bound, Gilbert-Varshamov lower} 

\subsection{\textcolor{Chapter }{LowerBoundGilbertVarshamov}}
\logpage{[ 7, 1, 10 ]}\nobreak
\hyperdef{L}{X7CF15D2084499869}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundGilbertVarshamov({\mdseries\slshape n, d, q})\index{LowerBoundGilbertVarshamov@\texttt{LowerBoundGilbertVarshamov}}
\label{LowerBoundGilbertVarshamov}
}\hfill{\scriptsize (function)}}\\


 This is the lower bound on the size of a linear code due (independently) to
Gilbert and Varshamov. It says that for each \mbox{\texttt{\mdseries\slshape n}} and \mbox{\texttt{\mdseries\slshape d}}, there exists a linear code having length $n$ and minimum distance $d$ at least of size $q^k$, where $k$ is the largest integer such that $q^k < q^{n}/$\texttt{SphereContent}$(n-1,d-2,GF(q))$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@LowerBoundGilbertVarshamov(24,8,2);|
  64
  !gapprompt@gap>| !gapinput@LowerBoundGilbertVarshamov(7,3,2);|
  16
  !gapprompt@gap>| !gapinput@LowerBoundMinimumDistance(7,4,2);|
  3
  !gapprompt@gap>| !gapinput@LowerBoundGilbertVarshamov(3,3,2);|
  1
  !gapprompt@gap>| !gapinput@LowerBoundMinimumDistance(3,3,2);|
  1
  !gapprompt@gap>| !gapinput@LowerBoundGilbertVarshamov(25,10,2);|
  16
\end{Verbatim}
  \index{bound, sphere packing lower} 

\subsection{\textcolor{Chapter }{LowerBoundSpherePacking}}
\logpage{[ 7, 1, 11 ]}\nobreak
\hyperdef{L}{X8217D830871286D8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundSpherePacking({\mdseries\slshape n, d, q})\index{LowerBoundSpherePacking@\texttt{LowerBoundSpherePacking}}
\label{LowerBoundSpherePacking}
}\hfill{\scriptsize (function)}}\\


 This is the (weaker) Gilbert-Varshamov bound valid for unrestricted codes over
an alphabet of size \mbox{\texttt{\mdseries\slshape q}} (where \mbox{\texttt{\mdseries\slshape q}} is an integer {\textgreater} 1). It says that for each \mbox{\texttt{\mdseries\slshape n}} and \mbox{\texttt{\mdseries\slshape r}}, there exists an unrestricted code at least of size $q^n/$\texttt{SphereContent}$(n,d,GF(q))$ minimum distance $d$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@LowerBoundSpherePacking(3,2,2);|
  2
  !gapprompt@gap>| !gapinput@LowerBoundSpherePacking(3,3,2);|
  1
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UpperBoundMinimumDistance}}
\logpage{[ 7, 1, 12 ]}\nobreak
\hyperdef{L}{X7C6A58327BD6B685}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundMinimumDistance({\mdseries\slshape C})\index{UpperBoundMinimumDistance@\texttt{UpperBoundMinimumDistance}}
\label{UpperBoundMinimumDistance}
}\hfill{\scriptsize (function)}}\\


 In this form, \texttt{UpperBoundMinimumDistance} returns an upper bound for the minimum distance of code \mbox{\texttt{\mdseries\slshape C}}. For unrestricted codes, it just returns the word length. For linear codes,
it takes the minimum of the possibly known value from the method of
construction, the weight of the generators, and the value from the table (see \ref{BoundsMinimumDistance}). 

 This command can also be called using the syntax \texttt{UpperBoundMinimumDistance( n, k, F )}. In this form, \texttt{UpperBoundMinimumDistance} returns an upper bound for the minimum distance of the best known linear code
of length \mbox{\texttt{\mdseries\slshape n}}, dimension \mbox{\texttt{\mdseries\slshape k}} over field \mbox{\texttt{\mdseries\slshape F}}. It uses the mechanism explained in section \ref{BoundsMinimumDistance}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := BCHCode( 45, 7 );;|
  !gapprompt@gap>| !gapinput@UpperBoundMinimumDistance( C );|
  9 
  !gapprompt@gap>| !gapinput@UpperBoundMinimumDistance( 45, 23, GF(2) );|
  11 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{BoundsMinimumDistance}}
\logpage{[ 7, 1, 13 ]}\nobreak
\hyperdef{L}{X7B3858B27A9E509A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BoundsMinimumDistance({\mdseries\slshape n, k, F})\index{BoundsMinimumDistance@\texttt{BoundsMinimumDistance}}
\label{BoundsMinimumDistance}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{BoundsMinimumDistance} calculates a lower and upper bound for the minimum distance of an optimal
linear code with word length \mbox{\texttt{\mdseries\slshape n}}, dimension \mbox{\texttt{\mdseries\slshape k}} over field \mbox{\texttt{\mdseries\slshape F}}. The function returns a record with the two bounds and an explanation for
each bound. The function \texttt{Display} can be used to show the explanations. 

 The values for the lower and upper bound are obtained from a table. \textsf{GUAVA} has tables containing lower and upper bounds for $q=2 (n \leq 257),  3 (n \leq 243), 4 (n \leq 256)$. (Current as of 11 May 2006.) These tables were derived from the table of
Brouwer. (See \cite{Br}, \href{http://www.win.tue.nl/~aeb/voorlincod.html} {\texttt{http://www.win.tue.nl/\texttt{\symbol{126}}aeb/voorlincod.html}} for the most recent data.) For codes over other fields and for larger word
lengths, trivial bounds are used. 

 The resulting record can be used in the function \texttt{BestKnownLinearCode} (see \texttt{BestKnownLinearCode} (\ref{BestKnownLinearCode})) to construct a code with minimum distance equal to the lower bound. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@bounds := BoundsMinimumDistance( 7, 3 );; DisplayBoundsInfo( bounds );|
  an optimal linear [7,3,d] code over GF(2) has d=4
  ------------------------------------------------------------------------------
  Lb(7,3)=4, by shortening of:
  Lb(8,4)=4, u u+v construction of C1 and C2:
  Lb(4,3)=2, dual of the repetition code
  Lb(4,1)=4, repetition code
  ------------------------------------------------------------------------------
  Ub(7,3)=4, Griesmer bound
  # The lower bound is equal to the upper bound, so a code with
  # these parameters is optimal.
  !gapprompt@gap>| !gapinput@C := BestKnownLinearCode( bounds );; Display( C );|
  a linear [7,3,4]2..3 shortened code of
  a linear [8,4,4]2 U U+V construction code of
  U: a cyclic [4,3,2]1 dual code of
     a cyclic [4,1,4]2 repetition code over GF(2)
  V: a cyclic [4,1,4]2 repetition code over GF(2)
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Covering radius bounds on codes }}\logpage{[ 7, 2, 0 ]}
\hyperdef{L}{X817D0A647D3331EB}{}
{
  \label{Covering radius bounds on codes} 

\subsection{\textcolor{Chapter }{BoundsCoveringRadius}}
\logpage{[ 7, 2, 1 ]}\nobreak
\hyperdef{L}{X8320D1C180A1AAAD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BoundsCoveringRadius({\mdseries\slshape C})\index{BoundsCoveringRadius@\texttt{BoundsCoveringRadius}}
\label{BoundsCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{BoundsCoveringRadius} returns a list of integers. The first entry of this list is the maximum of
some lower bounds for the covering radius of \mbox{\texttt{\mdseries\slshape C}}, the last entry the minimum of some upper bounds of \mbox{\texttt{\mdseries\slshape C}}. 

 If the covering radius of \mbox{\texttt{\mdseries\slshape C}} is known, a list of length 1 is returned. \texttt{BoundsCoveringRadius} makes use of the functions \texttt{GeneralLowerBoundCoveringRadius} and \texttt{GeneralUpperBoundCoveringRadius}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@BoundsCoveringRadius( BCHCode( 17, 3, GF(2) ) );|
  [ 3 .. 4 ]
  !gapprompt@gap>| !gapinput@BoundsCoveringRadius( HammingCode( 5, GF(2) ) );|
  [ 1 ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IncreaseCoveringRadiusLowerBound}}
\logpage{[ 7, 2, 2 ]}\nobreak
\hyperdef{L}{X7881E03E812140F4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IncreaseCoveringRadiusLowerBound({\mdseries\slshape C[, stopdist][, startword]})\index{IncreaseCoveringRadiusLowerBound@\texttt{IncreaseCoveringRadiusLowerBound}}
\label{IncreaseCoveringRadiusLowerBound}
}\hfill{\scriptsize (function)}}\\


 \texttt{IncreaseCoveringRadiusLowerBound} tries to increase the lower bound of the covering radius of \mbox{\texttt{\mdseries\slshape C}}. It does this by means of a probabilistic algorithm. This algorithm takes a
random word in $GF(q)^n$ (or \mbox{\texttt{\mdseries\slshape startword}} if it is specified), and, by changing random coordinates, tries to get as far
from \mbox{\texttt{\mdseries\slshape C}} as possible. If changing a coordinate finds a word that has a larger distance
to the code than the previous one, the change is made permanent, and the
algorithm starts all over again. If changing a coordinate does not find a
coset leader that is further away from the code, then the change is made
permanent with a chance of 1 in 100, if it gets the word closer to the code,
or with a chance of 1 in 10, if the word stays at the same distance.
Otherwise, the algorithm starts again with the same word as before. 

 If the algorithm did not allow changes that decrease the distance to the code,
it might get stuck in a sub-optimal situation (the coset leader corresponding
to such a situation - i.e. no coordinate of this coset leader can be changed
in such a way that we get at a larger distance from the code - is called an \emph{orphan}). 

 If the algorithm finds a word that has distance \mbox{\texttt{\mdseries\slshape stopdist}} to the code, it ends and returns that word, which can be used for further
investigations. 

 The variable \mbox{\texttt{\mdseries\slshape InfoCoveringRadius}} can be set to \mbox{\texttt{\mdseries\slshape Print}} to print the maximum distance reached so far every 1000 runs. The algorithm
can be interrupted with \textsc{ctrl-C}, allowing the user to look at the word that is currently being examined
(called `current'), or to change the chances that the new word is made
permanent (these are called `staychance' and `downchance'). If one of these
variables is $i$, then it corresponds with a $i$ in 100 chance. 

 At the moment, the algorithm is only useful for codes with small dimension,
where small means that the elements of the code fit in the memory. It works
with larger codes, however, but when you use it for codes with large
dimension, you should be \emph{very} patient. If running the algorithm quits GAP (due to memory problems), you can
change the global variable \mbox{\texttt{\mdseries\slshape CRMemSize}} to a lower value. This might cause the algorithm to run slower, but without
quitting GAP. The only way to find out the best value of \mbox{\texttt{\mdseries\slshape CRMemSize}} is by experimenting. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@IncreaseCoveringRadiusLowerBound(C,10);|
  Number of runs: 1000  best distance so far: 3
  Number of runs: 2000  best distance so far: 3
  Number of changes: 100
  Number of runs: 3000  best distance so far: 3
  Number of runs: 4000  best distance so far: 3
  Number of runs: 5000  best distance so far: 3
  Number of runs: 6000  best distance so far: 3
  Number of runs: 7000  best distance so far: 3
  Number of changes: 200
  Number of runs: 8000  best distance so far: 3
  Number of runs: 9000  best distance so far: 3
  Number of runs: 10000  best distance so far: 3
  Number of changes: 300
  Number of runs: 11000  best distance so far: 3
  Number of runs: 12000  best distance so far: 3
  Number of runs: 13000  best distance so far: 3
  Number of changes: 400
  Number of runs: 14000  best distance so far: 3
  user interrupt at... 
  #
  # used ctrl-c to break out of execution
  #
  ... called from 
  IncreaseCoveringRadiusLowerBound( code, -1, current ) called from
   function( arguments ) called from read-eval-loop
  Entering break read-eval-print loop ...
  you can 'quit;' to quit to outer loop, or
  you can 'return;' to continue
  !gapbrkprompt@brk>| !gapinput@current;|
  [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ]
  !gapbrkprompt@brk>| !gapinput@|
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ExhaustiveSearchCoveringRadius}}
\logpage{[ 7, 2, 3 ]}\nobreak
\hyperdef{L}{X7AD9F1D27C52BC0F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExhaustiveSearchCoveringRadius({\mdseries\slshape C})\index{ExhaustiveSearchCoveringRadius@\texttt{ExhaustiveSearchCoveringRadius}}
\label{ExhaustiveSearchCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{ExhaustiveSearchCoveringRadius} does an exhaustive search to find the covering radius of \mbox{\texttt{\mdseries\slshape C}}. Every time a coset leader of a coset with weight $w$ is found, the function tries to find a coset leader of a coset with weight $w+1$. It does this by enumerating all words of weight $w+1$, and checking whether a word is a coset leader. The start weight is the
current known lower bound on the covering radius. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@ExhaustiveSearchCoveringRadius(C);|
  Trying 3 ...
  [ 3 .. 5 ]
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralLowerBoundCoveringRadius}}
\logpage{[ 7, 2, 4 ]}\nobreak
\hyperdef{L}{X85D671F4824B4B0C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralLowerBoundCoveringRadius({\mdseries\slshape C})\index{GeneralLowerBoundCoveringRadius@\texttt{GeneralLowerBoundCoveringRadius}}
\label{GeneralLowerBoundCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralLowerBoundCoveringRadius} returns a lower bound on the covering radius of \mbox{\texttt{\mdseries\slshape C}}. It uses as many functions which names start with \texttt{LowerBoundCoveringRadius} as possible to find the best known lower bound (at least that \textsf{GUAVA} knows of) together with tables for the covering radius of binary linear codes
with length not greater than $64$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@GeneralLowerBoundCoveringRadius(C);|
  2
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GeneralUpperBoundCoveringRadius}}
\logpage{[ 7, 2, 5 ]}\nobreak
\hyperdef{L}{X8638F5A67D6E50C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralUpperBoundCoveringRadius({\mdseries\slshape C})\index{GeneralUpperBoundCoveringRadius@\texttt{GeneralUpperBoundCoveringRadius}}
\label{GeneralUpperBoundCoveringRadius}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralUpperBoundCoveringRadius} returns an upper bound on the covering radius of \mbox{\texttt{\mdseries\slshape C}}. It uses as many functions which names start with \texttt{UpperBoundCoveringRadius} as possible to find the best known upper bound (at least that \textsf{GUAVA} knows of). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@GeneralUpperBoundCoveringRadius(C);|
  4
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusSphereCovering}}
\logpage{[ 7, 2, 6 ]}\nobreak
\hyperdef{L}{X7E7FBCC87D5562AB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundCoveringRadiusSphereCovering({\mdseries\slshape n, M[, F], false})\index{LowerBoundCoveringRadiusSphereCovering@\texttt{Lower}\-\texttt{Bound}\-\texttt{Covering}\-\texttt{Radius}\-\texttt{Sphere}\-\texttt{Covering}}
\label{LowerBoundCoveringRadiusSphereCovering}
}\hfill{\scriptsize (function)}}\\


 This command can also be called using the syntax \texttt{LowerBoundCoveringRadiusSphereCovering( n, r, [F,] true )}. If the last argument of \texttt{LowerBoundCoveringRadiusSphereCovering} is \mbox{\texttt{\mdseries\slshape false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{\mdseries\slshape M}} and length \mbox{\texttt{\mdseries\slshape n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{\mdseries\slshape n}} and covering radius \mbox{\texttt{\mdseries\slshape r}}. 

 \mbox{\texttt{\mdseries\slshape F}} is the field over which the code is defined. If \mbox{\texttt{\mdseries\slshape F}} is omitted, it is assumed that the code is over $GF(2)$. The bound is computed according to the sphere covering bound: 
\[ M \cdot V_q(n,r) \geq q^n \]
 where $V_q(n,r)$ is the size of a sphere of radius $r$ in $GF(q)^n$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@Size(C);|
  32
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusSphereCovering(10,32,GF(2),false);|
  2
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusSphereCovering(10,3,GF(2),true);|
  6
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusVanWee1}}
\logpage{[ 7, 2, 7 ]}\nobreak
\hyperdef{L}{X85E20C518360AB70}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundCoveringRadiusVanWee1({\mdseries\slshape n, M[, F], false})\index{LowerBoundCoveringRadiusVanWee1@\texttt{LowerBoundCoveringRadiusVanWee1}}
\label{LowerBoundCoveringRadiusVanWee1}
}\hfill{\scriptsize (function)}}\\


 This command can also be called using the syntax \texttt{LowerBoundCoveringRadiusVanWee1( n, r, [F,] true )}. If the last argument of \texttt{LowerBoundCoveringRadiusVanWee1} is \mbox{\texttt{\mdseries\slshape false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{\mdseries\slshape M}} and length \mbox{\texttt{\mdseries\slshape n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{\mdseries\slshape n}} and covering radius \mbox{\texttt{\mdseries\slshape r}}. 

 \mbox{\texttt{\mdseries\slshape F}} is the field over which the code is defined. If \mbox{\texttt{\mdseries\slshape F}} is omitted, it is assumed that the code is over $GF(2)$. 

 The Van Wee bound is an improvement of the sphere covering bound: 
\[ M \cdot \left\{ V_q(n,r) - \frac{{n \choose r}}{\lceil\frac{n-r}{r+1}\rceil}
\left(\left\lceil\frac{n+1}{r+1}\right\rceil - \frac{n+1}{r+1}\right) \right\}
\geq q^n \]
 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@Size(C);|
  32
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusVanWee1(10,32,GF(2),false);|
  2
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusVanWee1(10,3,GF(2),true);|
  6
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusVanWee2}}
\logpage{[ 7, 2, 8 ]}\nobreak
\hyperdef{L}{X7C72994A825228E7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundCoveringRadiusVanWee2({\mdseries\slshape n, M, false})\index{LowerBoundCoveringRadiusVanWee2@\texttt{LowerBoundCoveringRadiusVanWee2}}
\label{LowerBoundCoveringRadiusVanWee2}
}\hfill{\scriptsize (function)}}\\


 This command can also be called using the syntax \texttt{LowerBoundCoveringRadiusVanWee2( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusVanWee2} is \mbox{\texttt{\mdseries\slshape false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{\mdseries\slshape M}} and length \mbox{\texttt{\mdseries\slshape n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{\mdseries\slshape n}} and covering radius \mbox{\texttt{\mdseries\slshape r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \frac{\left( \left( V_2(n,2) - \frac{1}{2}(r+2)(r-1) \right) V_2(n,r)
+ \varepsilon V_2(n,r-2) \right)} {(V_2(n,2) - \frac{1}{2}(r+2)(r-1) +
\varepsilon)} \geq 2^n, \]
 where 
\[ \varepsilon = {r+2 \choose 2} \left\lceil {n-r+1 \choose 2} / {r+2 \choose 2}
\right\rceil - {n-r+1 \choose 2}. \]
 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@Size(C);|
  32
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusVanWee2(10,32,false);|
  2
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusVanWee2(10,3,true);|
  7
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusCountingExcess}}
\logpage{[ 7, 2, 9 ]}\nobreak
\hyperdef{L}{X7F95362485759ACB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundCoveringRadiusCountingExcess({\mdseries\slshape n, M, false})\index{LowerBoundCoveringRadiusCountingExcess@\texttt{Lower}\-\texttt{Bound}\-\texttt{Covering}\-\texttt{Radius}\-\texttt{Counting}\-\texttt{Excess}}
\label{LowerBoundCoveringRadiusCountingExcess}
}\hfill{\scriptsize (function)}}\\


 This command can also be called with \texttt{LowerBoundCoveringRadiusCountingExcess( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusCountingExcess} is \mbox{\texttt{\mdseries\slshape false}}, then it returns a lower bound for the covering radius of a code of size \mbox{\texttt{\mdseries\slshape M}} and length \mbox{\texttt{\mdseries\slshape n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{\mdseries\slshape n}} and covering radius \mbox{\texttt{\mdseries\slshape r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \left( \rho V_2(n,r) + \varepsilon V_2(n,r-1) \right) \geq (\rho +
\varepsilon) 2^n, \]
 where 
\[ \varepsilon = (r+1) \left\lceil\frac{n+1}{r+1}\right\rceil - (n+1) \]
 and 
\[ \rho = \left\{ \begin{array}{l} n-3+\frac{2}{n}, \ \ \ \ \ \ {\rm if}\ r = 2\\
n-r-1 , \ \ \ \ \ \ {\rm if}\ r \geq 3 . \end{array} \right. \]
 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@Size(C);|
  32
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusCountingExcess(10,32,false);|
  0
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusCountingExcess(10,3,true);|
  7
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusEmbedded1}}
\logpage{[ 7, 2, 10 ]}\nobreak
\hyperdef{L}{X829C14A383B5BF59}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundCoveringRadiusEmbedded1({\mdseries\slshape n, M, false})\index{LowerBoundCoveringRadiusEmbedded1@\texttt{LowerBoundCoveringRadiusEmbedded1}}
\label{LowerBoundCoveringRadiusEmbedded1}
}\hfill{\scriptsize (function)}}\\


 This command can also be called with \texttt{LowerBoundCoveringRadiusEmbedded1( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusEmbedded1} is 'false', then it returns a lower bound for the covering radius of a code of
size \mbox{\texttt{\mdseries\slshape M}} and length \mbox{\texttt{\mdseries\slshape n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{\mdseries\slshape n}} and covering radius \mbox{\texttt{\mdseries\slshape r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \left( V_2(n,r) - {2r \choose r} \right) \geq 2^n - A( n, 2r+1 ) {2r
\choose r}, \]
 where $A(n,d)$ denotes the maximal cardinality of a (binary) code of length $n$ and minimum distance $d$. The function \texttt{UpperBound} is used to compute this value. 

 Sometimes \texttt{LowerBoundCoveringRadiusEmbedded1} is better than \texttt{LowerBoundCoveringRadiusEmbedded2}, sometimes it is the other way around. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(10,5,GF(2));|
  a  [10,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@Size(C);|
  32
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusEmbedded1(10,32,false);|
  2
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusEmbedded1(10,3,true);|
  7
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusEmbedded2}}
\logpage{[ 7, 2, 11 ]}\nobreak
\hyperdef{L}{X7B0C81B88604C448}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundCoveringRadiusEmbedded2({\mdseries\slshape n, M, false})\index{LowerBoundCoveringRadiusEmbedded2@\texttt{LowerBoundCoveringRadiusEmbedded2}}
\label{LowerBoundCoveringRadiusEmbedded2}
}\hfill{\scriptsize (function)}}\\


 This command can also be called with \texttt{LowerBoundCoveringRadiusEmbedded2( n, r [,true] )}. If the last argument of \texttt{LowerBoundCoveringRadiusEmbedded2} is 'false', then it returns a lower bound for the covering radius of a code of
size \mbox{\texttt{\mdseries\slshape M}} and length \mbox{\texttt{\mdseries\slshape n}}. Otherwise, it returns a lower bound for the size of a code of length \mbox{\texttt{\mdseries\slshape n}} and covering radius \mbox{\texttt{\mdseries\slshape r}}. 

 This bound only works for binary codes. It is based on the following
inequality: 
\[ M \cdot \left( V_2(n,r) - \frac{3}{2} {2r \choose r} \right) \geq 2^n - 2A( n,
2r+1 ) {2r \choose r}, \]
 where $A(n,d)$ denotes the maximal cardinality of a (binary) code of length $n$ and minimum distance $d$. The function \texttt{UpperBound} is used to compute this value. 

 Sometimes \texttt{LowerBoundCoveringRadiusEmbedded1} is better than \texttt{LowerBoundCoveringRadiusEmbedded2}, sometimes it is the other way around. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(15,5,GF(2));|
  a  [15,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@Size(C);|
  32
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  6
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusEmbedded2(10,32,false);|
  2
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusEmbedded2(10,3,true);|
  7
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LowerBoundCoveringRadiusInduction}}
\logpage{[ 7, 2, 12 ]}\nobreak
\hyperdef{L}{X7D27F6E27B9A0D35}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerBoundCoveringRadiusInduction({\mdseries\slshape n, r})\index{LowerBoundCoveringRadiusInduction@\texttt{LowerBoundCoveringRadiusInduction}}
\label{LowerBoundCoveringRadiusInduction}
}\hfill{\scriptsize (function)}}\\


 \texttt{LowerBoundCoveringRadiusInduction} returns a lower bound for the size of a code with length \mbox{\texttt{\mdseries\slshape n}} and covering radius \mbox{\texttt{\mdseries\slshape r}}. 

 If $n = 2r+2$ and $r \geq 1$, the returned value is $4$. 

 If $n = 2r+3$ and $r \geq 1$, the returned value is $7$. 

 If $n = 2r+4$ and $r \geq 4$, the returned value is $8$. 

 Otherwise, $0$ is returned. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(15,5,GF(2));|
  a  [15,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  5
  !gapprompt@gap>| !gapinput@LowerBoundCoveringRadiusInduction(15,6);|
  7
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusRedundancy}}
\logpage{[ 7, 2, 13 ]}\nobreak
\hyperdef{L}{X80F8DFAD7D67CBEC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundCoveringRadiusRedundancy({\mdseries\slshape C})\index{UpperBoundCoveringRadiusRedundancy@\texttt{UpperBoundCoveringRadiusRedundancy}}
\label{UpperBoundCoveringRadiusRedundancy}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundCoveringRadiusRedundancy} returns the redundancy of \mbox{\texttt{\mdseries\slshape C}} as an upper bound for the covering radius of \mbox{\texttt{\mdseries\slshape C}}. \mbox{\texttt{\mdseries\slshape C}} must be a linear code. }

 \index{external distance} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(15,5,GF(2));|
  a  [15,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  5
  !gapprompt@gap>| !gapinput@UpperBoundCoveringRadiusRedundancy(C);|
  10
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusDelsarte}}
\logpage{[ 7, 2, 14 ]}\nobreak
\hyperdef{L}{X832847A17FD0D142}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundCoveringRadiusDelsarte({\mdseries\slshape C})\index{UpperBoundCoveringRadiusDelsarte@\texttt{UpperBoundCoveringRadiusDelsarte}}
\label{UpperBoundCoveringRadiusDelsarte}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundCoveringRadiusDelsarte} returns an upper bound for the covering radius of \mbox{\texttt{\mdseries\slshape C}}. This upper bound is equal to the external distance of \mbox{\texttt{\mdseries\slshape C}}, this is the minimum distance of the dual code, if \mbox{\texttt{\mdseries\slshape C}} is a linear code. 

 This is described in Theorem 11.3.3 of \cite{HP03}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(15,5,GF(2));|
  a  [15,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  5
  !gapprompt@gap>| !gapinput@UpperBoundCoveringRadiusDelsarte(C);|
  13
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusStrength}}
\logpage{[ 7, 2, 15 ]}\nobreak
\hyperdef{L}{X86F10D9E79AB8796}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundCoveringRadiusStrength({\mdseries\slshape C})\index{UpperBoundCoveringRadiusStrength@\texttt{UpperBoundCoveringRadiusStrength}}
\label{UpperBoundCoveringRadiusStrength}
}\hfill{\scriptsize (function)}}\\


 \texttt{UpperBoundCoveringRadiusStrength} returns an upper bound for the covering radius of \mbox{\texttt{\mdseries\slshape C}}. 

 First the code is punctured at the zero coordinates (i.e. the coordinates
where all codewords have a zero). If the remaining code has \emph{strength} 1 (i.e. each coordinate contains each element of the field an equal number of
times), then it returns $\frac{q-1}{q}m + (n-m)$ (where $q$ is the size of the field and $m$ is the length of punctured code), otherwise it returns $n$. This bound works for all codes. }

 \index{strength} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(15,5,GF(2));|
  a  [15,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  5
  !gapprompt@gap>| !gapinput@UpperBoundCoveringRadiusStrength(C);|
  7
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusGriesmerLike}}
\logpage{[ 7, 2, 16 ]}\nobreak
\hyperdef{L}{X8585C6A982489FC3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundCoveringRadiusGriesmerLike({\mdseries\slshape C})\index{UpperBoundCoveringRadiusGriesmerLike@\texttt{Upper}\-\texttt{Bound}\-\texttt{Covering}\-\texttt{Radius}\-\texttt{Griesmer}\-\texttt{Like}}
\label{UpperBoundCoveringRadiusGriesmerLike}
}\hfill{\scriptsize (function)}}\\


 This function returns an upper bound for the covering radius of \mbox{\texttt{\mdseries\slshape C}}, which must be linear, in a Griesmer-like fashion. It returns 
\[ n - \sum_{i=1}^k \left\lceil \frac{d}{q^i} \right\rceil \]
 }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=RandomLinearCode(15,5,GF(2));|
  a  [15,5,?] randomly generated code over GF(2)
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  5
  !gapprompt@gap>| !gapinput@UpperBoundCoveringRadiusGriesmerLike(C);|
  9
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{UpperBoundCoveringRadiusCyclicCode}}
\logpage{[ 7, 2, 17 ]}\nobreak
\hyperdef{L}{X82A38F5F858CF3FC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperBoundCoveringRadiusCyclicCode({\mdseries\slshape C})\index{UpperBoundCoveringRadiusCyclicCode@\texttt{UpperBoundCoveringRadiusCyclicCode}}
\label{UpperBoundCoveringRadiusCyclicCode}
}\hfill{\scriptsize (function)}}\\


 This function returns an upper bound for the covering radius of \mbox{\texttt{\mdseries\slshape C}}, which must be a cyclic code. It returns 
\[ n - k + 1 - \left\lceil \frac{w(g(x))}{2} \right\rceil, \]
 where $g(x)$ is the generator polynomial of \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:=CyclicCodes(15,GF(2))[3];|
  a cyclic [15,12,1..2]1..3 enumerated code over GF(2)
  !gapprompt@gap>| !gapinput@CoveringRadius(C);|
  3
  !gapprompt@gap>| !gapinput@UpperBoundCoveringRadiusCyclicCode(C);|
  3
  
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Special matrices in \textsf{GUAVA} }}\logpage{[ 7, 3, 0 ]}
\hyperdef{L}{X84F9246D84B9947A}{}
{
  \label{Special matrices in GUAVA} This section explains functions that work with special matrices \textsf{GUAVA} needs for several codes. 

 Firstly, we describe some matrix generating functions (see \texttt{KrawtchoukMat} (\ref{KrawtchoukMat}), \texttt{GrayMat} (\ref{GrayMat}), \texttt{SylvesterMat} (\ref{SylvesterMat}), \texttt{HadamardMat} (\ref{HadamardMat}) and \texttt{MOLS} (\ref{MOLS})). 

 Next we describe two functions regarding a standard form of matrices (see \texttt{PutStandardForm} (\ref{PutStandardForm}) and \texttt{IsInStandardForm} (\ref{IsInStandardForm})). 

 Then we describe functions that return a matrix after a manipulation (see \texttt{PermutedCols} (\ref{PermutedCols}), \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat}) and \texttt{HorizontalConversionFieldMat} (\ref{HorizontalConversionFieldMat})). 

 Finally, we describe functions that do some tests on matrices (see \texttt{IsLatinSquare} (\ref{IsLatinSquare}) and \texttt{AreMOLS} (\ref{AreMOLS})). 

\subsection{\textcolor{Chapter }{KrawtchoukMat}}
\logpage{[ 7, 3, 1 ]}\nobreak
\hyperdef{L}{X82899B64802A4BCE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KrawtchoukMat({\mdseries\slshape n, q})\index{KrawtchoukMat@\texttt{KrawtchoukMat}}
\label{KrawtchoukMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{KrawtchoukMat} returns the $n+1$ by $n+1$ matrix $K=(k_{ij})$ defined by $k_{ij}=K_i(j)$ for $i,j=0,...,n$. $K_i(j)$ is the Krawtchouk number (see \texttt{Krawtchouk} (\ref{Krawtchouk})). \mbox{\texttt{\mdseries\slshape n}} must be a positive integer and \mbox{\texttt{\mdseries\slshape q}} a prime power. The Krawtchouk matrix is used in the \emph{MacWilliams identities}, defining the relation between the weight distribution of a code of length \mbox{\texttt{\mdseries\slshape n}} over a field of size \mbox{\texttt{\mdseries\slshape q}}, and its dual code. Each call to \texttt{KrawtchoukMat} returns a new matrix, so it is safe to modify the result. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PrintArray( KrawtchoukMat( 3, 2 ) );|
  [ [   1,   1,   1,   1 ],
    [   3,   1,  -1,  -3 ],
    [   3,  -1,  -1,   3 ],
    [   1,  -1,   1,  -1 ] ]
  !gapprompt@gap>| !gapinput@C := HammingCode( 3 );; a := WeightDistribution( C );|
  [ 1, 0, 0, 7, 7, 0, 0, 1 ]
  !gapprompt@gap>| !gapinput@n := WordLength( C );; q := Size( LeftActingDomain( C ) );;|
  !gapprompt@gap>| !gapinput@k := Dimension( C );;|
  !gapprompt@gap>| !gapinput@q^( -k ) * KrawtchoukMat( n, q ) * a;|
  [ 1, 0, 0, 0, 7, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@WeightDistribution( DualCode( C ) );|
  [ 1, 0, 0, 0, 7, 0, 0, 0 ] 
\end{Verbatim}
  \index{Gary code} 

\subsection{\textcolor{Chapter }{GrayMat}}
\logpage{[ 7, 3, 2 ]}\nobreak
\hyperdef{L}{X87AFE2C078031CE4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GrayMat({\mdseries\slshape n, F})\index{GrayMat@\texttt{GrayMat}}
\label{GrayMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{GrayMat} returns a list of all different vectors (see GAP's \texttt{Vectors} command) of length \mbox{\texttt{\mdseries\slshape n}} over the field \mbox{\texttt{\mdseries\slshape F}}, using Gray ordering. \mbox{\texttt{\mdseries\slshape n}} must be a positive integer. This order has the property that subsequent
vectors differ in exactly one coordinate. The first vector is always the null
vector. Each call to \texttt{GrayMat} returns a new matrix, so it is safe to modify the result. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GrayMat(3);|
  [ [ 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0 ],
    [ 0*Z(2), Z(2)^0, Z(2)^0 ], [ 0*Z(2), Z(2)^0, 0*Z(2) ],
    [ Z(2)^0, Z(2)^0, 0*Z(2) ], [ Z(2)^0, Z(2)^0, Z(2)^0 ],
    [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2), 0*Z(2) ] ]
  !gapprompt@gap>| !gapinput@G := GrayMat( 4, GF(4) );; Length(G);|
  256          # the length of a GrayMat is always q^n
  !gapprompt@gap>| !gapinput@G[101] - G[100];|
  [ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{SylvesterMat}}
\logpage{[ 7, 3, 3 ]}\nobreak
\hyperdef{L}{X7E1E7C5287919CDB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SylvesterMat({\mdseries\slshape n})\index{SylvesterMat@\texttt{SylvesterMat}}
\label{SylvesterMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{SylvesterMat} returns the $n\times n$ Sylvester matrix of order \mbox{\texttt{\mdseries\slshape n}}. This is a special case of the Hadamard matrices (see \texttt{HadamardMat} (\ref{HadamardMat})). For this construction, \mbox{\texttt{\mdseries\slshape n}} must be a power of $2$. Each call to \texttt{SylvesterMat} returns a new matrix, so it is safe to modify the result. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PrintArray(SylvesterMat(2));|
  [ [   1,   1 ],
    [   1,  -1 ] ]
  !gapprompt@gap>| !gapinput@PrintArray( SylvesterMat(4) );|
  [ [   1,   1,   1,   1 ],
    [   1,  -1,   1,  -1 ],
    [   1,   1,  -1,  -1 ],
    [   1,  -1,  -1,   1 ] ] 
\end{Verbatim}
 \index{Hadamard matrix} 

\subsection{\textcolor{Chapter }{HadamardMat}}
\logpage{[ 7, 3, 4 ]}\nobreak
\hyperdef{L}{X8014A1F181ECD8AA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HadamardMat({\mdseries\slshape n})\index{HadamardMat@\texttt{HadamardMat}}
\label{HadamardMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{HadamardMat} returns a Hadamard matrix of order \mbox{\texttt{\mdseries\slshape n}}. This is an $n\times n$ matrix with the property that the matrix multiplied by its transpose returns \mbox{\texttt{\mdseries\slshape n}} times the identity matrix. This is only possible for $n=1, n=2$ or in cases where \mbox{\texttt{\mdseries\slshape n}} is a multiple of $4$. If the matrix does not exist or is not known (as of 1998), \texttt{HadamardMat} returns an error. A large number of construction methods is known to create
these matrices for different orders. \texttt{HadamardMat} makes use of two construction methods (the Paley Type I and II constructions,
and the Sylvester construction -- see \texttt{SylvesterMat} (\ref{SylvesterMat})). These methods cover most of the possible Hadamard matrices, although some
special algorithms have not been implemented yet. The following orders less
than $100$ do not yet have an implementation for a Hadamard matrix in \textsf{GUAVA}: $52, 92$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C := HadamardMat(8);; PrintArray(C);|
  [ [   1,   1,   1,   1,   1,   1,   1,   1 ],
    [   1,  -1,   1,  -1,   1,  -1,   1,  -1 ],
    [   1,   1,  -1,  -1,   1,   1,  -1,  -1 ],
    [   1,  -1,  -1,   1,   1,  -1,  -1,   1 ],
    [   1,   1,   1,   1,  -1,  -1,  -1,  -1 ],
    [   1,  -1,   1,  -1,  -1,   1,  -1,   1 ],
    [   1,   1,  -1,  -1,  -1,  -1,   1,   1 ],
    [   1,  -1,  -1,   1,  -1,   1,   1,  -1 ] ]
  !gapprompt@gap>| !gapinput@C * TransposedMat(C) = 8 * IdentityMat( 8, 8 );|
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{VandermondeMat}}
\logpage{[ 7, 3, 5 ]}\nobreak
\hyperdef{L}{X797F43607AD8660D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VandermondeMat({\mdseries\slshape X, a})\index{VandermondeMat@\texttt{VandermondeMat}}
\label{VandermondeMat}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{VandermondeMat} returns the $(a+1)\times n$ matrix of powers $x_i^j$ where \mbox{\texttt{\mdseries\slshape X}} is a list of elements of a field, $X=\{ x_1,...,x_n\}$, and \mbox{\texttt{\mdseries\slshape a}} is a non-negative integer. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M:=VandermondeMat([Z(5),Z(5)^2,Z(5)^0,Z(5)^3],2);|
  [ [ Z(5)^0, Z(5), Z(5)^2 ], [ Z(5)^0, Z(5)^2, Z(5)^0 ],
    [ Z(5)^0, Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5)^3, Z(5)^2 ] ]
  !gapprompt@gap>| !gapinput@Display(M);|
   1 2 4
   1 4 1
   1 1 1
   1 3 4
\end{Verbatim}
  \index{standard form} 

\subsection{\textcolor{Chapter }{PutStandardForm}}
\logpage{[ 7, 3, 6 ]}\nobreak
\hyperdef{L}{X7B47D82485B66F1D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PutStandardForm({\mdseries\slshape M[, idleft]})\index{PutStandardForm@\texttt{PutStandardForm}}
\label{PutStandardForm}
}\hfill{\scriptsize (function)}}\\


 We say that a $k\times n$ matrix is in \emph{standard form} if it is equal to the block matrix $(I\ |\ A)$, for some $k\times (n-k)$ matrix $A$ and where $I$ is the $k\times k$ identity matrix. It follows from a basis result in linear algebra that, after
a possible permutation of the columns, using elementary row operations, every
matrix can be reduced to standard form. \texttt{PutStandardForm} puts a matrix \mbox{\texttt{\mdseries\slshape M}} in standard form, and returns the permutation needed to do so. \mbox{\texttt{\mdseries\slshape idleft}} is a boolean that sets the position of the identity matrix in \mbox{\texttt{\mdseries\slshape M}}. (The default for \mbox{\texttt{\mdseries\slshape idleft}} is `true'.) If \mbox{\texttt{\mdseries\slshape idleft}} is set to `true', the identity matrix is put on the left side of \mbox{\texttt{\mdseries\slshape M}}. Otherwise, it is put at the right side. (This option is useful when putting
a check matrix of a code into standard form.) The function \texttt{BaseMat} also returns a similar standard form, but does not apply column permutations.
The rows of the matrix still span the same vector space after \texttt{BaseMat}, but after calling \texttt{PutStandardForm}, this is not necessarily true. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := Z(2)*[[1,0,0,1],[0,0,1,1]];; PrintArray(M);|
  [ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
    [  0*Z(2),  0*Z(2),    Z(2),    Z(2) ] ]
  !gapprompt@gap>| !gapinput@PutStandardForm(M);                   # identity at the left side|
  (2,3)
  !gapprompt@gap>| !gapinput@PrintArray(M);|
  [ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],
    [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]
  !gapprompt@gap>| !gapinput@PutStandardForm(M, false);            # identity at the right side|
  (1,4,3)
  !gapprompt@gap>| !gapinput@PrintArray(M);|
  [ [  0*Z(2),    Z(2),    Z(2),  0*Z(2) ],
    [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ]
  !gapprompt@gap>| !gapinput@C := BestKnownLinearCode( 23, 12, GF(2) );|
  a linear [23,12,7]3 punctured code
  !gapprompt@gap>| !gapinput@G:=MutableCopyMat(GeneratorMat(C));;|
  !gapprompt@gap>| !gapinput@PutStandardForm(G);|
  ()
  !gapprompt@gap>| !gapinput@Display(G);|
   1 . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1
   . 1 . . . . . . . . . . 1 1 1 1 1 . . 1 . . .
   . . 1 . . . . . . . . . 1 1 . 1 . . 1 . 1 . 1
   . . . 1 . . . . . . . . 1 1 . . . 1 1 1 . 1 .
   . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 . 1
   . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 1
   . . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1
   . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 . .
   . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 .
   . . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 .
   . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1 1
   . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsInStandardForm}}
\logpage{[ 7, 3, 7 ]}\nobreak
\hyperdef{L}{X7D4EDA0A854EBFEF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsInStandardForm({\mdseries\slshape M[, idleft]})\index{IsInStandardForm@\texttt{IsInStandardForm}}
\label{IsInStandardForm}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsInStandardForm} determines if \mbox{\texttt{\mdseries\slshape M}} is in standard form. \mbox{\texttt{\mdseries\slshape idleft}} is a boolean that indicates the position of the identity matrix in \mbox{\texttt{\mdseries\slshape M}}, as in \texttt{PutStandardForm} (see \texttt{PutStandardForm} (\ref{PutStandardForm})). \texttt{IsInStandardForm} checks if the identity matrix is at the left side of \mbox{\texttt{\mdseries\slshape M}}, otherwise if it is at the right side. The elements of \mbox{\texttt{\mdseries\slshape M}} may be elements of any field. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsInStandardForm(IdentityMat(7, GF(2)));|
  true
  !gapprompt@gap>| !gapinput@IsInStandardForm([[1, 1, 0], [1, 0, 1]], false);|
  true
  !gapprompt@gap>| !gapinput@IsInStandardForm([[1, 3, 2, 7]]);|
  true
  !gapprompt@gap>| !gapinput@IsInStandardForm(HadamardMat(4));|
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PermutedCols}}
\logpage{[ 7, 3, 8 ]}\nobreak
\hyperdef{L}{X7A97AD477E7638DE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PermutedCols({\mdseries\slshape M, P})\index{PermutedCols@\texttt{PermutedCols}}
\label{PermutedCols}
}\hfill{\scriptsize (function)}}\\


 \texttt{PermutedCols} returns a matrix \mbox{\texttt{\mdseries\slshape M}} with a permutation \mbox{\texttt{\mdseries\slshape P}} applied to its columns. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := [[1,2,3,4],[1,2,3,4]];; PrintArray(M);|
  [ [  1,  2,  3,  4 ],
    [  1,  2,  3,  4 ] ]
  !gapprompt@gap>| !gapinput@PrintArray(PermutedCols(M, (1,2,3)));|
  [ [  3,  1,  2,  4 ],
    [  3,  1,  2,  4 ] ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{VerticalConversionFieldMat}}
\logpage{[ 7, 3, 9 ]}\nobreak
\hyperdef{L}{X7B68119F85E9EC6D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VerticalConversionFieldMat({\mdseries\slshape M, F})\index{VerticalConversionFieldMat@\texttt{VerticalConversionFieldMat}}
\label{VerticalConversionFieldMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{VerticalConversionFieldMat} returns the matrix \mbox{\texttt{\mdseries\slshape M}} with its elements converted from a field $F=GF(q^m)$, $q$ prime, to a field $GF(q)$. Each element is replaced by its representation over the latter field, placed
vertically in the matrix, using the $GF(p)$-vector space isomorphism 
\[ [...] : GF(q)\rightarrow GF(p)^m, \]
 with $q=p^m$. 

 If \mbox{\texttt{\mdseries\slshape M}} is a $k$ by $n$ matrix, the result is a $k\cdot m \times n$ matrix, since each element of $GF(q^m)$ can be represented in $GF(q)$ using $m$ elements. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := Z(9)*[[1,2],[2,1]];; PrintArray(M);|
  [ [    Z(3^2),  Z(3^2)^5 ],
    [  Z(3^2)^5,    Z(3^2) ] ]
  !gapprompt@gap>| !gapinput@DefaultField( Flat(M) );|
  GF(3^2)
  !gapprompt@gap>| !gapinput@VCFM := VerticalConversionFieldMat( M, GF(9) );; PrintArray(VCFM);|
  [ [  0*Z(3),  0*Z(3) ],
    [  Z(3)^0,    Z(3) ],
    [  0*Z(3),  0*Z(3) ],
    [    Z(3),  Z(3)^0 ] ]
  !gapprompt@gap>| !gapinput@DefaultField( Flat(VCFM) );|
  GF(3) 
\end{Verbatim}
 A similar function is \texttt{HorizontalConversionFieldMat} (see \texttt{HorizontalConversionFieldMat} (\ref{HorizontalConversionFieldMat})). 

\subsection{\textcolor{Chapter }{HorizontalConversionFieldMat}}
\logpage{[ 7, 3, 10 ]}\nobreak
\hyperdef{L}{X8033E9A67BA155C8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HorizontalConversionFieldMat({\mdseries\slshape M, F})\index{HorizontalConversionFieldMat@\texttt{HorizontalConversionFieldMat}}
\label{HorizontalConversionFieldMat}
}\hfill{\scriptsize (function)}}\\


 \texttt{HorizontalConversionFieldMat} returns the matrix \mbox{\texttt{\mdseries\slshape M}} with its elements converted from a field $F=GF(q^m)$, $q$ prime, to a field $GF(q)$. Each element is replaced by its representation over the latter field, placed
horizontally in the matrix. 

 If \mbox{\texttt{\mdseries\slshape M}} is a $k \times n$ matrix, the result is a $k\times m\times n\cdot m$ matrix. The new word length of the resulting code is equal to $n\cdot m$, because each element of $GF(q^m)$ can be represented in $GF(q)$ using $m$ elements. The new dimension is equal to $k\times m$ because the new matrix should be a basis for the same number of vectors as the
old one. 

 \texttt{ConversionFieldCode} uses horizontal conversion to convert a code (see \texttt{ConversionFieldCode} (\ref{ConversionFieldCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := Z(9)*[[1,2],[2,1]];; PrintArray(M);|
  [ [    Z(3^2),  Z(3^2)^5 ],
    [  Z(3^2)^5,    Z(3^2) ] ]
  !gapprompt@gap>| !gapinput@DefaultField( Flat(M) );|
  GF(3^2)
  !gapprompt@gap>| !gapinput@HCFM := HorizontalConversionFieldMat(M, GF(9));; PrintArray(HCFM);|
  [ [  0*Z(3),  Z(3)^0,  0*Z(3),    Z(3) ],
    [  Z(3)^0,  Z(3)^0,    Z(3),    Z(3) ],
    [  0*Z(3),    Z(3),  0*Z(3),  Z(3)^0 ],
    [    Z(3),    Z(3),  Z(3)^0,  Z(3)^0 ] ]
  !gapprompt@gap>| !gapinput@DefaultField( Flat(HCFM) );|
  GF(3) 
\end{Verbatim}
 A similar function is \texttt{VerticalConversionFieldMat} (see \texttt{VerticalConversionFieldMat} (\ref{VerticalConversionFieldMat})). \index{mutually orthogonal Latin squares} \index{Latin square} 

\subsection{\textcolor{Chapter }{MOLS}}
\logpage{[ 7, 3, 11 ]}\nobreak
\hyperdef{L}{X804AAFF2867080F7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MOLS({\mdseries\slshape q[, n]})\index{MOLS@\texttt{MOLS}}
\label{MOLS}
}\hfill{\scriptsize (function)}}\\


 \texttt{MOLS} returns a list of \mbox{\texttt{\mdseries\slshape n}} \emph{Mutually Orthogonal Latin Squares} (MOLS). A \emph{Latin square} of order \mbox{\texttt{\mdseries\slshape q}} is a $q\times q$ matrix whose entries are from a set $F_{q}$ of \mbox{\texttt{\mdseries\slshape q}} distinct symbols (\textsf{GUAVA} uses the integers from $0$ to \mbox{\texttt{\mdseries\slshape q}}) such that each row and each column of the matrix contains each symbol
exactly once. 

 A set of Latin squares is a set of MOLS if and only if for each pair of Latin
squares in this set, every ordered pair of elements that are in the same
position in these matrices occurs exactly once. 

 \mbox{\texttt{\mdseries\slshape n}} must be less than \mbox{\texttt{\mdseries\slshape q}}. If \mbox{\texttt{\mdseries\slshape n}} is omitted, two MOLS are returned. If \mbox{\texttt{\mdseries\slshape q}} is not a prime power, at most $2$ MOLS can be created. For all values of \mbox{\texttt{\mdseries\slshape q}} with $q > 2$ and $q \neq 6$, a list of MOLS can be constructed. However, \textsf{GUAVA} does not yet construct MOLS for $q\equiv 2 \pmod 4$. If it is not possible to construct \mbox{\texttt{\mdseries\slshape n}} MOLS, the function returns `false'. 

 MOLS are used to create \mbox{\texttt{\mdseries\slshape q}}-ary codes (see \texttt{MOLSCode} (\ref{MOLSCode})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := MOLS( 4, 3 );;PrintArray( M[1] );|
  [ [  0,  1,  2,  3 ],
    [  1,  0,  3,  2 ],
    [  2,  3,  0,  1 ],
    [  3,  2,  1,  0 ] ]
  !gapprompt@gap>| !gapinput@PrintArray( M[2] );|
  [ [  0,  2,  3,  1 ],
    [  1,  3,  2,  0 ],
    [  2,  0,  1,  3 ],
    [  3,  1,  0,  2 ] ]
  !gapprompt@gap>| !gapinput@PrintArray( M[3] );|
  [ [  0,  3,  1,  2 ],
    [  1,  2,  0,  3 ],
    [  2,  1,  3,  0 ],
    [  3,  0,  2,  1 ] ]
  !gapprompt@gap>| !gapinput@MOLS( 12, 3 );|
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLatinSquare}}
\logpage{[ 7, 3, 12 ]}\nobreak
\hyperdef{L}{X7F34306B81DC2776}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLatinSquare({\mdseries\slshape M})\index{IsLatinSquare@\texttt{IsLatinSquare}}
\label{IsLatinSquare}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsLatinSquare} determines if a matrix \mbox{\texttt{\mdseries\slshape M}} is a Latin square. For a Latin square of size $n\times n$, each row and each column contains all the integers $1,\dots,n$ exactly once. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsLatinSquare([[1,2],[2,1]]);|
  true
  !gapprompt@gap>| !gapinput@IsLatinSquare([[1,2,3],[2,3,1],[1,3,2]]);|
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AreMOLS}}
\logpage{[ 7, 3, 13 ]}\nobreak
\hyperdef{L}{X81B9B40B7B2D97D5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AreMOLS({\mdseries\slshape L})\index{AreMOLS@\texttt{AreMOLS}}
\label{AreMOLS}
}\hfill{\scriptsize (function)}}\\


 \texttt{AreMOLS} determines if \mbox{\texttt{\mdseries\slshape L}} is a list of mutually orthogonal Latin squares (MOLS). For each pair of Latin
squares in this list, the function checks if each ordered pair of elements
that are in the same position in these matrices occurs exactly once. The
function \texttt{MOLS} creates MOLS (see \texttt{MOLS} (\ref{MOLS})). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@M := MOLS(4,2);|
  [ [ [ 0, 1, 2, 3 ], [ 1, 0, 3, 2 ], [ 2, 3, 0, 1 ], [ 3, 2, 1, 0 ] ],
    [ [ 0, 2, 3, 1 ], [ 1, 3, 2, 0 ], [ 2, 0, 1, 3 ], [ 3, 1, 0, 2 ] ] ]
  !gapprompt@gap>| !gapinput@AreMOLS(M);|
  true 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Some functions related to the norm of a code }}\logpage{[ 7, 4, 0 ]}
\hyperdef{L}{X7AB5E5CE7FDF7132}{}
{
  \label{Some functions related to the norm of a code} In this section, some functions that can be used to compute the norm of a code
and to decide upon its normality are discussed. Typically, these are applied
to binary linear codes. The definitions of this section were introduced in
Graham and Sloane \cite{GS85}. 

\subsection{\textcolor{Chapter }{CoordinateNorm}}
\logpage{[ 7, 4, 1 ]}\nobreak
\hyperdef{L}{X8032E53078264ABB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoordinateNorm({\mdseries\slshape C, coord})\index{CoordinateNorm@\texttt{CoordinateNorm}}
\label{CoordinateNorm}
}\hfill{\scriptsize (function)}}\\


 \texttt{CoordinateNorm} returns the norm of \mbox{\texttt{\mdseries\slshape C}} with respect to coordinate \mbox{\texttt{\mdseries\slshape coord}}. If $C_a = \{ c \in C \ |\ c_{coord} = a \}$, then the norm of \mbox{\texttt{\mdseries\slshape C}} with respect to \mbox{\texttt{\mdseries\slshape coord}} is defined as 
\[ \max_{v \in GF(q)^n} \sum_{a=1}^q d(x,C_a), \]
 with the convention that $d(x,C_a) = n$ if $C_a$ is empty. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CoordinateNorm( HammingCode( 3, GF(2) ), 3 );|
  3 
\end{Verbatim}
 \index{norm of a code} 

\subsection{\textcolor{Chapter }{CodeNorm}}
\logpage{[ 7, 4, 2 ]}\nobreak
\hyperdef{L}{X7ED2EF368203AF47}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CodeNorm({\mdseries\slshape C})\index{CodeNorm@\texttt{CodeNorm}}
\label{CodeNorm}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeNorm} returns the norm of \mbox{\texttt{\mdseries\slshape C}}. The \emph{norm} of a code is defined as the minimum of the norms for the respective
coordinates of the code. In effect, for each coordinate \texttt{CoordinateNorm} is called, and the minimum of the calculated numbers is returned. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CodeNorm( HammingCode( 3, GF(2) ) );|
  3 
\end{Verbatim}
 \index{acceptable coordinate} 

\subsection{\textcolor{Chapter }{IsCoordinateAcceptable}}
\logpage{[ 7, 4, 3 ]}\nobreak
\hyperdef{L}{X7D24F8BF7F9A7BF1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCoordinateAcceptable({\mdseries\slshape C, coord})\index{IsCoordinateAcceptable@\texttt{IsCoordinateAcceptable}}
\label{IsCoordinateAcceptable}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsCoordinateAcceptable} returns `true' if coordinate \mbox{\texttt{\mdseries\slshape coord}} of \mbox{\texttt{\mdseries\slshape C}} is acceptable. A coordinate is called \emph{acceptable} if the norm of the code with respect to that coordinate is not more than two
times the covering radius of the code plus one. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsCoordinateAcceptable( HammingCode( 3, GF(2) ), 3 );|
  true 
\end{Verbatim}
 \index{acceptable coordinate} 

\subsection{\textcolor{Chapter }{GeneralizedCodeNorm}}
\logpage{[ 7, 4, 4 ]}\nobreak
\hyperdef{L}{X87039FD179AD3009}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneralizedCodeNorm({\mdseries\slshape C, subcode1, subscode2, ..., subcodek})\index{GeneralizedCodeNorm@\texttt{GeneralizedCodeNorm}}
\label{GeneralizedCodeNorm}
}\hfill{\scriptsize (function)}}\\


 \texttt{GeneralizedCodeNorm} returns the \mbox{\texttt{\mdseries\slshape k}}-norm of \mbox{\texttt{\mdseries\slshape C}} with respect to \mbox{\texttt{\mdseries\slshape k}} subcodes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c := RepetitionCode( 7, GF(2) );;|
  !gapprompt@gap>| !gapinput@ham := HammingCode( 3, GF(2) );;|
  !gapprompt@gap>| !gapinput@d := EvenWeightSubcode( ham );;|
  !gapprompt@gap>| !gapinput@e := ConstantWeightSubcode( ham, 3 );;|
  !gapprompt@gap>| !gapinput@GeneralizedCodeNorm( ham, c, d, e );|
  4 
\end{Verbatim}
 \index{normal code} 

\subsection{\textcolor{Chapter }{IsNormalCode}}
\logpage{[ 7, 4, 5 ]}\nobreak
\hyperdef{L}{X80283A2F7C8101BD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNormalCode({\mdseries\slshape C})\index{IsNormalCode@\texttt{IsNormalCode}}
\label{IsNormalCode}
}\hfill{\scriptsize (function)}}\\


 \texttt{IsNormalCode} returns `true' if \mbox{\texttt{\mdseries\slshape C}} is normal. A code is called \emph{normal} if the norm of the code is not more than two times the covering radius of the
code plus one. Almost all codes are normal, however some (non-linear) abnormal
codes have been found. 

 Often, it is difficult to find out whether a code is normal, because it
involves computing the covering radius. However, \texttt{IsNormalCode} uses much information from the literature (in particular, \cite{GS85}) about normality for certain code parameters. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsNormalCode( HammingCode( 3, GF(2) ) );|
  true 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Miscellaneous functions }}\logpage{[ 7, 5, 0 ]}
\hyperdef{L}{X8308D685809A4E2F}{}
{
  \label{Miscellaneous functions} In this section we describe several vector space functions \textsf{GUAVA} uses for constructing codes or performing calculations with codes. 

 In this section, some new miscellaneous functions are described, including
weight enumerators, the MacWilliams-transform and affinity and almost affinity
of codes. \index{weight enumerator polynomial} 

\subsection{\textcolor{Chapter }{CodeWeightEnumerator}}
\logpage{[ 7, 5, 1 ]}\nobreak
\hyperdef{L}{X871286437DE7A6A4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CodeWeightEnumerator({\mdseries\slshape C})\index{CodeWeightEnumerator@\texttt{CodeWeightEnumerator}}
\label{CodeWeightEnumerator}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeWeightEnumerator} returns a polynomial of the following form: 
\[ f(x) = \sum_{i=0}^{n} A_i x^i, \]
 where $A_i$ is the number of codewords in \mbox{\texttt{\mdseries\slshape C}} with weight $i$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CodeWeightEnumerator( ElementsCode( [ [ 0,0,0 ], [ 0,0,1 ],|
  !gapprompt@>| !gapinput@[ 0,1,1 ], [ 1,1,1 ] ], GF(2) ) );|
  x^3 + x^2 + x + 1
  !gapprompt@gap>| !gapinput@CodeWeightEnumerator( HammingCode( 3, GF(2) ) );|
  x^7 + 7*x^4 + 7*x^3 + 1 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CodeDistanceEnumerator}}
\logpage{[ 7, 5, 2 ]}\nobreak
\hyperdef{L}{X84DA928083B103A0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CodeDistanceEnumerator({\mdseries\slshape C, w})\index{CodeDistanceEnumerator@\texttt{CodeDistanceEnumerator}}
\label{CodeDistanceEnumerator}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeDistanceEnumerator} returns a polynomial of the following form: 
\[ f(x) = \sum_{i=0}^{n} B_i x^i, \]
 where $B_i$ is the number of codewords with distance $i$ to \mbox{\texttt{\mdseries\slshape w}}. 

 If \mbox{\texttt{\mdseries\slshape w}} is a codeword, then \texttt{CodeDistanceEnumerator} returns the same polynomial as \texttt{CodeWeightEnumerator}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CodeDistanceEnumerator( HammingCode( 3, GF(2) ),[0,0,0,0,0,0,1] );|
  x^6 + 3*x^5 + 4*x^4 + 4*x^3 + 3*x^2 + x
  !gapprompt@gap>| !gapinput@CodeDistanceEnumerator( HammingCode( 3, GF(2) ),[1,1,1,1,1,1,1] );|
  x^7 + 7*x^4 + 7*x^3 + 1 # `[1,1,1,1,1,1,1]' $\in$ `HammingCode( 3, GF(2 ) )'
\end{Verbatim}
 \index{MacWilliams transform} 

\subsection{\textcolor{Chapter }{CodeMacWilliamsTransform}}
\logpage{[ 7, 5, 3 ]}\nobreak
\hyperdef{L}{X84B2BE66780EFBF9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CodeMacWilliamsTransform({\mdseries\slshape C})\index{CodeMacWilliamsTransform@\texttt{CodeMacWilliamsTransform}}
\label{CodeMacWilliamsTransform}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeMacWilliamsTransform} returns a polynomial of the following form: 
\[ f(x) = \sum_{i=0}^{n} C_i x^i, \]
 where $C_i$ is the number of codewords with weight $i$ in the \emph{dual} code of \mbox{\texttt{\mdseries\slshape C}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CodeMacWilliamsTransform( HammingCode( 3, GF(2) ) );|
  7*x^4 + 1 
\end{Verbatim}
 \index{density of a code} 

\subsection{\textcolor{Chapter }{CodeDensity}}
\logpage{[ 7, 5, 4 ]}\nobreak
\hyperdef{L}{X7903286078F8051B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CodeDensity({\mdseries\slshape C})\index{CodeDensity@\texttt{CodeDensity}}
\label{CodeDensity}
}\hfill{\scriptsize (function)}}\\


 \texttt{CodeDensity} returns the \emph{density} of \mbox{\texttt{\mdseries\slshape C}}. The density of a code is defined as 
\[ \frac{M \cdot V_q(n,t)}{q^n}, \]
 where $M$ is the size of the code, $V_q(n,t)$ is the size of a sphere of radius $t$ in $GF(q^n)$ (which may be computed using \texttt{SphereContent}), $t$ is the covering radius of the code and $n$ is the length of the code. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CodeDensity( HammingCode( 3, GF(2) ) );|
  1
  !gapprompt@gap>| !gapinput@CodeDensity( ReedMullerCode( 1, 4 ) );|
  14893/2048 
\end{Verbatim}
 \index{perfect code} 

\subsection{\textcolor{Chapter }{SphereContent}}
\logpage{[ 7, 5, 5 ]}\nobreak
\hyperdef{L}{X85303BAE7BD46D81}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SphereContent({\mdseries\slshape n, t, F})\index{SphereContent@\texttt{SphereContent}}
\label{SphereContent}
}\hfill{\scriptsize (function)}}\\


 \texttt{SphereContent} returns the content of a ball of radius \mbox{\texttt{\mdseries\slshape t}} around an arbitrary element of the vectorspace $F^n$. This is the cardinality of the set of all elements of $F^n$ that are at distance (see \texttt{DistanceCodeword} (\ref{DistanceCodeword}) less than or equal to \mbox{\texttt{\mdseries\slshape t}} from an element of $F^n$. 

 In the context of codes, the function is used to determine if a code is
perfect. A code is \emph{perfect} if spheres of radius $t$ around all codewords partition the whole ambient vector space, where \emph{t} is the number of errors the code can correct. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SphereContent( 15, 0, GF(2) );|
  1    # Only one word with distance 0, which is the word itself
  !gapprompt@gap>| !gapinput@SphereContent( 11, 3, GF(4) );|
  4984
  !gapprompt@gap>| !gapinput@C := HammingCode(5);|
  a linear [31,26,3]1 Hamming (5,2) code over GF(2)
  #the minimum distance is 3, so the code can correct one error
  !gapprompt@gap>| !gapinput@( SphereContent( 31, 1, GF(2) ) * Size(C) ) = 2 ^ 31;|
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Krawtchouk}}
\logpage{[ 7, 5, 6 ]}\nobreak
\hyperdef{L}{X7ACDC5377CD17451}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Krawtchouk({\mdseries\slshape k, i, n, q})\index{Krawtchouk@\texttt{Krawtchouk}}
\label{Krawtchouk}
}\hfill{\scriptsize (function)}}\\


 \texttt{Krawtchouk} returns the Krawtchouk number $K_{k}(i)$. \mbox{\texttt{\mdseries\slshape q}} must be a prime power, \mbox{\texttt{\mdseries\slshape n}} must be a positive integer, \mbox{\texttt{\mdseries\slshape k}} must be a non-negative integer less then or equal to \mbox{\texttt{\mdseries\slshape n}} and \mbox{\texttt{\mdseries\slshape i}} can be any integer. (See \texttt{KrawtchoukMat} (\ref{KrawtchoukMat})). This number is the value at $x=i$ of the polynomial 
\[ K_k^{n,q}(x) =\sum_{j=0}^n (-1)^j(q-1)^{k-j}b(x,j)b(n-x,k-j), \]
 where \$b(v,u)=u!/(v!(v-u)!)\$ is the binomial coefficient if \$u,v\$ are
integers. For more properties of these polynomials, see \cite{MS83}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Krawtchouk( 2, 0, 3, 2);|
  3 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PrimitiveUnityRoot}}
\logpage{[ 7, 5, 7 ]}\nobreak
\hyperdef{L}{X827E39957A87EB51}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrimitiveUnityRoot({\mdseries\slshape F, n})\index{PrimitiveUnityRoot@\texttt{PrimitiveUnityRoot}}
\label{PrimitiveUnityRoot}
}\hfill{\scriptsize (function)}}\\


 \texttt{PrimitiveUnityRoot} returns a primitive \mbox{\texttt{\mdseries\slshape n}}-th root of unity in an extension field of \mbox{\texttt{\mdseries\slshape F}}. This is a finite field element $a$ with the property $a^n=1$ in \mbox{\texttt{\mdseries\slshape F}}, and \mbox{\texttt{\mdseries\slshape n}} is the smallest integer such that this equality holds. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PrimitiveUnityRoot( GF(2), 15 );|
  Z(2^4)
  !gapprompt@gap>| !gapinput@last^15;|
  Z(2)^0
  !gapprompt@gap>| !gapinput@PrimitiveUnityRoot( GF(8), 21 );|
  Z(2^6)^3 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PrimitivePolynomialsNr}}
\logpage{[ 7, 5, 8 ]}\nobreak
\hyperdef{L}{X78AEA40F7AD9D541}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrimitivePolynomialsNr({\mdseries\slshape n, F})\index{PrimitivePolynomialsNr@\texttt{PrimitivePolynomialsNr}}
\label{PrimitivePolynomialsNr}
}\hfill{\scriptsize (function)}}\\


 \texttt{PrimitivePolynomialsNr} returns the number of irreducible polynomials over $F=GF(q)$ of degree \mbox{\texttt{\mdseries\slshape n}} with (maximum) period $q^n-1$. (According to a theorem of S. Golomb, this is $\phi(p^n-1)/n$.) 

 See also the GAP function \texttt{RandomPrimitivePolynomial}, \texttt{RandomPrimitivePolynomial} (\ref{RandomPrimitivePolynomial}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PrimitivePolynomialsNr(3,4);|
  12
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IrreduciblePolynomialsNr}}
\logpage{[ 7, 5, 9 ]}\nobreak
\hyperdef{L}{X7A2B54EF868AA752}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IrreduciblePolynomialsNr({\mdseries\slshape n, F})\index{IrreduciblePolynomialsNr@\texttt{IrreduciblePolynomialsNr}}
\label{IrreduciblePolynomialsNr}
}\hfill{\scriptsize (function)}}\\


 \texttt{PrimitivePolynomialsNr} returns the number of irreducible polynomials over $F=GF(q)$ of degree \mbox{\texttt{\mdseries\slshape n}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IrreduciblePolynomialsNr(3,4);|
  20
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{MatrixRepresentationOfElement}}
\logpage{[ 7, 5, 10 ]}\nobreak
\hyperdef{L}{X7B50D3417F6FD7C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MatrixRepresentationOfElement({\mdseries\slshape a, F})\index{MatrixRepresentationOfElement@\texttt{MatrixRepresentationOfElement}}
\label{MatrixRepresentationOfElement}
}\hfill{\scriptsize (function)}}\\


 Here \mbox{\texttt{\mdseries\slshape F}} is either a finite extension of the ``base field'' $GF(p)$ or of the rationals ${\mathbb{Q}}$, and $a\in F$. The command \texttt{MatrixRepresentationOfElement} returns a matrix representation of \mbox{\texttt{\mdseries\slshape a}} over the base field. 

 If the element \mbox{\texttt{\mdseries\slshape a}} is defined over the base field then it returns the corresponding $1\times 1$ matrix. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a:=Random(GF(4));|
  0*Z(2)
  !gapprompt@gap>| !gapinput@M:=MatrixRepresentationOfElement(a,GF(4));; Display(M);|
   .
  !gapprompt@gap>| !gapinput@a:=Random(GF(4));|
  Z(2^2)
  !gapprompt@gap>| !gapinput@M:=MatrixRepresentationOfElement(a,GF(4));; Display(M);|
   . 1
   1 1
  gap>
  
\end{Verbatim}
  \index{reciprocal polynomial} 

\subsection{\textcolor{Chapter }{ReciprocalPolynomial}}
\logpage{[ 7, 5, 11 ]}\nobreak
\hyperdef{L}{X7805D2BB7CE4D455}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ReciprocalPolynomial({\mdseries\slshape P})\index{ReciprocalPolynomial@\texttt{ReciprocalPolynomial}}
\label{ReciprocalPolynomial}
}\hfill{\scriptsize (function)}}\\


 \texttt{ReciprocalPolynomial} returns the \emph{reciprocal} of polynomial \mbox{\texttt{\mdseries\slshape P}}. This is a polynomial with coefficients of \mbox{\texttt{\mdseries\slshape P}} in the reverse order. So if $P=a_0 + a_1 X + ... + a_{n} X^{n}$, the reciprocal polynomial is $P'=a_{n} + a_{n-1} X + ... + a_0 X^{n}$. 

 This command can also be called using the syntax \texttt{ReciprocalPolynomial( P , n )}. In this form, the number of coefficients of \mbox{\texttt{\mdseries\slshape P}} is assumed to be less than or equal to $n+1$ (with zero coefficients added in the highest degrees, if necessary).
Therefore, the reciprocal polynomial also has degree $n+1$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );|
  Z(3)^0+x_1^2-x_1^3
  !gapprompt@gap>| !gapinput@RecP := ReciprocalPolynomial( P );|
  -Z(3)^0+x_1+x_1^3
  !gapprompt@gap>| !gapinput@ReciprocalPolynomial( RecP ) = P;|
  true 
  !gapprompt@gap>| !gapinput@P := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );|
  Z(3)^0+x_1^2-x_1^3
  !gapprompt@gap>| !gapinput@ReciprocalPolynomial( P, 6 );|
  -x_1^3+x_1^4+x_1^6
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CyclotomicCosets}}
\logpage{[ 7, 5, 12 ]}\nobreak
\hyperdef{L}{X7AEA9F807E6FFEFF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CyclotomicCosets({\mdseries\slshape q, n})\index{CyclotomicCosets@\texttt{CyclotomicCosets}}
\label{CyclotomicCosets}
}\hfill{\scriptsize (function)}}\\


 \texttt{CyclotomicCosets} returns the cyclotomic cosets of $q \pmod n$. \mbox{\texttt{\mdseries\slshape q}} and \mbox{\texttt{\mdseries\slshape n}} must be relatively prime. Each of the elements of the returned list is a list
of integers that belong to one cyclotomic coset. A $q$-cyclotomic coset of $s \pmod n$ is a set of the form $\{s,sq,sq^2,...,sq^{r-1}\}$, where $r$ is the smallest positive integer such that $sq^r-s$ is $0 \pmod n$. In other words, each coset contains all multiplications of the coset
representative by $q \pmod n$. The coset representative is the smallest integer that isn't in the previous
cosets. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CyclotomicCosets( 2, 15 );|
  [ [ 0 ], [ 1, 2, 4, 8 ], [ 3, 6, 12, 9 ], [ 5, 10 ],
    [ 7, 14, 13, 11 ] ]
  !gapprompt@gap>| !gapinput@CyclotomicCosets( 7, 6 );|
  [ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{WeightHistogram}}
\logpage{[ 7, 5, 13 ]}\nobreak
\hyperdef{L}{X7A4EA98D794CF410}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeightHistogram({\mdseries\slshape C[, h]})\index{WeightHistogram@\texttt{WeightHistogram}}
\label{WeightHistogram}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{WeightHistogram} plots a histogram of weights in code \mbox{\texttt{\mdseries\slshape C}}. The maximum length of a column is \mbox{\texttt{\mdseries\slshape h}}. Default value for \mbox{\texttt{\mdseries\slshape h}} is $1/3$ of the size of the screen. The number that appears at the top of the histogram
is the maximum value of the list of weights. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H := HammingCode(2, GF(5));|
  a linear [6,4,3]1 Hamming (2,5) code over GF(5)
  !gapprompt@gap>| !gapinput@WeightDistribution(H);|
  [ 1, 0, 0, 80, 120, 264, 160 ]
  !gapprompt@gap>| !gapinput@WeightHistogram(H);|
  264----------------
                 *
                 *
                 *
                 *
                 *  *
              *  *  *
           *  *  *  *
           *  *  *  *
  +--------+--+--+--+--
  0  1  2  3  4  5  6 
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MultiplicityInList}}
\logpage{[ 7, 5, 14 ]}\nobreak
\hyperdef{L}{X805DF25C84585FD6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MultiplicityInList({\mdseries\slshape L, a})\index{MultiplicityInList@\texttt{MultiplicityInList}}
\label{MultiplicityInList}
}\hfill{\scriptsize (function)}}\\


 This is a very simple list command which returns how many times a occurs in L.
It returns 0 if a is not in L. (The GAP command \texttt{Collected} does not quite handle this "extreme" case.) }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:=[1,2,3,4,3,2,1,5,4,3,2,1];;|
  !gapprompt@gap>| !gapinput@MultiplicityInList(L,1);|
  3
  !gapprompt@gap>| !gapinput@MultiplicityInList(L,6);|
  0
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{MostCommonInList}}
\logpage{[ 7, 5, 15 ]}\nobreak
\hyperdef{L}{X8072B0DA78FBE562}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MostCommonInList({\mdseries\slshape L})\index{MostCommonInList@\texttt{MostCommonInList}}
\label{MostCommonInList}
}\hfill{\scriptsize (function)}}\\


 Input: a list L 

 Output: an a in L which occurs at least as much as any other in L }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:=[1,2,3,4,3,2,1,5,4,3,2,1];;|
  !gapprompt@gap>| !gapinput@MostCommonInList(L);|
  1
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{RotateList}}
\logpage{[ 7, 5, 16 ]}\nobreak
\hyperdef{L}{X7C5407EF87849857}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RotateList({\mdseries\slshape L})\index{RotateList@\texttt{RotateList}}
\label{RotateList}
}\hfill{\scriptsize (function)}}\\


 Input: a list L 

 Output: a list L' which is the cyclic rotation of L (to the right) }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:=[1,2,3,4];;|
  !gapprompt@gap>| !gapinput@RotateList(L);|
  [2,3,4,1]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CirculantMatrix}}
\logpage{[ 7, 5, 17 ]}\nobreak
\hyperdef{L}{X85E526367878F72A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CirculantMatrix({\mdseries\slshape k, L})\index{CirculantMatrix@\texttt{CirculantMatrix}}
\label{CirculantMatrix}
}\hfill{\scriptsize (function)}}\\


 Input: integer k, a list L of length n 

 Output: kxn matrix whose rows are cyclic rotations of the list L }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@k:=3; L:=[1,2,3,4];;|
  !gapprompt@gap>| !gapinput@M:=CirculantMatrix(k,L);;|
  !gapprompt@gap>| !gapinput@Display(M);|
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Miscellaneous polynomial functions }}\logpage{[ 7, 6, 0 ]}
\hyperdef{L}{X7969103F7A8598F9}{}
{
  \label{Miscellaneous polynomial functions} In this section we describe several multivariate polynomial GAP functions \textsf{GUAVA} uses for constructing codes or performing calculations with codes. 

\subsection{\textcolor{Chapter }{MatrixTransformationOnMultivariatePolynomial }}
\logpage{[ 7, 6, 1 ]}\nobreak
\hyperdef{L}{X84D51EBB784E7C5D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MatrixTransformationOnMultivariatePolynomial ({\mdseries\slshape A, f, R})\index{MatrixTransformationOnMultivariatePolynomial @\texttt{Matrix}\-\texttt{Transformation}\-\texttt{On}\-\texttt{Multivariate}\-\texttt{Polynomial }}
\label{MatrixTransformationOnMultivariatePolynomial }
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape A}} is an $n\times n$ matrix with entries in a field $F$, \mbox{\texttt{\mdseries\slshape R}} is a polynomial ring of $n$ variables, say $F[x_1,...,x_n]$, and \mbox{\texttt{\mdseries\slshape f}} is a polynomial in \mbox{\texttt{\mdseries\slshape R}}. Returns the composition $f\circ A$. }

 

\subsection{\textcolor{Chapter }{DegreeMultivariatePolynomial}}
\logpage{[ 7, 6, 2 ]}\nobreak
\hyperdef{L}{X80433A4B792880EF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreeMultivariatePolynomial({\mdseries\slshape f, R})\index{DegreeMultivariatePolynomial@\texttt{DegreeMultivariatePolynomial}}
\label{DegreeMultivariatePolynomial}
}\hfill{\scriptsize (function)}}\\


 This command takes two arguments, \mbox{\texttt{\mdseries\slshape f}}, a multivariate polynomial, and \mbox{\texttt{\mdseries\slshape R}} a polynomial ring over a field $F$ containing \mbox{\texttt{\mdseries\slshape f}}, say $R=F[x_1,x_2,...,x_n]$. The output is simply the maximum degrees of all the monomials occurring in \mbox{\texttt{\mdseries\slshape f}}. 

 This command can be used to compute the degree of an affine plane curve. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,2);|
  PolynomialRing(..., [ x_1, x_2 ])
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R2);;|
  !gapprompt@gap>| !gapinput@x:=vars[1];; y:=vars[2];;|
  !gapprompt@gap>| !gapinput@poly:=y^2-x*(x^2-1);;|
  !gapprompt@gap>| !gapinput@DegreeMultivariatePolynomial(poly,R2);|
  3
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DegreesMultivariatePolynomial}}
\logpage{[ 7, 6, 3 ]}\nobreak
\hyperdef{L}{X83F44E397C56F2E0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreesMultivariatePolynomial({\mdseries\slshape f, R})\index{DegreesMultivariatePolynomial@\texttt{DegreesMultivariatePolynomial}}
\label{DegreesMultivariatePolynomial}
}\hfill{\scriptsize (function)}}\\


 Returns a list of information about the multivariate polynomial \mbox{\texttt{\mdseries\slshape f}}. Nice for other programs but mostly unreadable by GAP users. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,2);|
  PolynomialRing(..., [ x_1, x_2 ])
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R2);;|
  !gapprompt@gap>| !gapinput@x:=vars[1];; y:=vars[2];;|
  !gapprompt@gap>| !gapinput@poly:=y^2-x*(x^2-1);;|
  !gapprompt@gap>| !gapinput@DegreesMultivariatePolynomial(poly,R2);|
  [ [ [ x_1, x_1, 1 ], [ x_1, x_2, 0 ] ], [ [ x_2^2, x_1, 0 ], [ x_2^2, x_2, 2 ] ],
    [ [ x_1^3, x_1, 3 ], [ x_1^3, x_2, 0 ] ] ]
  gap>
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CoefficientMultivariatePolynomial}}
\logpage{[ 7, 6, 4 ]}\nobreak
\hyperdef{L}{X7E9021697A61A60F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoefficientMultivariatePolynomial({\mdseries\slshape f, var, power, R})\index{CoefficientMultivariatePolynomial@\texttt{CoefficientMultivariatePolynomial}}
\label{CoefficientMultivariatePolynomial}
}\hfill{\scriptsize (function)}}\\


 The command \texttt{CoefficientMultivariatePolynomial} takes four arguments: a multivariant polynomial \mbox{\texttt{\mdseries\slshape f}}, a variable name \mbox{\texttt{\mdseries\slshape var}}, an integer \mbox{\texttt{\mdseries\slshape power}}, and a polynomial ring \mbox{\texttt{\mdseries\slshape R}} containing \mbox{\texttt{\mdseries\slshape f}}. For example, if \mbox{\texttt{\mdseries\slshape f}} is a multivariate polynomial in $R$ = $F$[$x_1,x_2,...,x_n$] then \mbox{\texttt{\mdseries\slshape var}} must be one of the $x_i$. The output is the coefficient of $x_i^{power}$ in \mbox{\texttt{\mdseries\slshape f}}. 

 (Not sure if $F$ needs to be a field in fact ...) 

 Related to the GAP command \texttt{PolynomialCoefficientsPolynomial}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,2);|
  PolynomialRing(..., [ x_1, x_2 ])
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R2);;|
  !gapprompt@gap>| !gapinput@x:=vars[1];; y:=vars[2];;|
  !gapprompt@gap>| !gapinput@poly:=y^2-x*(x^2-1);;|
  !gapprompt@gap>| !gapinput@PolynomialCoefficientsOfPolynomial(poly,x);|
  [ x_2^2, Z(11)^0, 0*Z(11), -Z(11)^0 ]
  !gapprompt@gap>| !gapinput@PolynomialCoefficientsOfPolynomial(poly,y);|
  [ -x_1^3+x_1, 0*Z(11), Z(11)^0 ]
  !gapprompt@gap>| !gapinput@CoefficientMultivariatePolynomial(poly,y,0,R2);|
  -x_1^3+x_1
  !gapprompt@gap>| !gapinput@CoefficientMultivariatePolynomial(poly,y,1,R2);|
  0*Z(11)
  !gapprompt@gap>| !gapinput@CoefficientMultivariatePolynomial(poly,y,2,R2);|
  Z(11)^0
  !gapprompt@gap>| !gapinput@CoefficientMultivariatePolynomial(poly,x,0,R2);|
  x_2^2
  !gapprompt@gap>| !gapinput@CoefficientMultivariatePolynomial(poly,x,1,R2);|
  Z(11)^0
  !gapprompt@gap>| !gapinput@CoefficientMultivariatePolynomial(poly,x,2,R2);|
  0*Z(11)
  !gapprompt@gap>| !gapinput@CoefficientMultivariatePolynomial(poly,x,3,R2);|
  -Z(11)^0
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{SolveLinearSystem}}
\logpage{[ 7, 6, 5 ]}\nobreak
\hyperdef{L}{X79E76B6F7D177E27}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SolveLinearSystem({\mdseries\slshape L, vars})\index{SolveLinearSystem@\texttt{SolveLinearSystem}}
\label{SolveLinearSystem}
}\hfill{\scriptsize (function)}}\\


 Input: \mbox{\texttt{\mdseries\slshape L}} is a list of linear forms in the variables \mbox{\texttt{\mdseries\slshape vars}}. 

 Output: the solution of the system, if its unique. 

 The procedure is straightforward: Find the associated matrix $A$, find the "constant vector" $b$, and solve $A*v=b$. No error checking is performed. 

 Related to the GAP command \texttt{SolutionMat( A, b )}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);;|
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,2);|
  PolynomialRing(..., [ x_1, x_2 ])
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R2);;|
  !gapprompt@gap>| !gapinput@x:=vars[1];; y:=vars[2];;|
  !gapprompt@gap>| !gapinput@f:=3*y-3*x+1;; g:=-5*y+2*x-7;;|
  !gapprompt@gap>| !gapinput@soln:=SolveLinearSystem([f,g],[x,y]);|
  [ Z(11)^3, Z(11)^2 ]
  !gapprompt@gap>| !gapinput@Value(f,[x,y],soln); # checking okay|
  0*Z(11)
  !gapprompt@gap>| !gapinput@Value(g,[x,y],col); # checking okay|
  0*Z(11)
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GuavaVersion}}
\logpage{[ 7, 6, 6 ]}\nobreak
\hyperdef{L}{X80171AA687FFDC70}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GuavaVersion({\mdseries\slshape })\index{GuavaVersion@\texttt{GuavaVersion}}
\label{GuavaVersion}
}\hfill{\scriptsize (function)}}\\


 Returns the current version of Guava. Same as \texttt{guava\texttt{\symbol{92}}{\textunderscore}version()}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GuavaVersion();|
  "3.11"
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{ZechLog}}
\logpage{[ 7, 6, 7 ]}\nobreak
\hyperdef{L}{X7EBBE86D85CC90C0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZechLog({\mdseries\slshape x, b, F})\index{ZechLog@\texttt{ZechLog}}
\label{ZechLog}
}\hfill{\scriptsize (function)}}\\


 Returns the Zech log of x to base b, ie the i such that
\$x+1=b\texttt{\symbol{94}}i\$, so \$y+z=y(1+z/y)=b\texttt{\symbol{94}}k\$,
where k=Log(y,b)+ZechLog(z/y,b) and b must be a primitive element of F. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);; l := One(F);;|
  !gapprompt@gap>| !gapinput@ZechLog(2*l,8*l,F);|
  -24
  !gapprompt@gap>| !gapinput@8*l+l;(2*l)^(-24);|
  Z(11)^6
  Z(11)^6
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{CoefficientToPolynomial}}
\logpage{[ 7, 6, 8 ]}\nobreak
\hyperdef{L}{X7C8C1E6A7E3497F0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoefficientToPolynomial({\mdseries\slshape coeffs, R})\index{CoefficientToPolynomial@\texttt{CoefficientToPolynomial}}
\label{CoefficientToPolynomial}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{CoefficientToPolynomial} returns the degree $d-1$ polynomial $c_0+c_1x+...+c_{d-1}x^{d-1}$, where \mbox{\texttt{\mdseries\slshape coeffs}} is a list of elements of a field, $coeffs=\{ c_0,...,c_{d-1}\}$, and \mbox{\texttt{\mdseries\slshape R}} is a univariate polynomial ring. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@coeffs:=Z(11)^0*[1,2,3,4];|
  [ Z(11)^0, Z(11), Z(11)^8, Z(11)^2 ]
  !gapprompt@gap>| !gapinput@CoefficientToPolynomial(coeffs,R1);|
  Z(11)^2*a^3+Z(11)^8*a^2+Z(11)*a+Z(11)^0
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DegreesMonomialTerm}}
\logpage{[ 7, 6, 9 ]}\nobreak
\hyperdef{L}{X8431985183B63BB7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreesMonomialTerm({\mdseries\slshape m, R})\index{DegreesMonomialTerm@\texttt{DegreesMonomialTerm}}
\label{DegreesMonomialTerm}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{DegreesMonomialTerm} returns the list of degrees to which each variable in the multivariate
polynomial ring \mbox{\texttt{\mdseries\slshape R}} occurs in the monomial \mbox{\texttt{\mdseries\slshape m}}, where \mbox{\texttt{\mdseries\slshape coeffs}} is a list of elements of a field. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(11);|
  GF(11)
  !gapprompt@gap>| !gapinput@R1:=PolynomialRing(F,["a"]);;|
  !gapprompt@gap>| !gapinput@var1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;|
  !gapprompt@gap>| !gapinput@b:=X(F,"b",var1);|
  b
  !gapprompt@gap>| !gapinput@var2:=Concatenation(var1,[b]);|
  [ a, b ]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(F,var2);|
  PolynomialRing(..., [ a, b ])
  !gapprompt@gap>| !gapinput@c:=X(F,"c",var2);|
  c
  !gapprompt@gap>| !gapinput@var3:=Concatenation(var2,[c]);|
  [ a, b, c ]
  !gapprompt@gap>| !gapinput@R3:=PolynomialRing(F,var3);|
  PolynomialRing(..., [ a, b, c ])
  !gapprompt@gap>| !gapinput@m:=b^3*c^7;|
  b^3*c^7
  !gapprompt@gap>| !gapinput@DegreesMonomialTerm(m,R3);|
  [ 0, 3, 7 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DivisorsMultivariatePolynomial}}
\logpage{[ 7, 6, 10 ]}\nobreak
\hyperdef{L}{X860EF39B841380A1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivisorsMultivariatePolynomial({\mdseries\slshape f, R})\index{DivisorsMultivariatePolynomial@\texttt{DivisorsMultivariatePolynomial}}
\label{DivisorsMultivariatePolynomial}
}\hfill{\scriptsize (function)}}\\


 The function \texttt{DivisorsMultivariatePolynomial} returns the list of polynomial divisors of \mbox{\texttt{\mdseries\slshape f}} in the multivariate polynomial ring \mbox{\texttt{\mdseries\slshape R}} with coefficients in a field. This program uses a simple but slow algorithm
(see Joachim von zur Gathen, J{\"u}rgen Gerhard, \cite{GG03}, exercise 16.10) which first converts the multivariate polynomial \mbox{\texttt{\mdseries\slshape f}} to an associated univariate polynomial $f^*$, then \texttt{Factors} $f^*$, and finally converts these univariate factors back into the multivariate
polynomial factors of \mbox{\texttt{\mdseries\slshape f}}. Since \texttt{Factors} is non-deterministic, \texttt{DivisorsMultivariatePolynomial} is non-deterministic as well. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R2:=PolynomialRing(GF(3),["x1","x2"]);|
  PolynomialRing(..., [ x1, x2 ])
  !gapprompt@gap>| !gapinput@vars:=IndeterminatesOfPolynomialRing(R2);|
  [ x1, x2 ]
  !gapprompt@gap>| !gapinput@x2:=vars[2];|
  x2
  !gapprompt@gap>| !gapinput@x1:=vars[1];|
  x1
  !gapprompt@gap>| !gapinput@f:=x1^3+x2^3;;|
  !gapprompt@gap>| !gapinput@DivisorsMultivariatePolynomial(f,R2);|
  [ x1+x2, x1+x2, x1+x2 ]
\end{Verbatim}
  }

 }

 
\chapter{\textcolor{Chapter }{Coding theory functions in GAP}}\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X7A93308C82637F4F}{}
{
  \label{Coding theory functions in the GAP} This chapter will recall from the GAP4.4.5 manual some of the GAP coding
theory and finite field functions useful for coding theory. Some of these
functions are partially written in C for speed. The main functions are 
\begin{itemize}
\item  \texttt{AClosestVectorCombinationsMatFFEVecFFE}, 
\item  \texttt{AClosestVectorCombinationsMatFFEVecFFECoords}, 
\item  \texttt{CosetLeadersMatFFE}, 
\item  \texttt{DistancesDistributionMatFFEVecFFE}, 
\item  \texttt{DistancesDistributionVecFFEsVecFFE}, 
\item  \texttt{DistanceVecFFE} and \texttt{WeightVecFFE}, 
\item  \texttt{ConwayPolynomial} and \texttt{IsCheapConwayPolynomial}, 
\item  \texttt{IsPrimitivePolynomial}, and \texttt{RandomPrimitivePolynomial}. 
\end{itemize}
 However, the GAP command \texttt{PrimitivePolynomial} returns an integer primitive polynomial not the finite field kind. 

 
\section{\textcolor{Chapter }{ Distance functions }}\logpage{[ 8, 1, 0 ]}
\hyperdef{L}{X80F192497C008691}{}
{
  \label{Distance functions} 

\subsection{\textcolor{Chapter }{AClosestVectorCombinationsMatFFEVecFFE}}
\logpage{[ 8, 1, 1 ]}\nobreak
\hyperdef{L}{X82E5987E81487D18}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AClosestVectorCombinationsMatFFEVecFFE({\mdseries\slshape mat, F, vec, r, st})\index{AClosestVectorCombinationsMatFFEVecFFE@\texttt{AClosest}\-\texttt{Vector}\-\texttt{Combinations}\-\texttt{Mat}\-\texttt{F}\-\texttt{F}\-\texttt{E}\-\texttt{VecFFE}}
\label{AClosestVectorCombinationsMatFFEVecFFE}
}\hfill{\scriptsize (function)}}\\


 This command runs through the \mbox{\texttt{\mdseries\slshape F}}-linear combinations of the vectors in the rows of the matrix \mbox{\texttt{\mdseries\slshape mat}} that can be written as linear combinations of exactly \mbox{\texttt{\mdseries\slshape r}} rows (that is without using zero as a coefficient) and returns a vector from
these that is closest to the vector \mbox{\texttt{\mdseries\slshape vec}}. The length of the rows of \mbox{\texttt{\mdseries\slshape mat}} and the length of \mbox{\texttt{\mdseries\slshape vec}} must be equal, and all elements must lie in \mbox{\texttt{\mdseries\slshape F}}. The rows of \mbox{\texttt{\mdseries\slshape mat}} must be linearly independent. If it finds a vector of distance at most \mbox{\texttt{\mdseries\slshape st}}, which must be a nonnegative integer, then it stops immediately and returns
this vector. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(3);;|
  !gapprompt@gap>| !gapinput@x:= Indeterminate( F );; pol:= x^2+1;|
  x_1^2+Z(3)^0
  !gapprompt@gap>| !gapinput@C := GeneratorPolCode(pol,8,F);|
  a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)
  !gapprompt@gap>| !gapinput@v:=Codeword("12101111");|
  [ 1 2 1 0 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@v:=VectorCodeword(v);|
  [ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ]
  !gapprompt@gap>| !gapinput@G:=GeneratorMat(C);|
  [ [ Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3) ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ] ]
  !gapprompt@gap>| !gapinput@AClosestVectorCombinationsMatFFEVecFFE(G,F,v,1,1);|
  [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{AClosestVectorComb..MatFFEVecFFECoords}}
\logpage{[ 8, 1, 2 ]}\nobreak
\hyperdef{L}{X870DE258833C5AA0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AClosestVectorComb..MatFFEVecFFECoords({\mdseries\slshape mat, F, vec, r, st})\index{AClosestVectorComb..MatFFEVecFFECoords@\texttt{AClosest}\-\texttt{Vector}\-\texttt{Comb..}\-\texttt{Mat}\-\texttt{F}\-\texttt{F}\-\texttt{E}\-\texttt{Vec}\-\texttt{F}\-\texttt{F}\-\texttt{E}\-\texttt{Coords}}
\label{AClosestVectorComb..MatFFEVecFFECoords}
}\hfill{\scriptsize (function)}}\\


 \texttt{AClosestVectorCombinationsMatFFEVecFFECoords} returns a two element list containing (a) the same closest vector as in \texttt{AClosestVectorCombinationsMatFFEVecFFE}, and (b) a vector \mbox{\texttt{\mdseries\slshape v}} with exactly \mbox{\texttt{\mdseries\slshape r}} non-zero entries, such that $v*mat$ is the closest vector. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:=GF(3);;|
  !gapprompt@gap>| !gapinput@x:= Indeterminate( F );; pol:= x^2+1;|
  x_1^2+Z(3)^0
  !gapprompt@gap>| !gapinput@C := GeneratorPolCode(pol,8,F);|
  a cyclic [8,6,1..2]1..2 code defined by generator polynomial over GF(3)
  !gapprompt@gap>| !gapinput@v:=Codeword("12101111"); v:=VectorCodeword(v);;|
  [ 1 2 1 0 1 1 1 1 ]
  !gapprompt@gap>| !gapinput@G:=GeneratorMat(C);;|
  !gapprompt@gap>| !gapinput@AClosestVectorCombinationsMatFFEVecFFECoords(G,F,v,1,1);|
  [ [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ],
    [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0 ] ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DistancesDistributionMatFFEVecFFE}}
\logpage{[ 8, 1, 3 ]}\nobreak
\hyperdef{L}{X85135CEB86E61D49}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DistancesDistributionMatFFEVecFFE({\mdseries\slshape mat, f, vec})\index{DistancesDistributionMatFFEVecFFE@\texttt{DistancesDistributionMatFFEVecFFE}}
\label{DistancesDistributionMatFFEVecFFE}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistancesDistributionMatFFEVecFFE} returns the distances distribution of the vector \mbox{\texttt{\mdseries\slshape vec}} to the vectors in the vector space generated by the rows of the matrix \mbox{\texttt{\mdseries\slshape mat}} over the finite field \mbox{\texttt{\mdseries\slshape f}}. All vectors must have the same length, and all elements must lie in a common
field. The distances distribution is a list $d$ of length $Length(vec)+1$, such that the value $d[i]$ is the number of vectors in vecs that have distance $i+1$ to \mbox{\texttt{\mdseries\slshape vec}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@v:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;|
  !gapprompt@gap>| !gapinput@vecs:=[ [ Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ] ];;|
  !gapprompt@gap>| !gapinput@DistancesDistributionMatFFEVecFFE(vecs,GF(3),v);|
  [ 0, 4, 6, 60, 109, 216, 192, 112, 30 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{DistancesDistributionVecFFEsVecFFE}}
\logpage{[ 8, 1, 4 ]}\nobreak
\hyperdef{L}{X7F2F630984A9D3D6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DistancesDistributionVecFFEsVecFFE({\mdseries\slshape vecs, vec})\index{DistancesDistributionVecFFEsVecFFE@\texttt{DistancesDistributionVecFFEsVecFFE}}
\label{DistancesDistributionVecFFEsVecFFE}
}\hfill{\scriptsize (function)}}\\


 \texttt{DistancesDistributionVecFFEsVecFFE} returns the distances distribution of the vector \mbox{\texttt{\mdseries\slshape vec}} to the vectors in the list \mbox{\texttt{\mdseries\slshape vecs}}. All vectors must have the same length, and all elements must lie in a common
field. The distances distribution is a list $d$ of length $Length(vec)+1$, such that the value $d[i]$ is the number of vectors in \mbox{\texttt{\mdseries\slshape vecs}} that have distance $i+1$ to \mbox{\texttt{\mdseries\slshape vec}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@v:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;|
  !gapprompt@gap>| !gapinput@vecs:=[ [ Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3), 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0, 0*Z(3) ],|
  !gapprompt@>| !gapinput@  [ 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), 0*Z(3), Z(3)^0, 0*Z(3), Z(3)^0 ] ];;|
  !gapprompt@gap>| !gapinput@DistancesDistributionVecFFEsVecFFE(vecs,v);|
  [ 0, 0, 0, 0, 0, 4, 0, 1, 1 ]
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{WeightVecFFE}}
\logpage{[ 8, 1, 5 ]}\nobreak
\hyperdef{L}{X7C9F4D657F9BA5A1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeightVecFFE({\mdseries\slshape vec})\index{WeightVecFFE@\texttt{WeightVecFFE}}
\label{WeightVecFFE}
}\hfill{\scriptsize (function)}}\\


 \texttt{WeightVecFFE} returns the weight of the finite field vector \mbox{\texttt{\mdseries\slshape vec}}, i.e. the number of nonzero entries. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@v:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;|
  !gapprompt@gap>| !gapinput@WeightVecFFE(v);|
  7
\end{Verbatim}
  \index{Hamming metric} 

\subsection{\textcolor{Chapter }{DistanceVecFFE}}
\logpage{[ 8, 1, 6 ]}\nobreak
\hyperdef{L}{X85AA5C6587559C1C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DistanceVecFFE({\mdseries\slshape vec1, vec2})\index{DistanceVecFFE@\texttt{DistanceVecFFE}}
\label{DistanceVecFFE}
}\hfill{\scriptsize (function)}}\\


 The \emph{Hamming metric} on $GF(q)^n$ is the function 
\[ dist((v_1,...,v_n),(w_1,...,w_n)) =|\{i\in [1..n]\ |\ v_i\not= w_i\}|. \]
 This is also called the (Hamming) distance between $v=(v_1,...,v_n)$ and $w=(w_1,...,w_n)$. \texttt{DistanceVecFFE} returns the distance between the two vectors \mbox{\texttt{\mdseries\slshape vec1}} and \mbox{\texttt{\mdseries\slshape vec2}}, which must have the same length and whose elements must lie in a common
field. The distance is the number of places where \mbox{\texttt{\mdseries\slshape vec1}} and \mbox{\texttt{\mdseries\slshape vec2}} differ. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@v1:=[ Z(3)^0, Z(3), Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;|
  !gapprompt@gap>| !gapinput@v2:=[ Z(3), Z(3)^0, Z(3)^0, 0*Z(3), Z(3)^0, Z(3)^0, Z(3)^0, Z(3)^0 ];;|
  !gapprompt@gap>| !gapinput@DistanceVecFFE(v1,v2);|
  2
\end{Verbatim}
  }

 
\section{\textcolor{Chapter }{ Other functions }}\logpage{[ 8, 2, 0 ]}
\hyperdef{L}{X87C3D1B984960984}{}
{
  \label{Other functions} We basically repeat, with minor variation, the material in the GAP manual or
from Frank Luebeck's website \href{http://www.math.rwth-aachen.de:8001/~Frank.Luebeck/data/ConwayPol} {\texttt{http://www.math.rwth-aachen.de:8001/\texttt{\symbol{126}}Frank.Luebeck/data/ConwayPol}} on Conway polynomials. \index{$GF(p)$} The \textsc{prime fields}: If $p\geq 2$ is a prime then $GF(p)$ denotes the field ${\mathbb{Z}}/p{\mathbb{Z}}$, with addition and multiplication performed mod $p$. 

 \index{$GF(q)$} The \textsc{prime power fields}: Suppose $q=p^r$ is a prime power, $r>1$, and put $F=GF(p)$. Let $F[x]$ denote the ring of all polynomials over $F$ and let $f(x)$ denote a monic irreducible polynomial in $F[x]$ of degree $r$. The quotient $E = F[x]/(f(x))= F[x]/f(x)F[x]$ is a field with $q$ elements. If $f(x)$ and $E$ are related in this way, we say that $f(x)$ is the \textsc{defining polynomial} of $E$. \index{defining polynomial} Any defining polynomial factors completely into distinct linear factors over
the field it defines. 

 For any finite field $F$, the multiplicative group of non-zero elements $F^\times$ is a cyclic group. An $\alpha \in F$ is called a \textsc{primitive element} if it is a generator of $F^\times$. A defining polynomial $f(x)$ of $F$ is said to be \textsc{primitive} if it has a root in $F$ which is a primitive element. \index{primitive element} 

\subsection{\textcolor{Chapter }{ConwayPolynomial}}
\logpage{[ 8, 2, 1 ]}\nobreak
\hyperdef{L}{X7C2425A786F09054}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConwayPolynomial({\mdseries\slshape p, n})\index{ConwayPolynomial@\texttt{ConwayPolynomial}}
\label{ConwayPolynomial}
}\hfill{\scriptsize (function)}}\\


 A standard notation for the elements of $GF(p)$ is given via the representatives $0, ..., p-1$ of the cosets modulo $p$. We order these elements by $0 \ \ \langle\ \ 1 \ \ \langle\ \ 2 \ \ \langle\ \ ... \ \ \langle\ \ p-1$. We introduce an ordering of the polynomials of degree $r$ over $GF(p)$. Let $g(x) = g_rx^r + ... + g_0$ and $h(x) = h_rx^r + ... + h_0$ (by convention, $g_i=h_i=0$ for $i\ \ \rangle\ \ r$). Then we define $g \ \ \langle\ \ h$ if and only if there is an index $k$ with $g_i = h_i$ for $i \ \ \rangle\ \ k$ and $(-1)^{r-k} g_k \ \ \langle\ \ (-1)^{r-k} h_k$. 

 The \textsc{Conway polynomial} $f_{p,r}(x)$ for $GF(p^r)$ is the smallest polynomial of degree $r$ with respect to this ordering such that: 
\begin{itemize}
\item  $f_{p,r}(x)$ is monic, 
\item  $f_{p,r}(x)$ is primitive, that is, any zero is a generator of the (cyclic) multiplicative
group of $GF(p^r)$, 
\item  for each proper divisor $m$ of $r$ we have that $f_{p,m}(x^{(p^r-1) / (p^m-1)}) \equiv 0 \pmod{f_{p,r}(x)}$; that is, the $(p^r-1) / (p^m-1)$-th power of a zero of $f_{p,r}(x)$ is a zero of $f_{p,m}(x)$. 
\end{itemize}
 

 \texttt{ConwayPolynomial(p,n)} returns the polynomial $f_{p,r}(x)$ defined above. 

 \texttt{IsCheapConwayPolynomial(p,n)} returns true if \texttt{ConwayPolynomial( p, n )} will give a result in reasonable time. This is either the case when this
polynomial is pre-computed, or if $n,p$ are not too big. }

 \index{IsCheapConwayPolynomial} 

\subsection{\textcolor{Chapter }{RandomPrimitivePolynomial}}
\logpage{[ 8, 2, 2 ]}\nobreak
\hyperdef{L}{X7ECC593583E68A6C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RandomPrimitivePolynomial({\mdseries\slshape F, n})\index{RandomPrimitivePolynomial@\texttt{RandomPrimitivePolynomial}}
\label{RandomPrimitivePolynomial}
}\hfill{\scriptsize (function)}}\\


 For a finite field \mbox{\texttt{\mdseries\slshape F}} and a positive integer \mbox{\texttt{\mdseries\slshape n}} this function returns a primitive polynomial of degree \mbox{\texttt{\mdseries\slshape n}} over \mbox{\texttt{\mdseries\slshape F}}, that is a zero of this polynomial has maximal multiplicative order $|F|^n-1$. 

 \texttt{IsPrimitivePolynomial(f)} can be used to check if a univariate polynomial \mbox{\texttt{\mdseries\slshape f}} is primitive or not. }

 \index{IsPrimitivePolynomial} }

 }

 
\chapter{\textcolor{Chapter }{ GNU Free Documentation License }}\logpage{[ 9, 0, 0 ]}
\hyperdef{L}{X82257DE97D1822AA}{}
{
  GNU Free Documentation License Version 1.2, November 2002 

 Copyright (C) 2000,2001,2002 Free Software Foundation, Inc. 51 Franklin St,
Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and
distribute verbatim copies of this license document, but changing it is not
allowed. 

 0. PREAMBLE 

 The purpose of this License is to make a manual, textbook, or other functional
and useful document "free" in the sense of freedom: to assure everyone the
effective freedom to copy and redistribute it, with or without modifying it,
either commercially or noncommercially. Secondarily, this License preserves
for the author and publisher a way to get credit for their work, while not
being considered responsible for modifications made by others. 

 This License is a kind of "copyleft", which means that derivative works of the
document must themselves be free in the same sense. It complements the GNU
General Public License, which is a copyleft license designed for free
software. 

 We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free program
should come with manuals providing the same freedoms that the software does.
But this License is not limited to software manuals; it can be used for any
textual work, regardless of subject matter or whether it is published as a
printed book. We recommend this License principally for works whose purpose is
instruction or reference. 

 1. APPLICABILITY AND DEFINITIONS 

 This License applies to any manual or other work, in any medium, that contains
a notice placed by the copyright holder saying it can be distributed under the
terms of this License. Such a notice grants a world-wide, royalty-free
license, unlimited in duration, to use that work under the conditions stated
herein. The "Document", below, refers to any such manual or work. Any member
of the public is a licensee, and is addressed as "you". You accept the license
if you copy, modify or distribute the work in a way requiring permission under
copyright law. 

 A "Modified Version" of the Document means any work containing the Document or
a portion of it, either copied verbatim, or with modifications and/or
translated into another language. 

 A "Secondary Section" is a named appendix or a front-matter section of the
Document that deals exclusively with the relationship of the publishers or
authors of the Document to the Document's overall subject (or to related
matters) and contains nothing that could fall directly within that overall
subject. (Thus, if the Document is in part a textbook of mathematics, a
Secondary Section may not explain any mathematics.) The relationship could be
a matter of historical connection with the subject or with related matters, or
of legal, commercial, philosophical, ethical or political position regarding
them. 

 The "Invariant Sections" are certain Secondary Sections whose titles are
designated, as being those of Invariant Sections, in the notice that says that
the Document is released under this License. If a section does not fit the
above definition of Secondary then it is not allowed to be designated as
Invariant. The Document may contain zero Invariant Sections. If the Document
does not identify any Invariant Sections then there are none. 

 The "Cover Texts" are certain short passages of text that are listed, as
Front-Cover Texts or Back-Cover Texts, in the notice that says that the
Document is released under this License. A Front-Cover Text may be at most 5
words, and a Back-Cover Text may be at most 25 words. 

 A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the general
public, that is suitable for revising the document straightforwardly with
generic text editors or (for images composed of pixels) generic paint programs
or (for drawings) some widely available drawing editor, and that is suitable
for input to text formatters or for automatic translation to a variety of
formats suitable for input to text formatters. A copy made in an otherwise
Transparent file format whose markup, or absence of markup, has been arranged
to thwart or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount of text.
A copy that is not "Transparent" is called "Opaque". 

 Examples of suitable formats for Transparent copies include plain ASCII
without markup, Texinfo input format, LaTeX input format, SGML or XML using a
publicly available DTD, and standard-conforming simple HTML, PostScript or PDF
designed for human modification. Examples of transparent image formats include
PNG, XCF and JPG. Opaque formats include proprietary formats that can be read
and edited only by proprietary word processors, SGML or XML for which the DTD
and/or processing tools are not generally available, and the machine-generated
HTML, PostScript or PDF produced by some word processors for output purposes
only. 

 The "Title Page" means, for a printed book, the title page itself, plus such
following pages as are needed to hold, legibly, the material this License
requires to appear in the title page. For works in formats which do not have
any title page as such, "Title Page" means the text near the most prominent
appearance of the work's title, preceding the beginning of the body of the
text. 

 A section "Entitled XYZ" means a named subunit of the Document whose title
either is precisely XYZ or contains XYZ in parentheses following text that
translates XYZ in another language. (Here XYZ stands for a specific section
name mentioned below, such as "Acknowledgements", "Dedications",
"Endorsements", or "History".) To "Preserve the Title" of such a section when
you modify the Document means that it remains a section "Entitled XYZ"
according to this definition. 

 The Document may include Warranty Disclaimers next to the notice which states
that this License applies to the Document. These Warranty Disclaimers are
considered to be included by reference in this License, but only as regards
disclaiming warranties: any other implication that these Warranty Disclaimers
may have is void and has no effect on the meaning of this License. 

 2. VERBATIM COPYING 

 You may copy and distribute the Document in any medium, either commercially or
noncommercially, provided that this License, the copyright notices, and the
license notice saying this License applies to the Document are reproduced in
all copies, and that you add no other conditions whatsoever to those of this
License. You may not use technical measures to obstruct or control the reading
or further copying of the copies you make or distribute. However, you may
accept compensation in exchange for copies. If you distribute a large enough
number of copies you must also follow the conditions in section 3. 

 You may also lend copies, under the same conditions stated above, and you may
publicly display copies. 

 3. COPYING IN QUANTITY 

 If you publish printed copies (or copies in media that commonly have printed
covers) of the Document, numbering more than 100, and the Document's license
notice requires Cover Texts, you must enclose the copies in covers that carry,
clearly and legibly, all these Cover Texts: Front-Cover Texts on the front
cover, and Back-Cover Texts on the back cover. Both covers must also clearly
and legibly identify you as the publisher of these copies. The front cover
must present the full title with all words of the title equally prominent and
visible. You may add other material on the covers in addition. Copying with
changes limited to the covers, as long as they preserve the title of the
Document and satisfy these conditions, can be treated as verbatim copying in
other respects. 

 If the required texts for either cover are too voluminous to fit legibly, you
should put the first ones listed (as many as fit reasonably) on the actual
cover, and continue the rest onto adjacent pages. 

 If you publish or distribute Opaque copies of the Document numbering more than
100, you must either include a machine-readable Transparent copy along with
each Opaque copy, or state in or with each Opaque copy a computer-network
location from which the general network-using public has access to download
using public-standard network protocols a complete Transparent copy of the
Document, free of added material. If you use the latter option, you must take
reasonably prudent steps, when you begin distribution of Opaque copies in
quantity, to ensure that this Transparent copy will remain thus accessible at
the stated location until at least one year after the last time you distribute
an Opaque copy (directly or through your agents or retailers) of that edition
to the public. 

 It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give them a
chance to provide you with an updated version of the Document. 

 4. MODIFICATIONS 

 You may copy and distribute a Modified Version of the Document under the
conditions of sections 2 and 3 above, provided that you release the Modified
Version under precisely this License, with the Modified Version filling the
role of the Document, thus licensing distribution and modification of the
Modified Version to whoever possesses a copy of it. In addition, you must do
these things in the Modified Version: 

 A. Use in the Title Page (and on the covers, if any) a title distinct from
that of the Document, and from those of previous versions (which should, if
there were any, be listed in the History section of the Document). You may use
the same title as a previous version if the original publisher of that version
gives permission. 

 B. List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified Version,
together with at least five of the principal authors of the Document (all of
its principal authors, if it has fewer than five), unless they release you
from this requirement. 

 C. State on the Title page the name of the publisher of the Modified Version,
as the publisher. 

 D. Preserve all the copyright notices of the Document. 

 E. Add an appropriate copyright notice for your modifications adjacent to the
other copyright notices. 

 F. Include, immediately after the copyright notices, a license notice giving
the public permission to use the Modified Version under the terms of this
License, in the form shown in the Addendum below. 

 G. Preserve in that license notice the full lists of Invariant Sections and
required Cover Texts given in the Document's license notice. 

 H. Include an unaltered copy of this License. 

 I. Preserve the section Entitled "History", Preserve its Title, and add to it
an item stating at least the title, year, new authors, and publisher of the
Modified Version as given on the Title Page. If there is no section Entitled
"History" in the Document, create one stating the title, year, authors, and
publisher of the Document as given on its Title Page, then add an item
describing the Modified Version as stated in the previous sentence. 

 J. Preserve the network location, if any, given in the Document for public
access to a Transparent copy of the Document, and likewise the network
locations given in the Document for previous versions it was based on. These
may be placed in the "History" section. You may omit a network location for a
work that was published at least four years before the Document itself, or if
the original publisher of the version it refers to gives permission. 

 K. For any section Entitled "Acknowledgements" or "Dedications", Preserve the
Title of the section, and preserve in the section all the substance and tone
of each of the contributor acknowledgements and/or dedications given therein. 

 L. Preserve all the Invariant Sections of the Document, unaltered in their
text and in their titles. Section numbers or the equivalent are not considered
part of the section titles. 

 M. Delete any section Entitled "Endorsements". Such a section may not be
included in the Modified Version. 

 N. Do not retitle any existing section to be Entitled "Endorsements" or to
conflict in title with any Invariant Section. 

 O. Preserve any Warranty Disclaimers. 

 If the Modified Version includes new front-matter sections or appendices that
qualify as Secondary Sections and contain no material copied from the
Document, you may at your option designate some or all of these sections as
invariant. To do this, add their titles to the list of Invariant Sections in
the Modified Version's license notice. These titles must be distinct from any
other section titles. 

 You may add a section Entitled "Endorsements", provided it contains nothing
but endorsements of your Modified Version by various parties--for example,
statements of peer review or that the text has been approved by an
organization as the authoritative definition of a standard. 

 You may add a passage of up to five words as a Front-Cover Text, and a passage
of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts
in the Modified Version. Only one passage of Front-Cover Text and one of
Back-Cover Text may be added by (or through arrangements made by) any one
entity. If the Document already includes a cover text for the same cover,
previously added by you or by arrangement made by the same entity you are
acting on behalf of, you may not add another; but you may replace the old one,
on explicit permission from the previous publisher that added the old one. 

 The author(s) and publisher(s) of the Document do not by this License give
permission to use their names for publicity for or to assert or imply
endorsement of any Modified Version. 

 5. COMBINING DOCUMENTS 

 You may combine the Document with other documents released under this License,
under the terms defined in section 4 above for modified versions, provided
that you include in the combination all of the Invariant Sections of all of
the original documents, unmodified, and list them all as Invariant Sections of
your combined work in its license notice, and that you preserve all their
Warranty Disclaimers. 

 The combined work need only contain one copy of this License, and multiple
identical Invariant Sections may be replaced with a single copy. If there are
multiple Invariant Sections with the same name but different contents, make
the title of each such section unique by adding at the end of it, in
parentheses, the name of the original author or publisher of that section if
known, or else a unique number. Make the same adjustment to the section titles
in the list of Invariant Sections in the license notice of the combined work. 

 In the combination, you must combine any sections Entitled "History" in the
various original documents, forming one section Entitled "History"; likewise
combine any sections Entitled "Acknowledgements", and any sections Entitled
"Dedications". You must delete all sections Entitled "Endorsements". 

 6. COLLECTIONS OF DOCUMENTS 

 You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this License
in the various documents with a single copy that is included in the
collection, provided that you follow the rules of this License for verbatim
copying of each of the documents in all other respects. 

 You may extract a single document from such a collection, and distribute it
individually under this License, provided you insert a copy of this License
into the extracted document, and follow this License in all other respects
regarding verbatim copying of that document. 

 7. AGGREGATION WITH INDEPENDENT WORKS 

 A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or distribution
medium, is called an "aggregate" if the copyright resulting from the
compilation is not used to limit the legal rights of the compilation's users
beyond what the individual works permit. When the Document is included in an
aggregate, this License does not apply to the other works in the aggregate
which are not themselves derivative works of the Document. 

 If the Cover Text requirement of section 3 is applicable to these copies of
the Document, then if the Document is less than one half of the entire
aggregate, the Document's Cover Texts may be placed on covers that bracket the
Document within the aggregate, or the electronic equivalent of covers if the
Document is in electronic form. Otherwise they must appear on printed covers
that bracket the whole aggregate. 

 8. TRANSLATION 

 Translation is considered a kind of modification, so you may distribute
translations of the Document under the terms of section 4. Replacing Invariant
Sections with translations requires special permission from their copyright
holders, but you may include translations of some or all Invariant Sections in
addition to the original versions of these Invariant Sections. You may include
a translation of this License, and all the license notices in the Document,
and any Warranty Disclaimers, provided that you also include the original
English version of this License and the original versions of those notices and
disclaimers. In case of a disagreement between the translation and the
original version of this License or a notice or disclaimer, the original
version will prevail. 

 If a section in the Document is Entitled "Acknowledgements", "Dedications", or
"History", the requirement (section 4) to Preserve its Title (section 1) will
typically require changing the actual title. 

 9. TERMINATION 

 You may not copy, modify, sublicense, or distribute the Document except as
expressly provided for under this License. Any other attempt to copy, modify,
sublicense or distribute the Document is void, and will automatically
terminate your rights under this License. However, parties who have received
copies, or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance. 

 10. FUTURE REVISIONS OF THIS LICENSE 

 The Free Software Foundation may publish new, revised versions of the GNU Free
Documentation License from time to time. Such new versions will be similar in
spirit to the present version, but may differ in detail to address new
problems or concerns. See http://www.gnu.org/copyleft/. 

 Each version of the License is given a distinguishing version number. If the
Document specifies that a particular numbered version of this License "or any
later version" applies to it, you have the option of following the terms and
conditions either of that specified version or of any later version that has
been published (not as a draft) by the Free Software Foundation. If the
Document does not specify a version number of this License, you may choose any
version ever published (not as a draft) by the Free Software Foundation. }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{guava_bib.xml}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
