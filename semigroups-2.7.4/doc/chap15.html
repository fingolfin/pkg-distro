<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (semigroups) - Chapter 15: 
    Attributes and operations for semigroups
  </title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap15"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap14.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap16.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap15_mj.html">[MathJax on]</a></p>
<p><a id="X7C75B1DB81C7779B" name="X7C75B1DB81C7779B"></a></p>
<div class="ChapSects"><a href="chap15.html#X7C75B1DB81C7779B">15 <span class="Heading">
    Attributes and operations for semigroups
  </span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X824184C785BF12FF">15.1 <span class="Heading">
      Random elements of a semigroup
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7BB7FDFE7AFFD672">15.1-1 Random</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X81CEB3717E021643">15.2 <span class="Heading">
      Expressing semigroup elements as words in generators
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X799D2F3C866B9AED">15.2-1 EvaluateWord</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X8357294D7B164106">15.2-2 Factorization</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X83A4D71382C5B6C3">15.2-3 MinimalFactorization</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X7E4AA1437A6C7B40">15.3 <span class="Heading">
      Generating sets
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7BD5B55C802805B4">15.3-1 Generators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X814DBABC878D5232">15.3-2 SmallGeneratingSet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7F88DA9487720D2B">15.3-3 IrredundantGeneratingSubset</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X830E18747A0B5BED">15.4 <span class="Heading">
      Minimal ideals and multiplicative zeros
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7BC68589879C3BE9">15.4-1 MinimalIdeal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7CA6744182D07C5B">15.4-2 RepresentativeOfMinimalIdeal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7B39F93C8136D642">15.4-3 MultiplicativeZero</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X7CAB17667ED5A6E8">15.5 <span class="Heading">
      Group of units and identity elements
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X811AEDD88280C277">15.5-1 GroupOfUnits</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X7C651C9C78398FFF">15.6 <span class="Heading">
      Idempotents
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7C651C9C78398FFF">15.6-1 Idempotents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7CFC4DB387452320">15.6-2 NrIdempotents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X83970D028143B79B">15.6-3 IdempotentGeneratedSubsemigroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X7D490B867CEFCBEF">15.7 <span class="Heading">
      Maximal subsemigroups
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X80292361867AF3FE">15.7-1 MaximalSubsemigroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7C39DC3C85462681">15.7-2 MaximalSubsemigroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X82D74C2478A49FD5">15.7-3 IsMaximalSubsemigroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X7E654D0D8427A001">15.8 <span class="Heading">
      The normalizer of a semigroup
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X87C024AE814BC9D8">15.8-1 Normalizer</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X786F25478029619D">15.9 <span class="Heading">
      Attributes of transformation semigroups
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X8065DBC48722B085">15.9-1 ComponentRepsOfTransformationSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X8706A72A7F3EE532">15.9-2 ComponentsOfTransformationSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7AA697B186301F54">15.9-3 CyclesOfTransformationSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X83DA161F875F63B1">15.9-4 IsTransitive</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7C65202187A9C9F5">15.9-5 SmallestElementSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X83B3BBCD783B3408">15.9-6 GeneratorsSmallest</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X84B8E29C7D7565B0">15.10 <span class="Heading">
      Attributes of partial perm semigroups
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7BC22CB47C7B5EBB">15.10-1 ComponentRepsOfPartialPermSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X8464BC397ACBF2F1">15.10-2 ComponentsOfPartialPermSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X832937BB87EB4349">15.10-3 CyclesOfPartialPerm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7F7A5E5E8355E230">15.10-4 CyclesOfPartialPermSemigroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X7AF313CF7CBE98D7">15.11 <span class="Heading">
      Attributes of Rees (0-)matrix semigroups
    </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X7EA1B28785B9D38C">15.11-1 RZMSDigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X79B062917AB34542">15.11-2 RZMSConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X870210EA7912B52A">15.11-3 RZMSNormalization</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap15.html#X80DE617E841E5BA0">15.11-4 RMSNormalization</a></span>
</div></div>
</div>

<h3>15 <span class="Heading">
    Attributes and operations for semigroups
  </span></h3>

<p>In this chapter we decribe the methods that are available in <strong class="pkg">Semigroups</strong> for determining the attributes of a semigroup, and the operations which can be applied to a semigroup.</p>

<p><a id="X824184C785BF12FF" name="X824184C785BF12FF"></a></p>

<h4>15.1 <span class="Heading">
      Random elements of a semigroup
    </span></h4>

<p><a id="X7BB7FDFE7AFFD672" name="X7BB7FDFE7AFFD672"></a></p>

<h5>15.1-1 Random</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Random</code>( <var class="Arg">S</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>Returns: A random element.</p>

<p>This function returns a random element of the semigroup <var class="Arg">S</var>. If the elements of <var class="Arg">S</var> have been calculated, then one of these is chosen randomly. Otherwise, if the data structure for <var class="Arg">S</var> is known, then a random element of a randomly chosen \(\mathscr{R}\)-class is returned. If the data structure for <var class="Arg">S</var> has not been calculated, then a short product (at most <code class="code">2 * Length(GeneratorsOfSemigroup(<var class="Arg">S</var>))</code>) of generators is returned.</p>

<p><a id="X81CEB3717E021643" name="X81CEB3717E021643"></a></p>

<h4>15.2 <span class="Heading">
      Expressing semigroup elements as words in generators
    </span></h4>

<p>It is possible to express an element of a semigroup as a word in the generators of that semigroup. This section describes how to accomplish this in <strong class="pkg">Semigroups</strong>.</p>

<p><a id="X799D2F3C866B9AED" name="X799D2F3C866B9AED"></a></p>

<h5>15.2-1 EvaluateWord</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EvaluateWord</code>( <var class="Arg">gens</var>, <var class="Arg">w</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A semigroup element.</p>

<p>The argument <var class="Arg">gens</var> should be a collection of generators of a semigroup and the argument <var class="Arg">w</var> should be a list of positive integers less than or equal to the length of <var class="Arg">gens</var>. This operation evaluates the word <var class="Arg">w</var> in the generators <var class="Arg">gens</var>. More precisely, <code class="code">EvaluateWord</code> returns the equivalent of:</p>


<div class="example"><pre>Product(List(w, i -&gt; gens[i]));</pre></div>

<p>see also <code class="func">Factorization</code> (<a href="chap15.html#X8357294D7B164106"><span class="RefLink">15.2-2</span></a>).</p>


<dl>
<dt><strong class="Mark">for elements of a semigroup</strong></dt>
<dd><p>When <var class="Arg">gens</var> is a list of elements of a semigroup and <var class="Arg">w</var> is a list of positive integers less than or equal to the length of <var class="Arg">gens</var>, this operation returns the product <code class="code">gens[w[1]] * gens[w[2]] * .. . * gens[w[n]]</code> when the length of <var class="Arg">w</var> is <code class="code">n</code>.</p>

</dd>
<dt><strong class="Mark">for elements of an inverse semigroup</strong></dt>
<dd><p>When <var class="Arg">gens</var> is a list of elements with a semigroup inverse and <var class="Arg">w</var> is a list of non-zero integers whose absolute value does not exceed the length of <var class="Arg">gens</var>, this operation returns the product <code class="code">gens[AbsInt(w[1])] ^ SignInt(w[1]) * .. . * gens[AbsInt(w[n])] ^ SignInt(w[n])</code> where <code class="code">n</code> is the length of <var class="Arg">w</var>.</p>

</dd>
</dl>
<p>Note that <code class="code">EvaluateWord(<var class="Arg">gens</var>, [])</code> returns <code class="code">One(<var class="Arg">gens</var>)</code> if <var class="Arg">gens</var> belongs to the category <code class="func">IsMultiplicativeElementWithOne</code> (<a href="../../../doc/ref/chap31_mj.html#X82BC294F7D388AE8"><span class="RefLink">Reference: IsMultiplicativeElementWithOne</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := [Transformation([2, 4, 4, 6, 8, 8, 6, 6]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([2, 7, 4, 1, 4, 6, 5, 2]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([3, 6, 2, 4, 2, 2, 2, 8]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([4, 3, 6, 4, 2, 1, 2, 6]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([4, 5, 1, 3, 8, 5, 8, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(gens);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation([1, 4, 6, 1, 7, 2, 7, 6]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">word := Factorization(S, x);</span>
[ 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EvaluateWord(gens, word);</span>
Transformation( [ 1, 4, 6, 1, 7, 2, 7, 6 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseMonoid(10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := PartialPerm([1, 2, 3, 6, 8, 10], [2, 6, 7, 9, 1, 5]);</span>
[3,7][8,1,2,6,9][10,5]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">word := Factorization(S, x);</span>
[ -2, -2, -2, -2, -3, -2, -2, -2, -2, -2, 5, 2, 5, 5, 2, 5, 2, 2, 2, 
  2, -3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EvaluateWord(GeneratorsOfSemigroup(S), word); </span>
[3,7][8,1,2,6,9][10,5]</pre></div>

<p><a id="X8357294D7B164106" name="X8357294D7B164106"></a></p>

<h5>15.2-2 Factorization</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Factorization</code>( <var class="Arg">S</var>, <var class="Arg">x</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A word in the generators.</p>


<dl>
<dt><strong class="Mark">for semigroups</strong></dt>
<dd><p>When <var class="Arg">S</var> is a semigroup and <var class="Arg">x</var> belongs to <var class="Arg">S</var>, <code class="code">Factorization</code> return a word in the generators of <var class="Arg">S</var> that is equal to <var class="Arg">x</var>. In this case, a word is a list of positive integers where an entry <code class="code">i</code> corresponds to <code class="code">GeneratorsOfSemigroups(S)[i]</code>. More specifically,</p>


<div class="example"><pre>EvaluateWord(GeneratorsOfSemigroup(S), Factorization(S, x)) = x;</pre></div>

</dd>
<dt><strong class="Mark">for inverse semigroups</strong></dt>
<dd><p>When <var class="Arg">S</var> is a inverse semigroup and <var class="Arg">x</var> belongs to <var class="Arg">S</var>, <code class="code">Factorization</code> return a word in the generators of <var class="Arg">S</var> that is equal to <var class="Arg">x</var>. In this case, a word is a list of non-zero integers where an entry <code class="code">i</code> corresponds to <code class="code">GeneratorsOfSemigroup(S)[i]</code> and <code class="code">-i</code> corresponds to <code class="code">GeneratorsOfSemigroup(S)[i] ^ -1</code>. As in the previous case,</p>


<div class="example"><pre>EvaluateWord(GeneratorsOfSemigroup(S), Factorization(S, x)) = x;</pre></div>

</dd>
</dl>
<p>Note that <code class="code">Factorization</code> does not always return a word of minimum length; see <code class="func">MinimalFactorization</code> (<a href="chap15.html#X83A4D71382C5B6C3"><span class="RefLink">15.2-3</span></a>).</p>

<p>See also <code class="func">EvaluateWord</code> (<a href="chap15.html#X799D2F3C866B9AED"><span class="RefLink">15.2-1</span></a>) and <code class="func">GeneratorsOfSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X78147A247963F23B"><span class="RefLink">Reference: GeneratorsOfSemigroup</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := [Transformation([2, 2, 9, 7, 4, 9, 5, 5, 4, 8]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Transformation([4, 10, 5, 6, 4, 1, 2, 7, 1, 2])];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(gens);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation([1, 10, 2, 10, 1, 2, 7, 10, 2, 7]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">word := Factorization(S, x);</span>
[ 2, 2, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EvaluateWord(gens, word);</span>
Transformation( [ 1, 10, 2, 10, 1, 2, 7, 10, 2, 7 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseMonoid(8);</span>
&lt;symmetric inverse monoid of degree 8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := PartialPerm( [ 1, 2, 3, 4, 5, 8 ], [ 7, 1, 4, 3, 2, 6 ] );</span>
[5,2,1,7][8,6](3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">word := Factorization(S, x);</span>
[ -2, -2, -2, -2, -2, -2, 2, 4, 4, 2, 3, 2, -3, -2, -2, 3, 2, -3, -2, 
  -2, 4, -3, -4, 2, 2, 3, -2, -3, 4, -3, -4, 2, 2, 3, -2, -3, 2, 2, 
  3, -2, -3, 2, 2, 3, -2, -3, 4, -3, -4, 3, 2, -3, -2, -2, 3, 2, -3, 
  -2, -2, 4, 3, -4, 3, 2, -3, -2, -2, 3, 2, -3, -2, -2, 3, 2, 2, 3, 
  2, 2, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EvaluateWord(GeneratorsOfSemigroup(S), word);</span>
[5,2,1,7][8,6](3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := DualSymmetricInverseMonoid(6);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := S.1 * S.2 * S.3 * S.2 * S.1;</span>
&lt;block bijection: [ 1, 6, -4 ], [ 2, -2, -3 ], [ 3, -5 ], [ 4, -6 ], 
 [ 5, -1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">word := Factorization(S, x);</span>
[ -2, -2, -2, -2, -2, 4, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EvaluateWord(GeneratorsOfSemigroup(S), word);</span>
&lt;block bijection: [ 1, 6, -4 ], [ 2, -2, -3 ], [ 3, -5 ], [ 4, -6 ], 
 [ 5, -1 ]&gt;</pre></div>

<p><a id="X83A4D71382C5B6C3" name="X83A4D71382C5B6C3"></a></p>

<h5>15.2-3 MinimalFactorization</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalFactorization</code>( <var class="Arg">S</var>, <var class="Arg">x</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A minimal word in the generators.</p>

<p>This operation returns a minimal length word in the generators of the semigroup <var class="Arg">S</var> that equals the element <var class="Arg">x</var>. In this case, a word is a list of positive integers where an entry <code class="code">i</code> corresponds to <code class="code">GeneratorsOfSemigroups(<var class="Arg">S</var>)[i]</code>. More specifically,</p>


<div class="example"><pre>EvaluateWord(GeneratorsOfSemigroup(S), MinimalFactorization(S, x)) = x;</pre></div>

<p><code class="code">MinimalFactorization</code> involves exhaustively enumerating <var class="Arg">S</var> until the element <var class="Arg">x</var> is found, and so <code class="code">MinimalFactorization</code> may be less efficient than <code class="func">Factorization</code> (<a href="chap15.html#X8357294D7B164106"><span class="RefLink">15.2-2</span></a>) for some semigroups.</p>

<p>Unlike <code class="func">Factorization</code> (<a href="chap15.html#X8357294D7B164106"><span class="RefLink">15.2-2</span></a>) this operation does not distinguish between semigroups and inverse semigroups. See also <code class="func">EvaluateWord</code> (<a href="chap15.html#X799D2F3C866B9AED"><span class="RefLink">15.2-1</span></a>) and <code class="func">GeneratorsOfSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X78147A247963F23B"><span class="RefLink">Reference: GeneratorsOfSemigroup</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([2, 2, 9, 7, 4, 9, 5, 5, 4, 8]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([4, 10, 5, 6, 4, 1, 2, 7, 1, 2]));</span>
&lt;transformation semigroup of degree 10 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation( [ 8, 8, 2, 2, 9, 2, 8, 8, 9, 9 ] );</span>
Transformation( [ 8, 8, 2, 2, 9, 2, 8, 8, 9, 9 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Factorization(S, x);</span>
[ 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalFactorization(S, x);</span>
[ 1, 2, 1, 1, 1, 1, 2, 2, 1 ]</pre></div>

<p><a id="X7E4AA1437A6C7B40" name="X7E4AA1437A6C7B40"></a></p>

<h4>15.3 <span class="Heading">
      Generating sets
    </span></h4>

<p><a id="X7BD5B55C802805B4" name="X7BD5B55C802805B4"></a></p>

<h5>15.3-1 Generators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Generators</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A list of generators.</p>

<p><code class="code">Generators</code> returns a generating set that can be used to define the semigroup <var class="Arg">S</var>. The generators of a monoid or inverse semigroup <var class="Arg">S</var>, say, can be defined in several ways, for example, including or excluding the identity element, including or not the inverses of the generators. <code class="code">Generators</code> uses the definition that returns the least number of generators. If no generating set for <var class="Arg">S</var> is known, then <code class="code">GeneratorsOfSemigroup</code> is used by default.</p>


<dl>
<dt><strong class="Mark">for a group</strong></dt>
<dd><p><code class="code">Generators(<var class="Arg">S</var>)</code> is a synonym for <code class="func">GeneratorsOfGroup</code> (<a href="../../../doc/ref/chap39_mj.html#X79C44528864044C5"><span class="RefLink">Reference: GeneratorsOfGroup</span></a>).</p>

</dd>
<dt><strong class="Mark">for an ideal of semigroup</strong></dt>
<dd><p><code class="code">Generators(<var class="Arg">S</var>)</code> is a synonym for <code class="func">GeneratorsOfSemigroupIdeal</code> (<a href="chap7.html#X87BB45DB844D41BC"><span class="RefLink">7.2-1</span></a>).</p>

</dd>
<dt><strong class="Mark">for a semigroup</strong></dt>
<dd><p><code class="code">Generators(<var class="Arg">S</var>)</code> is a synonym for <code class="func">GeneratorsOfSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X78147A247963F23B"><span class="RefLink">Reference: GeneratorsOfSemigroup</span></a>).</p>

</dd>
<dt><strong class="Mark">for a monoid</strong></dt>
<dd><p><code class="code">Generators(<var class="Arg">S</var>)</code> is a synonym for <code class="func">GeneratorsOfMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X83CA2E7279C44718"><span class="RefLink">Reference: GeneratorsOfMonoid</span></a>).</p>

</dd>
<dt><strong class="Mark">for an inverse semigroup</strong></dt>
<dd><p><code class="code">Generators(<var class="Arg">S</var>)</code> is a synonym for <code class="func">GeneratorsOfInverseSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X87C373597F787250"><span class="RefLink">Reference: GeneratorsOfInverseSemigroup</span></a>).</p>

</dd>
<dt><strong class="Mark">for an inverse monoid</strong></dt>
<dd><p><code class="code">Generators(<var class="Arg">S</var>)</code> is a synonym for <code class="func">GeneratorsOfInverseMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X7A3B262C85B6D475"><span class="RefLink">Reference: GeneratorsOfInverseMonoid</span></a>).</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := Monoid(Transformation([1, 4, 6, 2, 5, 3, 7, 8, 9, 9]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([6, 3, 2, 7, 5, 1, 8, 8, 9, 9]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfSemigroup(M);</span>
[ IdentityTransformation, 
  Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ), 
  Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfMonoid(M);</span>
[ Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ), 
  Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Generators(M);</span>
[ Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ), 
  Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Generators(M));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Generators(S);</span>
[ Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ), 
  Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfSemigroup(S);</span>
[ Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ), 
  Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) ]</pre></div>

<p><a id="X814DBABC878D5232" name="X814DBABC878D5232"></a></p>

<h5>15.3-2 SmallGeneratingSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallGeneratingSet</code>( <var class="Arg">coll</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallSemigroupGeneratingSet</code>( <var class="Arg">coll</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallMonoidGeneratingSet</code>( <var class="Arg">coll</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallInverseSemigroupGeneratingSet</code>( <var class="Arg">coll</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallInverseMonoidGeneratingSet</code>( <var class="Arg">coll</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A small generating set for a semigroup.</p>

<p>The attributes <code class="code">SmallXGeneratingSet</code> return a relatively small generating subset of the collection of elements <var class="Arg">coll</var>, which can also be a semigroup. The returned value of <code class="code">SmallXGeneratingSet</code>, where applicable, has the property that</p>


<div class="example"><pre>
      X(SmallXGeneratingSet(coll))=X(coll);
    </pre></div>

<p>where <code class="code">X</code> is any of <code class="func">Semigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X7F55D28F819B2817"><span class="RefLink">Reference: Semigroup</span></a>), <code class="func">Monoid</code> (<a href="../../../doc/ref/chap51_mj.html#X7F95328B7C7E49EA"><span class="RefLink">Reference: Monoid</span></a>), <code class="func">InverseSemigroup</code> (<a href="../../../doc/ref/chap51_mj.html#X78B13FED7AFB4326"><span class="RefLink">Reference: InverseSemigroup</span></a>), or <code class="func">InverseMonoid</code> (<a href="../../../doc/ref/chap51_mj.html#X80D9B9A98736051B"><span class="RefLink">Reference: InverseMonoid</span></a>).</p>

<p>If the number of generators for <var class="Arg">S</var> is already relatively small, then these functions will often return the original generating set. These functions may return different results in different <strong class="pkg">GAP</strong> sessions.</p>

<p><code class="code">SmallGeneratingSet</code> returns the smallest of the returned values of <code class="code">SmallXGeneratingSet</code> which is applicable to <var class="Arg">coll</var>; see <code class="func">Generators</code> (<a href="chap15.html#X7BD5B55C802805B4"><span class="RefLink">15.3-1</span></a>).</p>

<p>As neither irredundancy, nor minimal length are proven, these functions usually return an answer much more quickly than <code class="func">IrredundantGeneratingSubset</code> (<a href="chap15.html#X7F88DA9487720D2B"><span class="RefLink">15.3-3</span></a>). These functions can be used whenever a small generating set is desired which does not necessarily needs to be minimal.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup( Transformation( [ 1, 2, 3, 2, 4 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 1, 5, 4, 3, 2 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 2, 1, 4, 2, 2 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 2, 4, 4, 2, 1 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 3, 1, 4, 3, 2 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 3, 2, 3, 4, 1 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 4, 4, 3, 3, 5 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 5, 1, 5, 5, 3 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 5, 4, 3, 5, 2 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 5, 5, 4, 5, 5 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SmallGeneratingSet(S);                  </span>
[ Transformation( [ 1, 5, 4, 3, 2 ] ), Transformation( [ 3, 2, 3, 4, 1 ] ), 
  Transformation( [ 5, 4, 3, 5, 2 ] ), Transformation( [ 1, 2, 3, 2, 4 ] ), 
  Transformation( [ 4, 4, 3, 3, 5 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := RandomInverseMonoid(10000,10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SmallGeneratingSet(S);</span>
[ [ 1 .. 10 ] -&gt; [ 3, 2, 4, 5, 6, 1, 7, 10, 9, 8 ], 
  [ 1 .. 10 ] -&gt; [ 5, 10, 8, 9, 3, 2, 4, 7, 6, 1 ], 
  [ 1, 3, 4, 5, 6, 7, 8, 9, 10 ] -&gt; [ 1, 6, 4, 8, 2, 10, 7, 3, 9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := MathieuGroup(24);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := List([1..1000], x-&gt; Random(G));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append(mat, [1..1000]*0);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := List([1..138], x-&gt; List([1..57], x-&gt; Random(mat)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesZeroMatrixSemigroup(G, mat);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := Semigroup(List([1..200], x-&gt; Random(R)));</span>
&lt;subsemigroup of 57x138 Rees 0-matrix semigroup with 100 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(SmallGeneratingSet(U));</span>
84
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := RandomBipartitionSemigroup(100,4);</span>
&lt;bipartition semigroup on 4 pts with 96 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(SmallGeneratingSet(S));       </span>
13</pre></div>

<p><a id="X7F88DA9487720D2B" name="X7F88DA9487720D2B"></a></p>

<h5>15.3-3 IrredundantGeneratingSubset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IrredundantGeneratingSubset</code>( <var class="Arg">coll</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A list of irredundant generators.</p>

<p>If <var class="Arg">coll</var> is a collection of elements of a semigroup, then this function returns a subset <code class="code">U</code> of <var class="Arg">coll</var> such that no element of <code class="code">U</code> is generated by the other elements of <code class="code">U</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup( Transformation( [ 5, 1, 4, 6, 2, 3 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 1, 2, 3, 4, 5, 6 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 4, 6, 3, 4, 2, 5 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 5, 4, 6, 3, 1, 3 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 2, 2, 6, 5, 4, 3 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 3, 5, 5, 1, 2, 4 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 6, 5, 1, 3, 3, 4 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 1, 3, 4, 3, 2, 1 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IrredundantGeneratingSubset(S);</span>
[ Transformation( [ 1, 3, 4, 3, 2, 1 ] ), 
  Transformation( [ 2, 2, 6, 5, 4, 3 ] ), 
  Transformation( [ 3, 5, 5, 1, 2, 4 ] ), 
  Transformation( [ 5, 1, 4, 6, 2, 3 ] ), 
  Transformation( [ 5, 4, 6, 3, 1, 3 ] ), 
  Transformation( [ 6, 5, 1, 3, 3, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := RandomInverseMonoid(1000,10);</span>
&lt;inverse partial perm monoid on 10 pts with 1000 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SmallGeneratingSet(S);</span>
[ [ 1 .. 10 ] -&gt; [ 6, 5, 1, 9, 8, 3, 10, 4, 7, 2 ], 
  [ 1 .. 10 ] -&gt; [ 1, 4, 6, 2, 8, 5, 7, 10, 3, 9 ], 
  [ 1, 2, 3, 4, 6, 7, 8, 9 ] -&gt; [ 7, 5, 10, 1, 8, 4, 9, 6 ]
  [ 1 .. 9 ] -&gt; [ 4, 3, 5, 7, 10, 9, 1, 6, 8 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IrredundantGeneratingSubset(last);</span>
[ [ 1 .. 9 ] -&gt; [ 4, 3, 5, 7, 10, 9, 1, 6, 8 ], 
  [ 1 .. 10 ] -&gt; [ 1, 4, 6, 2, 8, 5, 7, 10, 3, 9 ], 
  [ 1 .. 10 ] -&gt; [ 6, 5, 1, 9, 8, 3, 10, 4, 7, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := RandomBipartitionSemigroup(1000,4);</span>
&lt;bipartition semigroup on 4 pts with 749 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SmallGeneratingSet(S);</span>
[ &lt;bipartition: [ 1, -3 ], [ 2, -2 ], [ 3, -1 ], [ 4, -4 ]&gt;, 
  &lt;bipartition: [ 1, 3, -2 ], [ 2, -1, -3 ], [ 4, -4 ]&gt;, 
  &lt;bipartition: [ 1, -4 ], [ 2, 4, -1, -3 ], [ 3, -2 ]&gt;, 
  &lt;bipartition: [ 1, -1, -3 ], [ 2, -4 ], [ 3, 4, -2 ]&gt;, 
  &lt;bipartition: [ 1, -2, -4 ], [ 2 ], [ 3, -3 ], [ 4, -1 ]&gt;, 
  &lt;bipartition: [ 1, -2 ], [ 2, -1, -3 ], [ 3, 4, -4 ]&gt;, 
  &lt;bipartition: [ 1, 3, -1 ], [ 2, -3 ], [ 4, -2, -4 ]&gt;, 
  &lt;bipartition: [ 1, -1 ], [ 2, 4, -4 ], [ 3, -2, -3 ]&gt;, 
  &lt;bipartition: [ 1, 3, -1 ], [ 2, -2 ], [ 4, -3, -4 ]&gt;, 
  &lt;bipartition: [ 1, 2, -2 ], [ 3, -1, -4 ], [ 4, -3 ]&gt;, 
  &lt;bipartition: [ 1, -2, -3 ], [ 2, -4 ], [ 3 ], [ 4, -1 ]&gt;, 
  &lt;bipartition: [ 1, -1 ], [ 2, 4, -3 ], [ 3, -2 ], [ -4 ]&gt;, 
  &lt;bipartition: [ 1, -3 ], [ 2, -1 ], [ 3, 4, -4 ], [ -2 ]&gt;, 
  &lt;bipartition: [ 1, 2, -4 ], [ 3, -1 ], [ 4, -2 ], [ -3 ]&gt;, 
  &lt;bipartition: [ 1, -3 ], [ 2, -4 ], [ 3, -1, -2 ], [ 4 ]&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IrredundantGeneratingSubset(last);</span>
[ &lt;bipartition: [ 1, 2, -4 ], [ 3, -1 ], [ 4, -2 ], [ -3 ]&gt;, 
  &lt;bipartition: [ 1, 3, -1 ], [ 2, -2 ], [ 4, -3, -4 ]&gt;, 
  &lt;bipartition: [ 1, 3, -2 ], [ 2, -1, -3 ], [ 4, -4 ]&gt;, 
  &lt;bipartition: [ 1, -1 ], [ 2, 4, -3 ], [ 3, -2 ], [ -4 ]&gt;, 
  &lt;bipartition: [ 1, -3 ], [ 2, -1 ], [ 3, 4, -4 ], [ -2 ]&gt;, 
  &lt;bipartition: [ 1, -3 ], [ 2, -2 ], [ 3, -1 ], [ 4, -4 ]&gt;, 
  &lt;bipartition: [ 1, -3 ], [ 2, -4 ], [ 3, -1, -2 ], [ 4 ]&gt;, 
  &lt;bipartition: [ 1, -2, -3 ], [ 2, -4 ], [ 3 ], [ 4, -1 ]&gt;, 
  &lt;bipartition: [ 1, -2, -4 ], [ 2 ], [ 3, -3 ], [ 4, -1 ]&gt; ]</pre></div>

<p><a id="X830E18747A0B5BED" name="X830E18747A0B5BED"></a></p>

<h4>15.4 <span class="Heading">
      Minimal ideals and multiplicative zeros
    </span></h4>

<p>In this section we describe the attributes of a semigroup that can be found using the <strong class="pkg">Semigroups</strong> package.</p>

<p><a id="X7BC68589879C3BE9" name="X7BC68589879C3BE9"></a></p>

<h5>15.4-1 MinimalIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalIdeal</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The minimal ideal of a semigroup.</p>

<p>The minimal ideal of a semigroup is the least ideal with respect to containment.</p>

<p>It is significantly easier to find the minimal \(\mathscr{D}\)-class of a semigroup, than to find its \(\mathscr{D}\)-classes.</p>

<p>See also <code class="func">RepresentativeOfMinimalIdeal</code> (<a href="chap15.html#X7CA6744182D07C5B"><span class="RefLink">15.4-2</span></a>), <code class="func">PartialOrderOfDClasses</code> (<a href="chap14.html#X83F1C306846DF26B"><span class="RefLink">14.1-10</span></a>), <code class="func">IsGreensLessThanOrEqual</code> (<a href="../../../doc/ref/chap51_mj.html#X7AA204C8850F9070"><span class="RefLink">Reference: IsGreensLessThanOrEqual</span></a>), and <code class="func">MinimalDClass</code> (<a href="chap14.html#X81E5A04F7DA3A1E1"><span class="RefLink">14.1-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 3, 4, 1, 3, 6, 3, 4, 6, 10, 1 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 8, 2, 3, 8, 4, 1, 3, 4, 9, 7 ] ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalIdeal(S);</span>
&lt;simple transformation semigroup ideal of degree 10 with 1 generator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Elements(MinimalIdeal(S));</span>
[ Transformation( [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), 
  Transformation( [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ] ), 
  Transformation( [ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ] ), 
  Transformation( [ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 ] ), 
  Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DClass(S, x);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(GreensDClasses(S), x-&gt; IsGreensLessThanOrEqual(D, x));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalIdeal(POI(10));</span>
&lt;partial perm group of rank 10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalIdeal(BrauerMonoid(6));</span>
&lt;simple bipartition semigroup ideal of degree 6 with 1 generator&gt;</pre></div>

<p><a id="X7CA6744182D07C5B" name="X7CA6744182D07C5B"></a></p>

<h5>15.4-2 RepresentativeOfMinimalIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RepresentativeOfMinimalIdeal</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RepresentativeOfMinimalDClass</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: An element of the minimal ideal of a semigroup.</p>

<p>The minimal ideal of a semigroup is the least ideal with respect to containment.</p>

<p>This method returns a representative element of the minimal ideal of <var class="Arg">S</var> without having to create the minimal ideal itself. In general, beyond being a member of the minimal ideal, the returned element is not guaranteed to have any special properties. However, the element will coincide with the zero element of <var class="Arg">S</var> if one exists.</p>

<p>This method works particularly well if <var class="Arg">S</var> is a semigroup of transformations or partial permutations.</p>

<p>See also <code class="func">MinimalIdeal</code> (<a href="chap15.html#X7BC68589879C3BE9"><span class="RefLink">15.4-1</span></a>) and <code class="func">MinimalDClass</code> (<a href="chap14.html#X81E5A04F7DA3A1E1"><span class="RefLink">14.1-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseSemigroup(10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentativeOfMinimalIdeal(S);</span>
&lt;empty partial perm&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Semigroup([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition( [ [ 1, 2 ], [ 3, 6, -2 ], [ 4, 5, -3, -4 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [ -1, -6 ], [ -5 ] ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition( [ [ 1, -1 ], [ 2 ], [ 3 ], [ 4, -3 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [ 5, 6, -5, -6 ], [ -2, -4 ] ] ) ]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentativeOfMinimalIdeal(B);</span>
&lt;bipartition: [ 1, 2 ], [ 3, 6 ], [ 4, 5 ], [ -1, -5, -6 ], 
 [ -2, -4 ], [ -3 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation( [ 5, 1, 6, 2, 2, 4 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation( [ 3, 5, 5, 1, 6, 2 ] ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentativeOfMinimalDClass(S);</span>
Transformation( [ 1, 2, 2, 5, 5, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalDClass(S);</span>
&lt;Green's D-class: Transformation( [ 1, 2, 2, 5, 5, 1 ] )&gt;</pre></div>

<p><a id="X7B39F93C8136D642" name="X7B39F93C8136D642"></a></p>

<h5>15.4-3 MultiplicativeZero</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MultiplicativeZero</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The zero element of a semigroup.</p>

<p><code class="code">MultiplicativeZero</code> returns the zero element of the semigroup <var class="Arg">S</var> if it exists and <code class="keyw">fail</code> if it does not. See also <code class="func">MultiplicativeZero</code> (<a href="../../../doc/ref/chap35_mj.html#X7B39F93C8136D642"><span class="RefLink">Reference: MultiplicativeZero</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup( Transformation( [ 1, 4, 2, 6, 6, 5, 2 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Transformation( [ 1, 6, 3, 6, 2, 1, 6 ] ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultiplicativeZero(S);</span>
Transformation( [ 1, 1, 1, 1, 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation( [ 2, 8, 3, 7, 1, 5, 2, 6 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation( [ 3, 5, 7, 2, 5, 6, 3, 8 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation( [ 6, 7, 4, 1, 4, 1, 6, 2 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation( [ 8, 8, 5, 1, 7, 5, 2, 8 ] ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultiplicativeZero(S);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm( [ 1, 3, 4 ], [ 5, 3, 1 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm( [ 1, 2, 3, 4 ], [ 4, 3, 1, 2 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm( [ 1, 3, 4, 5 ], [ 2, 4, 5, 3 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultiplicativeZero(S);</span>
&lt;empty partial perm&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := PartitionMonoid(6);</span>
&lt;regular bipartition monoid of degree 6 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultiplicativeZero(S);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := DualSymmetricInverseMonoid(6);</span>
&lt;inverse bipartition monoid of degree 6 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultiplicativeZero(S);</span>
&lt;block bijection: [ 1, 2, 3, 4, 5, 6, -1, -2, -3, -4, -5, -6 ]&gt;
</pre></div>

<p><a id="X7CAB17667ED5A6E8" name="X7CAB17667ED5A6E8"></a></p>

<h4>15.5 <span class="Heading">
      Group of units and identity elements
    </span></h4>

<p><a id="X811AEDD88280C277" name="X811AEDD88280C277"></a></p>

<h5>15.5-1 GroupOfUnits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupOfUnits</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The group of units of a semigroup or <code class="keyw">fail</code>.</p>

<p><code class="code">GroupOfUnits</code> returns the group of units of the semigroup <var class="Arg">S</var> as a subsemigroup of <var class="Arg">S</var> if it exists and returns <code class="keyw">fail</code> if it does not. Use <code class="func">IsomorphismPermGroup</code> (<a href="chap6.html#X80B7B1C783AA1567"><span class="RefLink">6.5-2</span></a>) if you require a permutation representation of the group of units.</p>

<p>If a semigroup <var class="Arg">S</var> has an identity <code class="code">e</code>, then the <em>group of units</em> of <var class="Arg">S</var> is the set of those <code class="code">s</code> in <var class="Arg">S</var> such that there exists <code class="code">t</code> in <var class="Arg">S</var> where <code class="code">s*t=t*s=e</code>. Equivalently, the group of units is the \(\mathscr{H}\)-class of the identity of <var class="Arg">S</var>.</p>

<p>See also <code class="func">GreensHClassOfElement</code> (<a href="../../../doc/ref/chap51_mj.html#X87C75A9D86122D93"><span class="RefLink">Reference: GreensHClassOfElement</span></a>), <code class="func">IsMonoidAsSemigroup</code> (<a href="chap17.html#X7E4DEECD7CD9886D"><span class="RefLink">17.1-11</span></a>), and <code class="func">MultiplicativeNeutralElement</code> (<a href="../../../doc/ref/chap35_mj.html#X7EE2EA5F7EB7FEC2"><span class="RefLink">Reference: MultiplicativeNeutralElement</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 1, 2, 5, 4, 3, 8, 7, 6 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 1, 6, 3, 4, 7, 2, 5, 8 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 2, 1, 6, 7, 8, 3, 4, 5 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 3, 2, 3, 6, 1, 6, 1, 2 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(S);</span>
5304
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(GroupOfUnits(S));</span>
"C2 x S4"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [ 2, 4, 5, 3, 6, 7, 10, 9, 8, 1 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm( [ 1, 2, 3, 4, 5, 6, 7, 8, 10 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [ 8, 2, 3, 1, 4, 5, 10, 6, 9 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(GroupOfUnits(S));</span>
"C8"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm( [ 1, 3, 4 ], [ 4, 3, 5 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm( [ 1, 2, 3, 5 ], [ 3, 1, 5, 2 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GroupOfUnits(S);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition( [ [ 1, 2, 3, -1, -3 ], [ -2 ] ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition( [ [ 1, -1 ], [ 2, 3, -2, -3 ] ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition( [ [ 1, -2 ], [ 2, -3 ], [ 3, -1 ] ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition( [ [ 1 ], [ 2, 3, -2 ], [ -1, -3 ] ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(GroupOfUnits(S));</span>
"C3"</pre></div>

<p><a id="X7C651C9C78398FFF" name="X7C651C9C78398FFF"></a></p>

<h4>15.6 <span class="Heading">
      Idempotents
    </span></h4>

<p><a id="X7C651C9C78398FFF" name="X7C651C9C78398FFF"></a></p>

<h5>15.6-1 Idempotents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Idempotents</code>( <var class="Arg">obj</var>[, <var class="Arg">n</var>] )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A list of idempotents.</p>

<p>The argument <var class="Arg">obj</var> should be a semigroup, \(\mathscr{D}\)-class, \(\mathscr{H}\)-class, \(\mathscr{L}\)-class, or \(\mathscr{R}\)-class.</p>

<p>If the optional second argument <var class="Arg">n</var> is present and <var class="Arg">obj</var> is a semigroup, then a list of the idempotents in <var class="Arg">obj</var> of rank <var class="Arg">n</var> is returned. If you are only interested in the idempotents of a given rank, then the second version of the function will probably be faster. However, if the optional second argument is present, then nothing is stored in <var class="Arg">obj</var> and so every time the function is called the computation must be repeated.</p>

<p>This functions produce essentially the same output as the <strong class="pkg">GAP</strong> library function with the same name; see <code class="func">Idempotents</code> (<a href="../../../doc/ref/chap35_mj.html#X7C651C9C78398FFF"><span class="RefLink">Reference: Idempotents</span></a>). The main difference is that this function can be applied to a wider class of objects as described above.</p>

<p>See also <code class="func">IsRegularDClass</code> (<a href="../../../doc/ref/chap51_mj.html#X7F5860927CAD920F"><span class="RefLink">Reference: IsRegularDClass</span></a>), <code class="func">IsRegularClass</code> (<a href="chap14.html#X813A259E8463B3A9"><span class="RefLink">14.3-2</span></a>) <code class="func">IsGroupHClass</code> (<a href="../../../doc/ref/chap51_mj.html#X79D740EF7F0E53BD"><span class="RefLink">Reference: IsGroupHClass</span></a>), <code class="func">NrIdempotents</code> (<a href="chap15.html#X7CFC4DB387452320"><span class="RefLink">15.6-2</span></a>), and <code class="func">GroupHClass</code> (<a href="chap14.html#X8723756387DD4C0F"><span class="RefLink">14.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([2, 3, 4, 1]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([3, 3, 1, 1]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Idempotents(S, 1);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSet(Idempotents(S, 2));</span>
[ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 3, 3, 1 ] ), 
  Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 4, 2, 2, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSet(Idempotents(S));</span>
[ Transformation( [ 1, 1, 3, 3 ] ), IdentityTransformation, 
  Transformation( [ 1, 3, 3, 1 ] ), Transformation( [ 2, 2, 4, 4 ] ), 
  Transformation( [ 4, 2, 2, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation([2, 2, 4, 4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := GreensRClassOfElement(S, x);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Idempotents(R);</span>
[ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 2, 2, 4, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Transformation([4, 2, 2, 4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := GreensLClassOfElement(S, x);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSet(Idempotents(L));</span>
[ Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 4, 2, 2, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DClassOfLClass(L);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSet(Idempotents(D));</span>
[ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 3, 3, 1 ] ), 
  Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 4, 2, 2, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := GreensLClassOfElement(S, Transformation([3, 1, 1, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSet(Idempotents(L));</span>
[ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 3, 3, 1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := GroupHClass(D);</span>
&lt;Green's H-class: Transformation( [ 1, 1, 3, 3 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Idempotents(H);</span>
[ Transformation( [ 1, 1, 3, 3 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 4, 5, 7], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            [10, 6, 3, 4, 9, 1]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 4, 5, 6, 7, 8], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            [6, 10, 7, 4, 8, 2, 9, 1]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Idempotents(S, 1);</span>
[ &lt;identity partial perm on [ 4 ]&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Idempotents(S, 0);</span>
[  ]</pre></div>

<p><a id="X7CFC4DB387452320" name="X7CFC4DB387452320"></a></p>

<h5>15.6-2 NrIdempotents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NrIdempotents</code>( <var class="Arg">obj</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A positive integer.</p>

<p>This function returns the number of idempotents in <var class="Arg">obj</var> where <var class="Arg">obj</var> can be a semigroup, \(\mathscr{D}\)-, \(\mathscr{L}\)-, \(\mathscr{H}\)-, or \(\mathscr{R}\)-class. If the actual idempotents are not required, then it is more efficient to use <code class="code">NrIdempotents(obj)</code> than <code class="code">Length(Idempotents(obj))</code> since the idempotents themselves are not created when <code class="code">NrIdempotents</code> is called.</p>

<p>See also <code class="func">Idempotents</code> (<a href="../../../doc/ref/chap35_mj.html#X7C651C9C78398FFF"><span class="RefLink">Reference: Idempotents</span></a>) and <code class="func">Idempotents</code> (<a href="chap15.html#X7C651C9C78398FFF"><span class="RefLink">15.6-1</span></a>), <code class="func">IsRegularDClass</code> (<a href="../../../doc/ref/chap51_mj.html#X7F5860927CAD920F"><span class="RefLink">Reference: IsRegularDClass</span></a>), <code class="func">IsRegularClass</code> (<a href="chap14.html#X813A259E8463B3A9"><span class="RefLink">14.3-2</span></a>) <code class="func">IsGroupHClass</code> (<a href="../../../doc/ref/chap51_mj.html#X79D740EF7F0E53BD"><span class="RefLink">Reference: IsGroupHClass</span></a>), and <code class="func">GroupHClass</code> (<a href="chap14.html#X8723756387DD4C0F"><span class="RefLink">14.4-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(Transformation([2, 3, 4, 1]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([3, 3, 1, 1]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(S);   </span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Transformation([2, 2, 4, 4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := GreensRClassOfElement(S, f);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(R);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Transformation([4, 2, 2, 4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := GreensLClassOfElement(S, f);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(L);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DClassOfLClass(L);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(D);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := GreensLClassOfElement(S, Transformation([3, 1, 1, 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(L);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := GroupHClass(D);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(H);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [6, 7, 2, 9, 1, 5, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 5, 6, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            [8, 1, 9, 4, 10, 5, 6, 7]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(S);</span>
236
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := PartialPerm([2, 3, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    [7, 2, 1, 5, 3]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DClassNC(S, f);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrIdempotents(D);</span>
13</pre></div>

<p><a id="X83970D028143B79B" name="X83970D028143B79B"></a></p>

<h5>15.6-3 IdempotentGeneratedSubsemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdempotentGeneratedSubsemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A semigroup.</p>

<p><code class="code">IdempotentGeneratedSubsemigroup</code> returns the subsemigroup of the semigroup <var class="Arg">S</var> generated by the idempotents of <var class="Arg">S</var>.</p>

<p>See also <code class="func">Idempotents</code> (<a href="chap15.html#X7C651C9C78398FFF"><span class="RefLink">15.6-1</span></a>) and <code class="func">SmallGeneratingSet</code> (<a href="chap15.html#X814DBABC878D5232"><span class="RefLink">15.3-2</span></a>).</p>


<div class="example"><pre> 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 1 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 2, 1 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 2 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 3, 4, 5, 1 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 3, 4, 5, 5 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 3, 4, 6, 5 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 3, 5, 4 ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 3, 7, 4, 5, 7 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 4, 8, 8, 3, 8, 7 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 1, 2, 8, 4, 5, 6, 7, 8 ] ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> Transformation( [ 7, 7, 7, 4, 5, 6, 1 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdempotentGeneratedSubsemigroup(S);</span>
&lt;transformation monoid of degree 8 with 19 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SymmetricInverseSemigroup(5);</span>
&lt;symmetric inverse monoid of degree 5&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdempotentGeneratedSubsemigroup(S);</span>
&lt;inverse partial perm monoid of rank 5 with 5 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := DualSymmetricInverseSemigroup(5); </span>
&lt;inverse bipartition monoid of degree 5 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdempotentGeneratedSubsemigroup(S);</span>
&lt;inverse bipartition monoid of degree 5 with 10 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSemilattice(last);</span>
true</pre></div>

<p><a id="X7D490B867CEFCBEF" name="X7D490B867CEFCBEF"></a></p>

<h4>15.7 <span class="Heading">
      Maximal subsemigroups
    </span></h4>

<p><a id="X80292361867AF3FE" name="X80292361867AF3FE"></a></p>

<h5>15.7-1 MaximalSubsemigroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalSubsemigroups</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The maximal subsemigroups of <var class="Arg">S</var>.</p>

<p>If <var class="Arg">S</var> is a semigroup, then <code class="code">MaximalSubsemigroups</code> returns a list of the maximal subsemigroups of <var class="Arg">S</var>.</p>

<p>A <em>maximal subsemigroup</em> of <var class="Arg">S</var> is a proper subsemigroup of <var class="Arg">S</var> which is contained in no other proper subsemigroups of <var class="Arg">S</var>.</p>

<p>The method for this function are based on <a href="chapBib.html#biBGraham1968aa">[GGR68]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := FullTransformationSemigroup(4);</span>
&lt;full transformation monoid of degree 4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalSubsemigroups(S);</span>
[ &lt;transformation semigroup of degree 4 with 3 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 5 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 4 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 4 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 5 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 5 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 5 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 5 generators&gt;, 
  &lt;transformation semigroup of degree 4 with 4 generators&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DClass(S, Transformation([2, 2]));</span>
&lt;Green's D-class: Transformation( [ 2, 3, 1, 2 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := PrincipalFactor(D);</span>
&lt;Rees 0-matrix semigroup 6x4 over Group([ (1,2,3), (1,2) ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalSubsemigroups(R);                                       </span>
[ &lt;Rees 0-matrix semigroup 6x3 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 6x3 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 6x3 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 6x3 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 5x4 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 5x4 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 5x4 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 5x4 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 5x4 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;Rees 0-matrix semigroup 5x4 over Group([ (1,2,3), (1,2) ])&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 23 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 23 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 21 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 23 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 21 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 21 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 23 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 21 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 21 generators&gt;, 
  &lt;subsemigroup of 6x4 Rees 0-matrix semigroup with 21 generators&gt; ]</pre></div>

<p><a id="X7C39DC3C85462681" name="X7C39DC3C85462681"></a></p>

<h5>15.7-2 MaximalSubsemigroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalSubsemigroups</code>( <var class="Arg">R</var>, <var class="Arg">H</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The maximal subsemigroups of a Rees (0)-matrix semigroup corresponding to a maximal subgroup of the underlying group.</p>

<p>Suppose that <var class="Arg">R</var> is a regular Rees (0-)matrix semigroup of the form <span class="SimpleMath">mathcalM[G; I, J; P]</span> where <span class="SimpleMath">G</span> is a group and <span class="SimpleMath">P</span> is a <span class="SimpleMath">|J|</span> by <span class="SimpleMath">|I|</span> matrix with entries in <span class="SimpleMath">G∪{0}</span> . If <var class="Arg">H</var> is a maximal subgroup of <span class="SimpleMath">G</span>, then this function returns the maximal subsemigroups of <var class="Arg">R</var> which are isomorphic to <span class="SimpleMath">mathcalM[H; I, J; P]</span>.</p>

<p>The method used in this function is based on Remark 1 of <a href="chapBib.html#biBGraham1968aa">[GGR68]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesZeroMatrixSemigroup(Group([(1, 2), (3, 4)]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ [ (), (1,2) ], [ (), (1,2) ] ]);</span>
&lt;Rees 0-matrix semigroup 2x2 over Group([ (1,2), (3,4) ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := UnderlyingSemigroup(R);</span>
Group([ (1,2), (3,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Group((1,2));  </span>
Group([ (1,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">max := MaximalSubsemigroups(R, H);</span>
[ &lt;subsemigroup of 2x2 Rees 0-matrix semigroup with 6 generators&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalSubsemigroup(R, max[1]);</span>
true</pre></div>

<p><a id="X82D74C2478A49FD5" name="X82D74C2478A49FD5"></a></p>

<h5>15.7-3 IsMaximalSubsemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMaximalSubsemigroup</code>( <var class="Arg">S</var>, <var class="Arg">T</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>If <var class="Arg">S</var> and <var class="Arg">T</var> are semigroups, then <code class="code">IsMaximalSubsemigroup</code> returns true if and only if <var class="Arg">T</var> is a maximal subsemigroup of <var class="Arg">S</var>.</p>

<p>A proper subsemigroup <var class="Arg">T</var> of a semigroup <var class="Arg">S</var> is a <em>maximal</em> if <var class="Arg">T</var> is not contained in any other proper subsemigroups of <var class="Arg">S</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := FullTransformationSemigroup(4);                              </span>
&lt;full transformation monoid of degree 4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := Semigroup(Transformation([3, 4, 1, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([1, 4, 2, 3]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([2, 1, 1, 3]));</span>
&lt;transformation semigroup of degree 4 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalSubsemigroup(S, T);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := Semigroup(Transformation([3, 4, 1, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([1, 4, 2, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Transformation([2, 1, 1, 3]));</span>
&lt;transformation semigroup of degree 4 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalSubsemigroup(S, R); </span>
false</pre></div>

<p><a id="X7E654D0D8427A001" name="X7E654D0D8427A001"></a></p>

<h4>15.8 <span class="Heading">
      The normalizer of a semigroup
    </span></h4>

<p><a id="X87C024AE814BC9D8" name="X87C024AE814BC9D8"></a></p>

<h5>15.8-1 Normalizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Normalizer</code>( <var class="Arg">G</var>, <var class="Arg">S</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Normalizer</code>( <var class="Arg">S</var>[, <var class="Arg">opts</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p>In its first form, this function returns the normalizer of the transformation, partial perm, or bipartition semigroup <var class="Arg">S</var> in the permutation group <var class="Arg">G</var>. In its second form, the normalizer of <var class="Arg">S</var> in the symmetric group on <code class="code">[1 .. n]</code> where <code class="code">n</code> is the degree of <var class="Arg">S</var> is returned.</p>

<p>The <strong class="button">normalizer</strong> of a transformation semigroup <var class="Arg">S</var> in a permutation group <var class="Arg">G</var> in the subgroup <code class="code">H</code> of <var class="Arg">G</var> consisting of those elements in <code class="code">g</code> in <var class="Arg">G</var> conjugating <var class="Arg">S</var> to <var class="Arg">S</var>, i.e. <code class="code"><var class="Arg">S</var> ^ g = <var class="Arg">S</var></code>.</p>

<p>Analogous definitions can be given for a partial perm and bipartition semigroups.</p>

<p>The method used by this operation is based on Section 3 in <a href="chapBib.html#biBAraujo2010aa">[ABMN10]</a>.</p>

<p>The optional final argument <var class="Arg">opts</var> allows you to specify various options, which determine how the normalizer is calculated. The values of these options can dramatically change the time it takes for this operation to complete. In different situations, different options give the best performance.</p>

<p>The argument <var class="Arg">opts</var> should be a record, and the available options are:</p>


<dl>
<dt><strong class="Mark">random</strong></dt>
<dd><p>If this option has the value <code class="keyw">true</code>, then the non-deterministic algorithms in <span class="URL"><a href=" http://www-groups.mcs.st-and.ac.uk/~neunhoef/Computer/Software/Gap/genss.html ">genss</a></span> are used in <code class="code">Normalizer</code>. So, there is some chance that <code class="code">Normalizer</code> will return an incorrect result in this case, but these methods can also be much faster than the deterministic algorithms which are used if this option is <code class="keyw">false</code>.</p>

<p>The default value for this option is <code class="keyw">false</code>.</p>

</dd>
<dt><strong class="Mark">lambdastab</strong></dt>
<dd><p>If this option has the value <code class="keyw">true</code>, then <code class="code">Normalizer</code> initially finds the setwise stabilizer of the images or right blocks of the semigroup <var class="Arg">S</var>. Sometimes this improves the performance of <code class="code">Normalizer</code> and sometimes it does not. If this option in <code class="keyw">false</code>, then this setwise stabilizer is not found.</p>

<p>The default value for this option is <code class="keyw">true</code>.</p>

</dd>
<dt><strong class="Mark">rhostab</strong></dt>
<dd><p>If this option has the value <code class="keyw">true</code>, then <code class="code">Normalizer</code> initially finds the setwise stabilizer of the kernels, domains, or left blocks of the semigroup <var class="Arg">S</var>. Sometimes this improves the performance of <code class="code">Normalizer</code> and sometimes it does not. If this option is <code class="keyw">false</code>, the this setwise stabilizer is not found.</p>

<p>If <var class="Arg">S</var> is an inverse semigroup, then this option is ignored.</p>

<p>The default value for this option is <code class="keyw">true</code>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := BrauerMonoid(8);</span>
&lt;regular bipartition monoid on 8 pts with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription(Normalizer(S));</span>
"S8"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := InverseSemigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 4, 5], [2, 5, 6, 3, 8]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 4, 7, 8], [3, 6, 2, 5, 7]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Normalizer(S, rec(random:=true, lambdastab:=false));</span>
#I  Have 33389 points.
#I  Have 40136 points in new orbit.
Group(())</pre></div>

<p><a id="X786F25478029619D" name="X786F25478029619D"></a></p>

<h4>15.9 <span class="Heading">
      Attributes of transformation semigroups
    </span></h4>

<p><a id="X8065DBC48722B085" name="X8065DBC48722B085"></a></p>

<h5>15.9-1 ComponentRepsOfTransformationSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComponentRepsOfTransformationSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The representatives of components of a transformation semigroup.</p>

<p>This function returns the representatives of the components of the action of the transformation semigroup <var class="Arg">S</var> on the set of positive integers not greater than the degree of <var class="Arg">S</var>.</p>

<p>The representatives are the least set of points such that every point can be reached from some representative under the action of <var class="Arg">S</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComponentRepsOfTransformationSemigroup(S);</span>
[ 2, 3, 8 ]</pre></div>

<p><a id="X8706A72A7F3EE532" name="X8706A72A7F3EE532"></a></p>

<h5>15.9-2 ComponentsOfTransformationSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComponentsOfTransformationSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The components of a transformation semigroup.</p>

<p>This function returns the components of the action of the transformation semigroup <var class="Arg">S</var> on the set of positive integers not greater than the degree of <var class="Arg">S</var>; the components of <var class="Arg">S</var> partition this set.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComponentsOfTransformationSemigroup(S);</span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ] ]</pre></div>

<p><a id="X7AA697B186301F54" name="X7AA697B186301F54"></a></p>

<h5>15.9-3 CyclesOfTransformationSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CyclesOfTransformationSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The cycles of a transformation semigroup.</p>

<p>This function returns the cycles, or strongly connected components, of the action of the transformation semigroup <var class="Arg">S</var> on the set of positive integers not greater than the degree of <var class="Arg">S</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([11, 11, 9, 6, 4, 1, 4, 1, 6, 7, 12, 5]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([12, 10, 7, 10, 4, 1, 12, 9, 11, 9, 1, 12]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CyclesOfTransformationSemigroup(S);</span>
[ [ 12 ], [ 1, 11 ], [ 1, 11, 12, 5, 4, 6 ], 
  [ 1, 11, 12, 5, 4, 10, 9, 6 ], [ 1, 12, 5, 4, 6 ], 
  [ 1, 12, 5, 4, 10, 9, 6 ], [ 1, 12, 5, 4, 10, 9, 11 ], 
  [ 11, 12, 5, 4, 10, 9 ], [ 12, 5, 4, 10, 7 ], [ 4, 10, 7 ] ]</pre></div>

<p><a id="X83DA161F875F63B1" name="X83DA161F875F63B1"></a></p>

<h5>15.9-4 IsTransitive</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTransitive</code>( <var class="Arg">S</var>[, <var class="Arg">X</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTransitive</code>( <var class="Arg">S</var>[, <var class="Arg">n</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>A transformation semigroup <var class="Arg">S</var> is <em>transitive</em> or <em>strongly connected</em> on the set <var class="Arg">X</var> if for every <code class="code">i, j</code> in <var class="Arg">X</var> there is an element <code class="code">s</code> in <var class="Arg">S</var> such that <code class="code">i ^ s = j</code>.</p>

<p>If the optional second argument is a positive integer <var class="Arg">n</var>, then <code class="code">IsTransitive</code> returns <code class="keyw">true</code> if <var class="Arg">S</var> is transitive on <code class="code">[1 .. <var class="Arg">n</var>]</code>, and <code class="keyw">false</code> if it is not.</p>

<p>If the optional second argument is not provided, then the degree of <var class="Arg">S</var> is used by default; see <code class="func">DegreeOfTransformationSemigroup</code> (<a href="../../../doc/ref/chap53_mj.html#X7EA699C687952544"><span class="RefLink">Reference: DegreeOfTransformationSemigroup</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup([Bipartition([[1, 2], [3, 6, -2], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[4, 5, -3, -4], [-1, -6], [-5]]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Bipartition([[1, -4], [2, 3, 4, 5], [6], [-1, -6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[-2, -3], [-5]])]);</span>
&lt;bipartition semigroup of degree 6 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsTransformationSemigroup(S);</span>
&lt;transformation semigroup of degree 12 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitive(last);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitive(AsSemigroup(Group((1,2,3))));</span>
true</pre></div>

<p><a id="X7C65202187A9C9F5" name="X7C65202187A9C9F5"></a></p>

<h5>15.9-5 SmallestElementSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SmallestElementSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LargestElementSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A transformation.</p>

<p>These attributes return the smallest and largest element of the transformation semigroup <var class="Arg">S</var>, respectively. Smallest means the first element in the sorted set of elements of <var class="Arg">S</var> and largest means the last element in the set of elements.</p>

<p>It is not necessary to find the elements of the semigroup to determine the smallest or largest element, and this function has considerable better performance than the equivalent <code class="code">Elements(<var class="Arg">S</var>)[1]</code> and <code class="code">Elements(<var class="Arg">S</var>)[Size(<var class="Arg">S</var>)]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([1, 4, 11, 11, 7, 2, 6, 2, 5, 5, 10]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([2, 4, 4, 2, 10, 5, 11, 11, 11, 6, 7]));</span>
&lt;transformation monoid of degree 11 with 2 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SmallestElementSemigroup(S);</span>
IdentityTransformation
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LargestElementSemigroup(S);</span>
Transformation( [ 11, 11, 10, 10, 7, 6, 5, 6, 2, 2, 4 ] )</pre></div>

<p><a id="X83B3BBCD783B3408" name="X83B3BBCD783B3408"></a></p>

<h5>15.9-6 GeneratorsSmallest</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneratorsSmallest</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A generating set of transformations.</p>

<p><code class="code">GeneratorsSmallest</code> returns the lexicographically least collection <code class="code">X</code> of transformations such that <var class="Arg">S</var> is generated by <code class="code">X</code> and each <code class="code">X[i]</code> is not generated by <code class="code">X[1], X[2], ..., X[i-1]</code>.</p>

<p>Note that it can be difficult to find this set of generators, and that it might contain a substantial proportion of the elements of the semigroup.</p>

<p>The comparison of two transformation semigroups via the lexicographic comparison of their sets of elements is the same relation as the lexicographic comparison of their <code class="code">GeneratorsSmallest</code>. However, due to the complexity of determining the <code class="code">GeneratorsSmallest</code>, this is not the method used by the <strong class="pkg">Semigroups</strong> package when comparing transformation semigroups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Monoid(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([1, 3, 4, 1]), Transformation([2, 4, 1, 2]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Transformation([3, 1, 1, 3]), Transformation([3, 3, 4, 1]));</span>
&lt;transformation monoid of degree 4 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsSmallest(S);</span>
[ Transformation( [ 1, 1, 1, 1 ] ), Transformation( [ 1, 1, 1, 2 ] ), 
  Transformation( [ 1, 1, 1, 3 ] ), Transformation( [ 1, 1, 1 ] ), 
  Transformation( [ 1, 1, 2, 1 ] ), Transformation( [ 1, 1, 2, 2 ] ), 
  Transformation( [ 1, 1, 3, 1 ] ), Transformation( [ 1, 1, 3, 3 ] ), 
  Transformation( [ 1, 1 ] ), Transformation( [ 1, 1, 4, 1 ] ), 
  Transformation( [ 1, 2, 1, 1 ] ), Transformation( [ 1, 2, 2, 1 ] ), 
  IdentityTransformation, Transformation( [ 1, 3, 1, 1 ] ), 
  Transformation( [ 1, 3, 4, 1 ] ), Transformation( [ 2, 1, 1, 2 ] ), 
  Transformation( [ 2, 2, 2 ] ), Transformation( [ 2, 4, 1, 2 ] ), 
  Transformation( [ 3, 3, 3 ] ), Transformation( [ 3, 3, 4, 1 ] ) ]</pre></div>

<p><a id="X84B8E29C7D7565B0" name="X84B8E29C7D7565B0"></a></p>

<h4>15.10 <span class="Heading">
      Attributes of partial perm semigroups
    </span></h4>

<p><a id="X7BC22CB47C7B5EBB" name="X7BC22CB47C7B5EBB"></a></p>

<h5>15.10-1 ComponentRepsOfPartialPermSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComponentRepsOfPartialPermSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The representatives of components of a partial perm semigroup.</p>

<p>This function returns the representatives of the components of the action of the partial perm semigroup <var class="Arg">S</var> on the set of positive integers where it is defined.</p>

<p>The representatives are the least set of points such that every point can be reached from some representative under the action of <var class="Arg">S</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 5, 6, 7, 8, 11, 12, 16, 19], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [9, 18, 20, 11, 5, 16, 8, 19, 14, 13, 1]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 16, 18, 19, 20], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [13, 1, 8, 5, 4, 14, 11, 12, 9, 20, 2, 18, 7, 3, 19]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComponentRepsOfPartialPermSemigroup(S);</span>
[ 1, 4, 6, 10, 15, 17 ]</pre></div>

<p><a id="X8464BC397ACBF2F1" name="X8464BC397ACBF2F1"></a></p>

<h5>15.10-2 ComponentsOfPartialPermSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComponentsOfPartialPermSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The components of a partial perm semigroup.</p>

<p>This function returns the components of the action of the partial perm semigroup <var class="Arg">S</var> on the set of positive integers where it is defined; the components of <var class="Arg">S</var> partition this set.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 5, 6, 7, 8, 11, 12, 16, 19], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [9, 18, 20, 11, 5, 16, 8, 19, 14, 13, 1]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 16, 18, 19, 20], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [13, 1, 8, 5, 4, 14, 11, 12, 9, 20, 2, 18, 7, 3, 19]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComponentsOfPartialPermSemigroup(S);</span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 19, 20 ], 
  [ 15 ], [ 17 ] ]</pre></div>

<p><a id="X832937BB87EB4349" name="X832937BB87EB4349"></a></p>

<h5>15.10-3 CyclesOfPartialPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CyclesOfPartialPerm</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The cycles of a partial perm.</p>

<p>This function returns the cycles, or strongly connected components, of the action of the partial perm <var class="Arg">x</var> on the set of positive integers where it is defined.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := PartialPerm([1, 2, 3, 4, 5, 8, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [3, 1, 4, 2, 5, 6, 7]);</span>
[8,6][10,7](1,3,4,2)(5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CyclesOfPartialPerm(x);</span>
[ [ 3, 4, 2, 1 ], [ 5 ] ]</pre></div>

<p><a id="X7F7A5E5E8355E230" name="X7F7A5E5E8355E230"></a></p>

<h5>15.10-4 CyclesOfPartialPermSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CyclesOfPartialPermSemigroup</code>( <var class="Arg">S</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The cycles of a partial perm semigroup.</p>

<p>This function returns the cycles, or strongly connected components, of the action of the partial perm semigroup <var class="Arg">S</var> on the set of positive integers where it is defined.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Semigroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">PartialPerm([1, 2, 3, 5, 6, 7, 8, 11, 12, 16, 19], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [9, 18, 20, 11, 5, 16, 8, 19, 14, 13, 1]), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> PartialPerm([1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 16, 18, 19, 20], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [13, 1, 8, 5, 4, 14, 11, 12, 9, 20, 2, 18, 7, 3, 19]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CyclesOfPartialPermSemigroup(S);</span>
[ [ 1, 9, 12, 14, 2, 20, 19, 3, 8, 11 ] ]</pre></div>

<p><a id="X7AF313CF7CBE98D7" name="X7AF313CF7CBE98D7"></a></p>

<h4>15.11 <span class="Heading">
      Attributes of Rees (0-)matrix semigroups
    </span></h4>

<p><a id="X7EA1B28785B9D38C" name="X7EA1B28785B9D38C"></a></p>

<h5>15.11-1 RZMSDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RZMSDigraph</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A digraph.</p>

<p>If <var class="Arg">R</var> is an <span class="SimpleMath">n</span> by <span class="SimpleMath">m</span> Rees 0-matrix semigroup <span class="SimpleMath">M^0[I, T, Λ; P]</span> (so that <span class="SimpleMath">I = {1,2,...,n}</span> and <span class="SimpleMath">Λ = {1,2,...,m}</span>) then <code class="code">RZMSDigraph</code> returns a symmetric bipartite digraph with <span class="SimpleMath">n+m</span> vertices. An index <span class="SimpleMath">i ∈ I</span> corresponds to the vertex <span class="SimpleMath">i</span> and an index <span class="SimpleMath">j ∈ Λ</span> corresponds to the vertex <span class="SimpleMath">j + n</span>.</p>

<p>Two vertices <span class="SimpleMath">v</span> and <span class="SimpleMath">w</span> in <code class="code">RZMSDigraph(</code><var class="Arg">R</var><code class="code">)</code> are adjacent if and only if <span class="SimpleMath">v∈ I</span>, <span class="SimpleMath">w - n∈ Λ</span>, and <code class="code">P[w - n][v]</code> <span class="SimpleMath">≠ 0</span>.</p>

<p>This digraph is commonly called the <em>Graham-Houghton graph</em> of <var class="Arg">R</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := PrincipalFactor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DClass(FullTransformationMonoid(5),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Transformation( [ 2, 4, 1, 5, 5 ] )));</span>
&lt;Rees 0-matrix semigroup 10x5 over Group([ (1,2,3,4), (1,2) ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := RZMSDigraph(R);</span>
&lt;digraph with 15 vertices, 40 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := DigraphEdges(gr)[1];</span>
[ 1, 11 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Matrix(R)[e[2] - 10][e[1]] &lt;&gt; 0;</span>
true</pre></div>

<p><a id="X79B062917AB34542" name="X79B062917AB34542"></a></p>

<h5>15.11-2 RZMSConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RZMSConnectedComponents</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The connected components of a Rees 0-matrix semigroup.</p>

<p>If <var class="Arg">R</var> is an <span class="SimpleMath">n</span> by <span class="SimpleMath">m</span> Rees 0-matrix semigroup <span class="SimpleMath">M^0[I, T, Λ; P]</span> (so that <span class="SimpleMath">I = {1,2,...,n}</span> and <span class="SimpleMath">Λ = {1,2,...,m}</span>) then <code class="code">RZMSConnectedComponents</code> returns the connected components of <var class="Arg">R</var>.</p>

<p><em>Connectedness</em> is an equivalence relation on the indices of <var class="Arg">R</var>: the equivalence classes of the relation are called the <em>connected components</em> of <var class="Arg">R</var>, and two indices in <span class="SimpleMath">I ∪ Λ</span> are connected if and only if their corresponding vertices in <code class="code">RZMSDigraph(</code><var class="Arg">R</var><code class="code">)</code> are connected (see <code class="func">RZMSDigraph</code> (<a href="chap15.html#X7EA1B28785B9D38C"><span class="RefLink">15.11-1</span></a>)). If <var class="Arg">R</var> has <span class="SimpleMath">n</span> connected components, then <code class="code">RZMSConnectedComponents</code> will return a list of pairs:</p>

<p><code class="code">[ [ </code><span class="SimpleMath">I_1, Λ_1</span><code class="code"> ], </code><span class="SimpleMath">...</span><code class="code">, [ </code><span class="SimpleMath">I_k, Λ_k</span><code class="code"> ] ]</code></p>

<p>where <span class="SimpleMath">I = I_1 ⊔ ⋯ ⊔ I_k</span>, <span class="SimpleMath">Λ = Λ_1 ⊔ ⋯ ⊔ Λ_k</span>, and for each <span class="SimpleMath">l</span> the set <span class="SimpleMath">I_l∪Λ_l</span> is a connected component of <var class="Arg">R</var>. Note that at most one of <span class="SimpleMath">I_l</span> and <span class="SimpleMath">Λ_l</span> is possibly empty. The ordering of the connected components in the result in unspecified.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesZeroMatrixSemigroup(SymmetricGroup(5),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ [ (), 0, (1,3), (4,5), 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, (), 0, 0, (1,3,4,5) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, (1,5)(2,3), 0, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, (2,3)(1,4), 0, 0, 0 ] ]);</span>
&lt;Rees 0-matrix semigroup 5x4 over Sym( [ 1 .. 5 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RZMSConnectedComponents(R);</span>
[ [ [ 1, 3, 4 ], [ 1, 3 ] ], [ [ 2, 5 ], [ 2, 4 ] ] ]</pre></div>

<p><a id="X870210EA7912B52A" name="X870210EA7912B52A"></a></p>

<h5>15.11-3 RZMSNormalization</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RZMSNormalization</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: An isomorphism.</p>

<p>If <var class="Arg">R</var> is an <span class="SimpleMath">n</span> by <span class="SimpleMath">m</span> Rees 0-matrix semigroup <span class="SimpleMath">M^0[I, T, Λ; P]</span> then <code class="code">RZMSNormalization</code> returns an isomorphism from <var class="Arg">R</var> to a Rees 0-matrix semigroup <span class="SimpleMath">S = M^0[I, T, Λ; Q]</span>. The structure matrix <span class="SimpleMath">Q</span> is obtained by <em>normalizing</em> <span class="SimpleMath">P</span> (see <code class="func">Matrix</code> (<a href="../../../doc/ref/chap51_mj.html#X879384D479EB1D82"><span class="RefLink">Reference: Matrix</span></a>)) and has the following properties:</p>


<ul>
<li><p>The matrix <span class="SimpleMath">Q</span> is in block diagonal form, and the blocks are ordered by decreasing size along the leading diagonal. The blocks are the <code class="func">RZMSConnectedComponents</code> (<a href="chap15.html#X79B062917AB34542"><span class="RefLink">15.11-2</span></a>) of <var class="Arg">S</var>.</p>

</li>
<li><p>If <span class="SimpleMath">Q</span> has any rows/columns consisting entries of zeroes, then they will be the final rows/columns of <span class="SimpleMath">Q</span>.</p>

</li>
<li><p>If <span class="SimpleMath">T</span> is a group, then the first non-zero entry of every row and every column is equal to <span class="SimpleMath">1_T</span>.</p>

</li>
<li><p>The first non-zero entry of a row occurs no sooner than the first non-zero entry of the previous row.</p>

</li>
<li><p>The first non-zero entry of a column occurs no sooner than the first non-zero entry of the previous column.</p>

</li>
</ul>
<p>If <span class="SimpleMath">T</span> is a group, then the non-zero entries of <span class="SimpleMath">Q</span> are chosen so that <span class="SimpleMath">S</span> has an additional property. Let the index sets <span class="SimpleMath">I</span> and <span class="SimpleMath">Λ</span> be decomposed according to the <code class="func">RZMSConnectedComponents</code> (<a href="chap15.html#X79B062917AB34542"><span class="RefLink">15.11-2</span></a>) of <span class="SimpleMath">S</span>, giving that <span class="SimpleMath">I=I_1⊔...⊔ I_k</span> and <span class="SimpleMath">Λ=Λ_1⊔...⊔Λ_k</span>. For each <span class="SimpleMath">r</span> let <span class="SimpleMath">Q_r</span> be the sub-matrix of <span class="SimpleMath">Q</span> defined by <span class="SimpleMath">I_r</span> and <span class="SimpleMath">Λ_r</span>, and let <span class="SimpleMath">T_r</span> be the subgroup of <span class="SimpleMath">T</span> generated by the non-zero entries of <span class="SimpleMath">Q_r</span>. Then the idempotent generated subsemigroup of <span class="SimpleMath">S</span> is equal to:</p>


<ul>
<li><p><span class="SimpleMath">⋃_r = 1^k M^0[I_r, T_r, Λ_r, Q_r]</span>, where the zeroes of these Rees 0-matrix semigroups are all identified with the zero of <span class="SimpleMath">S</span>.</p>

</li>
</ul>
<p>The normalization given by <code class="code">RZMSNormalization</code> is based on Theorem 2 of <a href="chapBib.html#biBGraham1968Graph">[Gra68]</a> and is sometimes called <em>Graham normal form</em>. Note that isomorphic Rees 0-matrix semigroups can have normalizations which are not equal.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesZeroMatrixSemigroup(Group(()),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ [ 0, (), 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ (), 0, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, () ] ]);</span>
&lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := RZMSNormalization(R);</span>
MappingByFunction( &lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;, 
&lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;
 , function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Range(iso);</span>
&lt;Rees 0-matrix semigroup 3x3 over Group(())&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Matrix(S);</span>
[ [ (), 0, 0 ], [ 0, (), 0 ], [ 0, 0, () ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesZeroMatrixSemigroup(SymmetricGroup(4),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ [ 0, 0, 0, (1,3,2) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ (2,3), 0, 0, 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, 0, (1,3), (1,2) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 0, (4,1,2,3), 0, 0 ] ]);</span>
&lt;Rees 0-matrix semigroup 4x4 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Range(RZMSNormalization(R));</span>
&lt;Rees 0-matrix semigroup 4x4 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Matrix(S);</span>
[ [ (), (), 0, 0 ], [ 0, (), 0, 0 ], [ 0, 0, (), 0 ], [ 0, 0, 0, () ] 
 ]</pre></div>

<p><a id="X80DE617E841E5BA0" name="X80DE617E841E5BA0"></a></p>

<h5>15.11-4 RMSNormalization</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RMSNormalization</code>( <var class="Arg">R</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: An isomorphism.</p>

<p>If <var class="Arg">R</var> is a Rees matrix semigroup over a group <code class="code">G</code>, then <code class="code">RMSNormalization</code> returns an isomorphism from <var class="Arg">R</var> to a <em>normalized</em> Rees matrix semigroup <code class="code">S</code> over <code class="code">G</code>.</p>

<p>The semigroup <code class="code">S</code> is normalized in the sense that the first entry of each row and column of the <code class="func">Matrix</code> (<a href="../../../doc/ref/chap51_mj.html#X879384D479EB1D82"><span class="RefLink">Reference: Matrix</span></a>) of <code class="code">S</code> is the identity of <code class="code">G</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReesMatrixSemigroup(SymmetricGroup(4),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ [ (1,2), (2,4,3), (2,1,4) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ (1,3,2), (1,2)(3,4), () ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ (2,3), (1,3,2,4), (2,3) ] ]);</span>
&lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := RMSNormalization(R);</span>
MappingByFunction( &lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
 , &lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
 , function( x ) ... end, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Range(iso);</span>
&lt;Rees matrix semigroup 3x3 over Sym( [ 1 .. 4 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Matrix(S);</span>
[ [ (), (), () ], [ (), (1,2), (1,4,2,3) ], [ (), (1,4,2,3), (2,4) ] ]</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap14.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap16.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
