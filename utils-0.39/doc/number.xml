<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  number.xml          Utils documentation                Stefan Kohl -->
<!--                                                                     -->
<!--  Copyright (C) 2015-2016, The GAP Group,                            --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-number">
<Heading>Number-theoretic functions</Heading>



<Section Label="sec-integers">
<Heading>Functions for integers</Heading>


<ManSection>
   <Func Name="AllSmoothIntegers"
         Arg="maxp maxn" />
<Description>
This function is in the process of being transferred from package &RCWA;: 
for now you should &LoadRCWA; in order to use it. 
<P/>
The function <C>AllSmoothIntegers(<A>maxp</A>,<A>maxn</A>)</C>
returns a list of all integers less than or equal to <A>maxn</A> which do
not have prime divisors exceeding <A>maxp</A>.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> AllSmoothIntegers( 7, 100 );
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, 28, 
  30, 32, 35, 36, 40, 42, 45, 48, 49, 50, 54, 56, 60, 63, 64, 70, 72, 75, 80, 
  81, 84, 90, 96, 98, 100 ]
gap> Length(last);
46
]]>
</Example>

<ManSection>
   <Func Name="AllProducts"
         Arg="L, k" />
<Description>
This function has been transferred from package &RCWA;. 
<P/>
The command <C>AllProducts(<A>L</A>,<A>k</A>)</C> returns the list of
all products of <A>k</A> entries of the list&nbsp;<A>L</A>. 
Note that every ordering of the entries is used so that, in the commuting case, 
there are bound to be repetitions.  
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> AllProducts([1..4],3); 
[ 1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12, 4, 8, 12, 16, 2, 4, 6, 8, 4, 8, 12, 
  16, 6, 12, 18, 24, 8, 16, 24, 32, 3, 6, 9, 12, 6, 12, 18, 24, 9, 18, 27, 
  36, 12, 24, 36, 48, 4, 8, 12, 16, 8, 16, 24, 32, 12, 24, 36, 48, 16, 32, 
  48, 64 ]
gap> Set(last);            
[ 1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 27, 32, 36, 48, 64 ]
gap> AllProducts( [(1,2,3),(2,3,4)], 2 );
[ (2,4,3), (1,2)(3,4), (1,3)(2,4), (1,3,2) ]
]]>
</Example>

<ManSection>
   <Func Name="RestrictedPartitionsWithoutRepetitions"
         Arg="n,S" />
<Description>
This function is in the process of being transferred from package &RCWA;: 
for now you should &LoadRCWA; in order to use it. 
<P/>
Given a positive integer <A>n</A> and a set of positive integers <A>S</A>, 
this function returns a list of all partitions of <A>n</A> 
into distinct elements of <A>S</A>.
The only difference to <C>RestrictedPartitions</C> 
is that no repetitions are allowed.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> RestrictedPartitions( 20, [4..10] );
[ [ 4, 4, 4, 4, 4 ], [ 5, 5, 5, 5 ], [ 6, 5, 5, 4 ], [ 6, 6, 4, 4 ], 
  [ 7, 5, 4, 4 ], [ 7, 7, 6 ], [ 8, 4, 4, 4 ], [ 8, 6, 6 ], [ 8, 7, 5 ], 
  [ 8, 8, 4 ], [ 9, 6, 5 ], [ 9, 7, 4 ], [ 10, 5, 5 ], [ 10, 6, 4 ], 
  [ 10, 10 ] ]
gap> RestrictedPartitionsWithoutRepetitions( 20, [4..10] );
[ [ 10, 6, 4 ], [ 9, 7, 4 ], [ 9, 6, 5 ], [ 8, 7, 5 ] ]
]]>
</Example>

<ManSection>
   <Func Name="ExponentOfPrime"
         Arg="n p" />
<Description>
This function is in the process of being transferred from package &RCWA;: 
for now you should &LoadRCWA; in order to use it. 
<P/>
The function <C>ExponentOfPrime(<A>n</A>,<A>p</A>)</C> 
returns the exponent of the prime <A>p</A> 
in the prime factorization of <A>n</A>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ExponentOfPrime( 13577531, 11 ); 
3
]]>
</Example>

<ManSection>
   <Func Name="NextProbablyPrimeInt"
         Arg="n" />
<Description>
This function is in the process of being transferred from package &RCWA;: 
for now you should &LoadRCWA; in order to use it. 
<P/>
The function <C>NextProbablyPrimeInt(<A>n</A>)</C> 
does the same as <C>NextPrimeInt(<A>n</A>)</C> 
except that for reasons of performance it tests numbers only for
<C>IsProbablyPrimeInt(<A>n</A>)</C> instead of <C>IsPrimeInt(<A>n</A>)</C>.
For large <A>n</A>, this function is much faster than 
<C>NextPrimeInt(<A>n</A>)</C> 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> n := 2^251;
3618502788666131106986593281521497120414687020801267626233049500247285301248
gap> time;      
0
gap> NextProbablyPrimeInt( n );
3618502788666131106986593281521497120414687020801267626233049500247285301313
gap> time;                     
1
gap> NextPrimeInt( n );        
3618502788666131106986593281521497120414687020801267626233049500247285301313
gap> time;             
12346
]]>
</Example>

<ManSection>
   <Func Name="PrimeNumbersIterator"
         Arg="[chunksize]" />
<Description>
This function is in the process of being transferred from package &RCWA;: 
for now you should &LoadRCWA; in order to use it. 
<P/>
This function returns an iterator which runs over the prime numbers 
n ascending order; it takes an optional argument <C>chunksize</C> 
which specifies the length of the interval which is sieved in one go 
(the default is <M>10^7</M>), 
and which can be used to balance runtime vs. memory consumption. 
It is assumed that <C>chunksize</C> is larger than any gap between two 
consecutive primes within the range one intends to run the iterator over. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> iter := PrimeNumbersIterator();
<iterator>
gap> NextIterator( iter ); 
2
]]>
</Example>


</Section>


</Chapter>
