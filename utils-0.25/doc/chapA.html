<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Utils) - Appendix A: Appendix</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chapA"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chapA_mj.html">[MathJax on]</a></p>
<p><a id="X86E649828230497D" name="X86E649828230497D"></a></p>
<div class="ChapSects"><a href="chapA.html#X86E649828230497D">A <span class="Heading">Appendix</span></a>
</div>

<h3>A <span class="Heading">Appendix</span></h3>

<p>In order to deal with duplicate declarations and implementations of a global function <code class="code">glob</code>, the final sections of the library files <code class="file">oper.g</code> and <code class="file">global.g</code> have been modified as shown below.</p>

<p>There are three changes:</p>


<ul>
<li><p>The lists <var class="Arg">GLOBAL_REDECLARATION_LIST</var>, <var class="Arg">GLOBAL_REINSTALLATION_LIST</var> and <var class="Arg">GLOBAL_REDECLARATION_COUNT</var> are initialized.</p>

</li>
<li><p>Functions <code class="code">AllowGlobalRedeclaration</code> and <code class="code">AllowGlobalReinstallation</code> are added. The former adds function names (as strings) to the list <var class="Arg">GLOBAL_REDECLARATION_LIST</var>, while the latter adds the functions themselves to the list <var class="Arg">GLOBAL_REINSTALLATION_LIST</var>.</p>

</li>
<li><p>A conditional clause is inserted into the implementation of the functions <code class="code">DeclareGlobalFunction</code> and <code class="code">InstallGlobalFunction</code> which prevent their application to <code class="code">glob</code> a second time, but ensures a first application.</p>

</li>
</ul>
<p>The additional and modified code in <code class="file">oper.g</code> is listed here.</p>


<div class="example"><pre>

#############################################################################
##
#F  AllowGlobalRedeclaration( &lt;list&gt; ) . . function(s) may be declared twice
#F  AllowGlobalReinstallation( &lt;list&gt; ) . . . . . .  and implemented twice
## 
BIND_GLOBAL( "GLOBAL_REDECLARATION_LIST",   
    ShareSpecialObj([], "GLOBAL_REDECLARATION_LIST") );  
BIND_GLOBAL( "GLOBAL_REINSTALLATION_LIST",  
    ShareSpecialObj([], "GLOBAL_REINSTALLATION_LIST") );  
BIND_GLOBAL( "GLOBAL_REDECLARATION_COUNT", 
    ShareSpecialObj([], "GLOBAL_REDECLARATION_COUNT") );  

BIND_GLOBAL( "AllowGlobalRedeclaration", function( arg ) 
    local  L, pos, name, count;
    ##  form the arguments into a list L 
    if LEN_LIST(arg) = 1 then 
        if IS_STRING_REP( arg[1] ) then 
            L := arg;
        elif IS_LIST( arg[1] ) then 
            L := arg[1]; 
        else 
            L := [ ]; 
        fi;
    else 
        L := arg;
    fi;
    for name in L do 
        ##  avoid duplicate entries in GLOBAL_REDECLARATION_LIST 
        pos := POS_LIST_DEFAULT( GLOBAL_REDECLARATION_LIST, name, 0 ); 
        if ( pos = fail ) then 
            ADD_LIST( GLOBAL_REDECLARATION_LIST, name ); 
            ##  has name been declared already? 
            if ISBOUND_GLOBAL( name ) then 
                count := 1; 
            else 
                count := 0;
            fi; 
            ADD_LIST( GLOBAL_REDECLARATION_COUNT, count ); 
        fi;
    od;
end );

BIND_GLOBAL( "AllowGlobalReinstallation", function( arg ) 
    local  L, oper, posd, posi, name; 
    ##  form the arguments into a list L 
    if LEN_LIST(arg) = 1 then 
        if IS_FUNCTION( arg[1] ) then 
            L := arg;
        elif IS_LIST( arg[1] ) then 
            L := arg[1]; 
        else 
            L := [ ]; 
        fi;
    else 
        L := arg;
    fi;
    for oper in L do 
        ##  avoid duplicate entries in GLOBAL_REINSTALLATION_LIST 
        posi := POS_LIST_DEFAULT( GLOBAL_REINSTALLATION_LIST, oper, 0 ); 
        if ( ( posi = fail ) and IS_FUNCTION( oper ) ) then 
            ##  check that the two lists are consistently ordered 
            posi := LEN_LIST( GLOBAL_REINSTALLATION_LIST ) + 1; 
            name := NAME_FUNC( oper ); 
            posd := POS_LIST_DEFAULT( GLOBAL_REDECLARATION_LIST, name, 0 ); 
            if ( posd = posi ) then 
                ADD_LIST( GLOBAL_REINSTALLATION_LIST, oper ); 
            else 
                Error( "redeclaration and reinstallation lists inconsistent" );
            fi;
        fi;
    od;
end );


#############################################################################
##
#F  DeclareGlobalFunction( &lt;name&gt;, &lt;info&gt; ) . .  create a new global function
#F  InstallGlobalFunction( &lt;oper&gt;, &lt;func&gt; )
##
##  Global functions of the &amp;GAP; library must be distinguished from other
##  global variables (see &lt;C&gt;variable.g&lt;/C&gt;) because of the completion
##  mechanism.
##

BIND_GLOBAL( "GLOBAL_FUNCTION_NAMES", 
    ShareSpecialObj([], "GLOBAL_FUNCTION_NAMES") );

BIND_GLOBAL( "DeclareGlobalFunction", function( arg )
    local   pos,  count,  name;

    name := arg[1];
    ## special case: redeclaration is permitted so increment count for 'name' 
    if ( name in GLOBAL_REDECLARATION_LIST ) then 
        pos := POS_LIST_DEFAULT( GLOBAL_REDECLARATION_LIST, name, 0 );   
        count := GLOBAL_REDECLARATION_COUNT[pos] + 1; 
        GLOBAL_REDECLARATION_COUNT[pos] := count; 
        ## if already declared then there is nothing to do 
        if ISBOUND_GLOBAL( name ) then
            return; 
        fi;
    fi; 
    atomic GLOBAL_FUNCTION_NAMES do
    ADD_SET( GLOBAL_FUNCTION_NAMES, IMMUTABLE_COPY_OBJ(name) );
    od;
    BIND_GLOBAL( name, NEW_OPERATION_ARGS( name ) ); 
end );

BIND_GLOBAL( "InstallGlobalFunction", function( arg )
    local   oper,  info,  func,  pos;

    if LEN_LIST(arg) = 3  then
        oper := arg[1];
        info := arg[2];
        func := arg[3];
    else
        oper := arg[1];
        func := arg[2];
    fi;
    if IS_STRING( oper ) then
        oper := VALUE_GLOBAL( oper );
    fi;
    ## special case: reinstallation is permitted so check declaration number 
    if ( oper in GLOBAL_REINSTALLATION_LIST ) then 
        pos := POS_LIST_DEFAULT( GLOBAL_REINSTALLATION_LIST, oper, 0 );   
        if ( GLOBAL_REDECLARATION_COUNT[pos] &gt;= 2 ) then 
            ## there have been 2 declarations so this is a repeat installation 
            return; 
        fi; 
    fi;  
    atomic readonly GLOBAL_FUNCTION_NAMES do
    if NAME_FUNC(func) in GLOBAL_FUNCTION_NAMES then
        Error("you cannot install a global function for another global ",
              "function,\nuse `DeclareSynonym' instead!");
    fi;
    INSTALL_METHOD_ARGS( oper, func );
    od;
end );

</pre></div>

<p>For functions installed directly using <code class="code">BIND_GLOBAL</code> lists <var class="Arg">GLOBAL_REBINDING_LIST</var> and <var class="Arg">GLOBAL_REBINDING_COUNT</var> are used, and the function <code class="code">AllowGlobalRebinding</code> added. The additional and modified code in <code class="file">global.g</code> is listed here.</p>


<div class="example"><pre>

GLOBAL_REBINDING_LIST := [ ]; 
GLOBAL_REBINDING_COUNT := [ ]; 

#############################################################################
##
#F  BIND_GLOBAL ( &lt;name&gt;, &lt;val&gt; ) . . . . . .sets a global variable 'safely'
##
##  BIND_GLOBAL ( &lt;name&gt;, &lt;val&gt; ) sets the global variable named by
##  the string &lt;name&gt; to the value &lt;val&gt;, provided it was previously
##  unbound, and makes it read-only. This is intended to be the normal
##  way to create and set "official" global variable (such as
##  Operations and Categories)
##
  
BIND_GLOBAL := function( name, val)
local   pos,  count; 
    ## special case: rebinding is permitted so increment count for 'name'  
    if ( name in GLOBAL_REBINDING_LIST ) then 
        pos := POS_LIST_DEFAULT( GLOBAL_REBINDING_LIST, name, 0 );   
        count := GLOBAL_REBINDING_COUNT[pos] + 1; 
        GLOBAL_REBINDING_COUNT[pos] := count; 
        ## if already bound then there is nothing to do 
        if ISBOUND_GLOBAL( name ) then 
            return; 
        fi;
    fi; 
    if not REREADING and ISBOUND_GLOBAL( name ) then
        if (IS_READ_ONLY_GLOBAL(name)) then
            Error("BIND_GLOBAL: variable `", name, "' must be unbound");
        else
            Print("#W BIND_GLOBAL: variable `", name,"' already has a value\n");
        fi;
    fi;
    ASS_GVAR(name, val);
    MAKE_READ_ONLY_GLOBAL(name);
    return val;
end;

#############################################################################
##
#F  AllowGlobalRebinding( &lt;list&gt; ) . . function(s) may be BIND_GLOBAL'ed twice
##
BIND_GLOBAL( "AllowGlobalRebinding", function( arg ) 
    local  L, pos, name, val;
    ##  form the arguments into a list L 
    if LEN_LIST(arg) = 1 then 
        if IS_STRING_REP( arg[1] ) then 
            L := arg;
        elif IS_LIST( arg[1] ) then 
            L := arg[1]; 
        else 
            L := [ ]; 
        fi;
    else 
        L := arg;
    fi;
    for name in L do 
        ##  avoid duplicate entries in GLOBAL_REBINDING_LIST 
        pos := POS_LIST_DEFAULT( GLOBAL_REBINDING_LIST, name, 0 ); 
        if ( pos = fail ) then 
            ADD_LIST( GLOBAL_REBINDING_LIST, name ); 
            ##  has 'name' been declared already? 
            if ISBOUND_GLOBAL( name ) then 
                val := 1; 
            else 
                val := 0;
            fi; 
            ADD_LIST( GLOBAL_REBINDING_COUNT, val ); 
        fi;
    od;
end );

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
