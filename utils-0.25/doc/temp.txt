
The process for transferring utility functions from an existing package 
(the Home package, say) to Utils should only require the following steps from Home's author(s). 
  -  Offer functions for inclusion. This may be simply done by emailing a list of functions. More usefully, email the following files: home.gd, home.gi, home.tst and home.xml, 
  -  Once the functions have been included in Utils, and a new version of Utils released, remove the functions from Home, and add Utils to the list of required packages in PackageInfo.g. 

  
The following procedure is suggested for transferring a function func from Home to Utils.
There are two cases to consider. 
If the functions being transferred have names of the form Home_this_func, then it is probably sensible to change the name in Utils, to ThisFunc say.  In this case there is no duplication of declarations or implementations.  However, once the functions have appeared in a release of  Utils, the author(s) of Home will 
have a significant amount of editing to do. 

In the second case, the functions names in Utils will be the same as in Home, and the following steps  are proposed. 
  -  The package Home is added to the required packages in Utils. 
  -  Copy the code for func into the appropriate *.gd, *.gi files in Utils. 
For attributes and properties this duplication produces no obvious effect in GAP.  
For operations the following warning is printed: 
#I  equal requirements in multiple declarations for operation `func'. 
For a global function glob duplicate declarations produce an error.  To avoid this three steps are required. 
 : The function BIND_GLOBAL in gap4r8/lib/global.g is replaced by the code shown below. 
 : Secondly,  "glob" is added to the list UTILS_FUNCTION_NAMES in utils/lib/names.gd. 
 : Thirdly, the installed method for glob is surrounded by a conditional clause of the form: 
if ( UTILS_FUNCTION_STATUS[ 
    Position( UTILS_FUNCTION_NAMES, "glob" )] = 0 ) then 
        InstallGlobalFunction( glob,
        . . . 
        end ); 
fi;

  -  Copy and edit any tests and documentation into the corresponding *.tst, *.xml files in Utils. 
  -  When all is working satisfactorily, publish a new version of Utils; notify the author(s) of Home, asking them to check that the functions are working correctly. 
  -  The author(s) of Home remove the declaration and implementation of func from their files, and (possibly) edit reference to func in their manual.  
  -  
They make Utils a required package in PackageInfo.g and publish a new release of 
Home. 
  -  Now glob can be removed from UTILS_FUNCTION_NAMES, and the conditional clause removed from the implementation file in Utils. 

Modification to global.g
========================
In order to deal with duplicate declarations of a global function func, the final section of the library file global.g has been modified as shown below. There are two changes:
  -  The list UTILS_FUNCTION_NAMES is initialized. 
  -  A conditional clause is inserted into the implementation of the function 
BIND_GLOBAL which prevents func being bound twice. 

It is envisioned that these changes to global.g will be temporary, during the three-month period while packages are adjusting to the beta release of GAP 4.8. 


UTILS_FUNCTION_NAMES := [];

#############################################################################
##
#F  BIND_GLOBAL ( <name>, <val> ) . . . . . .sets a global variable 'safely'
##
##  BIND_GLOBAL ( <name>, <val> ) sets the global variable named by
##  the string <name> to the value <val>, provided it was previously
##  unbound, and makes it read-only. This is intended to be the normal
##  way to create and set "official" global variable (such as
##  Operations and Categories)
##
  
BIND_GLOBAL := function( name, val)
if not ( ISBOUND_GLOBAL( name ) and 
         ( name in UTILS_FUNCTION_NAMES ) ) then 
    if not REREADING and ISBOUND_GLOBAL( name ) then
        if (IS_READ_ONLY_GLOBAL(name)) then
            Error("BIND_GLOBAL: variable `", name, "' must be unbound");
        else
            Print("#W BIND_GLOBAL: variable `", name,"' already has a value\n");
        fi;
    fi;
    ASS_GVAR(name, val);
    MAKE_READ_ONLY_GLOBAL(name);
    return val;
fi;
end;
